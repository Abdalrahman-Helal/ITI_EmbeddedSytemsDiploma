
ITI23_FreeRTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005c12  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002a  00800060  00005c12  00005ca6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000045f  0080008a  0080008a  00005cd0  2**0
                  ALLOC
  3 .stab         000081c0  00000000  00000000  00005cd0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000052b7  00000000  00000000  0000de90  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00013147  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00013287  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  000133f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00015040  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00015f2b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00016cd8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00016e38  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  000170c5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00017893  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 71 0e 	jmp	0x1ce2	; 0x1ce2 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 e1       	ldi	r30, 0x12	; 18
      68:	fc e5       	ldi	r31, 0x5C	; 92
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 38       	cpi	r26, 0x8A	; 138
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	14 e0       	ldi	r17, 0x04	; 4
      78:	aa e8       	ldi	r26, 0x8A	; 138
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 3e       	cpi	r26, 0xE9	; 233
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 5d 06 	call	0xcba	; 0xcba <main>
      8a:	0c 94 07 2e 	jmp	0x5c0e	; 0x5c0e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 c7 2d 	jmp	0x5b8e	; 0x5b8e <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a1 e8       	ldi	r26, 0x81	; 129
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 e3 2d 	jmp	0x5bc6	; 0x5bc6 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 d3 2d 	jmp	0x5ba6	; 0x5ba6 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 ef 2d 	jmp	0x5bde	; 0x5bde <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 d3 2d 	jmp	0x5ba6	; 0x5ba6 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 ef 2d 	jmp	0x5bde	; 0x5bde <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 c7 2d 	jmp	0x5b8e	; 0x5b8e <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	81 e8       	ldi	r24, 0x81	; 129
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 e3 2d 	jmp	0x5bc6	; 0x5bc6 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 d3 2d 	jmp	0x5ba6	; 0x5ba6 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 ef 2d 	jmp	0x5bde	; 0x5bde <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 d3 2d 	jmp	0x5ba6	; 0x5ba6 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 ef 2d 	jmp	0x5bde	; 0x5bde <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 d3 2d 	jmp	0x5ba6	; 0x5ba6 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 ef 2d 	jmp	0x5bde	; 0x5bde <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 d7 2d 	jmp	0x5bae	; 0x5bae <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 f3 2d 	jmp	0x5be6	; 0x5be6 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <Task1>:

u8 Global_Flag = 0;


void Task1(void *pvParameters)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <Task1+0x6>
     b4c:	0f 92       	push	r0
     b4e:	cd b7       	in	r28, 0x3d	; 61
     b50:	de b7       	in	r29, 0x3e	; 62
     b52:	9b 83       	std	Y+3, r25	; 0x03
     b54:	8a 83       	std	Y+2, r24	; 0x02
	u8 Flag = 0;
     b56:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		if(Flag == 0)
     b58:	89 81       	ldd	r24, Y+1	; 0x01
     b5a:	88 23       	and	r24, r24
     b5c:	41 f4       	brne	.+16     	; 0xb6e <Task1+0x28>
		{
			MDIO_vSetPinVal(DIO_PORTA , PIN0 , DIO_HIGH);
     b5e:	80 e0       	ldi	r24, 0x00	; 0
     b60:	60 e0       	ldi	r22, 0x00	; 0
     b62:	41 e0       	ldi	r20, 0x01	; 1
     b64:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <MDIO_vSetPinVal>
			Flag = 1;
     b68:	81 e0       	ldi	r24, 0x01	; 1
     b6a:	89 83       	std	Y+1, r24	; 0x01
     b6c:	06 c0       	rjmp	.+12     	; 0xb7a <Task1+0x34>
		}
		else
		{
			MDIO_vSetPinVal(DIO_PORTA , PIN0 , DIO_LOW);
     b6e:	80 e0       	ldi	r24, 0x00	; 0
     b70:	60 e0       	ldi	r22, 0x00	; 0
     b72:	40 e0       	ldi	r20, 0x00	; 0
     b74:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <MDIO_vSetPinVal>
			Flag = 0;
     b78:	19 82       	std	Y+1, r1	; 0x01
		}
		vTaskDelay(500);
     b7a:	84 ef       	ldi	r24, 0xF4	; 244
     b7c:	91 e0       	ldi	r25, 0x01	; 1
     b7e:	0e 94 24 18 	call	0x3048	; 0x3048 <vTaskDelay>
     b82:	ea cf       	rjmp	.-44     	; 0xb58 <Task1+0x12>

00000b84 <Task2>:




void Task2(void *pvParameter)
{
     b84:	df 93       	push	r29
     b86:	cf 93       	push	r28
     b88:	00 d0       	rcall	.+0      	; 0xb8a <Task2+0x6>
     b8a:	0f 92       	push	r0
     b8c:	cd b7       	in	r28, 0x3d	; 61
     b8e:	de b7       	in	r29, 0x3e	; 62
     b90:	9b 83       	std	Y+3, r25	; 0x03
     b92:	8a 83       	std	Y+2, r24	; 0x02
	u8 Flag = 0;
     b94:	19 82       	std	Y+1, r1	; 0x01
	while(1)
	{
		if(Flag == 0)
     b96:	89 81       	ldd	r24, Y+1	; 0x01
     b98:	88 23       	and	r24, r24
     b9a:	41 f4       	brne	.+16     	; 0xbac <Task2+0x28>
		{
			MDIO_vSetPinVal(DIO_PORTA , PIN1 , DIO_HIGH);
     b9c:	80 e0       	ldi	r24, 0x00	; 0
     b9e:	61 e0       	ldi	r22, 0x01	; 1
     ba0:	41 e0       	ldi	r20, 0x01	; 1
     ba2:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <MDIO_vSetPinVal>
			Flag = 1;
     ba6:	81 e0       	ldi	r24, 0x01	; 1
     ba8:	89 83       	std	Y+1, r24	; 0x01
     baa:	06 c0       	rjmp	.+12     	; 0xbb8 <Task2+0x34>
		}
		else
		{
			MDIO_vSetPinVal(DIO_PORTA , PIN1 , DIO_LOW);
     bac:	80 e0       	ldi	r24, 0x00	; 0
     bae:	61 e0       	ldi	r22, 0x01	; 1
     bb0:	40 e0       	ldi	r20, 0x00	; 0
     bb2:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <MDIO_vSetPinVal>
			Flag = 0;
     bb6:	19 82       	std	Y+1, r1	; 0x01
		}
		vTaskDelay(1000);
     bb8:	88 ee       	ldi	r24, 0xE8	; 232
     bba:	93 e0       	ldi	r25, 0x03	; 3
     bbc:	0e 94 24 18 	call	0x3048	; 0x3048 <vTaskDelay>
     bc0:	ea cf       	rjmp	.-44     	; 0xb96 <Task2+0x12>

00000bc2 <Task3>:
	}

}

void Task3(void *pvParameter)
{
     bc2:	df 93       	push	r29
     bc4:	cf 93       	push	r28
     bc6:	00 d0       	rcall	.+0      	; 0xbc8 <Task3+0x6>
     bc8:	cd b7       	in	r28, 0x3d	; 61
     bca:	de b7       	in	r29, 0x3e	; 62
     bcc:	9a 83       	std	Y+2, r25	; 0x02
     bce:	89 83       	std	Y+1, r24	; 0x01
	while(1)
	{	if(Global_Flag == 0)
     bd0:	80 91 8a 00 	lds	r24, 0x008A
     bd4:	88 23       	and	r24, r24
     bd6:	e1 f7       	brne	.-8      	; 0xbd0 <Task3+0xe>
	{
		Global_Flag = 1;
     bd8:	81 e0       	ldi	r24, 0x01	; 1
     bda:	80 93 8a 00 	sts	0x008A, r24
		LCD_SendString("Task 3");
     bde:	80 e6       	ldi	r24, 0x60	; 96
     be0:	90 e0       	ldi	r25, 0x00	; 0
     be2:	0e 94 74 2c 	call	0x58e8	; 0x58e8 <LCD_SendString>
		Global_Flag =0;
     be6:	10 92 8a 00 	sts	0x008A, r1
		vTaskDelay(1000);
     bea:	88 ee       	ldi	r24, 0xE8	; 232
     bec:	93 e0       	ldi	r25, 0x03	; 3
     bee:	0e 94 24 18 	call	0x3048	; 0x3048 <vTaskDelay>
     bf2:	ee cf       	rjmp	.-36     	; 0xbd0 <Task3+0xe>

00000bf4 <Task4>:
	}

}

void Task4(void *pvParameter)
{
     bf4:	df 93       	push	r29
     bf6:	cf 93       	push	r28
     bf8:	00 d0       	rcall	.+0      	; 0xbfa <Task4+0x6>
     bfa:	cd b7       	in	r28, 0x3d	; 61
     bfc:	de b7       	in	r29, 0x3e	; 62
     bfe:	9a 83       	std	Y+2, r25	; 0x02
     c00:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		if(Global_Flag == 0)
     c02:	80 91 8a 00 	lds	r24, 0x008A
     c06:	88 23       	and	r24, r24
     c08:	e1 f7       	brne	.-8      	; 0xc02 <Task4+0xe>
		{
			Global_Flag = 1;
     c0a:	81 e0       	ldi	r24, 0x01	; 1
     c0c:	80 93 8a 00 	sts	0x008A, r24
			LCD_SendString("Task 4");
     c10:	87 e6       	ldi	r24, 0x67	; 103
     c12:	90 e0       	ldi	r25, 0x00	; 0
     c14:	0e 94 74 2c 	call	0x58e8	; 0x58e8 <LCD_SendString>
			Global_Flag =0;
     c18:	10 92 8a 00 	sts	0x008A, r1
			vTaskDelay(1000);
     c1c:	88 ee       	ldi	r24, 0xE8	; 232
     c1e:	93 e0       	ldi	r25, 0x03	; 3
     c20:	0e 94 24 18 	call	0x3048	; 0x3048 <vTaskDelay>
     c24:	ee cf       	rjmp	.-36     	; 0xc02 <Task4+0xe>

00000c26 <Task5>:
	}

}

void Task5(void *pvParameter)
{
     c26:	df 93       	push	r29
     c28:	cf 93       	push	r28
     c2a:	00 d0       	rcall	.+0      	; 0xc2c <Task5+0x6>
     c2c:	cd b7       	in	r28, 0x3d	; 61
     c2e:	de b7       	in	r29, 0x3e	; 62
     c30:	9a 83       	std	Y+2, r25	; 0x02
     c32:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		if(xSemaphoreTake(xSemaphore , (TickType_t)portMAX_DELAY) == pdTRUE)
     c34:	80 91 e7 04 	lds	r24, 0x04E7
     c38:	90 91 e8 04 	lds	r25, 0x04E8
     c3c:	6f ef       	ldi	r22, 0xFF	; 255
     c3e:	7f ef       	ldi	r23, 0xFF	; 255
     c40:	0e 94 84 11 	call	0x2308	; 0x2308 <xQueueSemaphoreTake>
     c44:	81 30       	cpi	r24, 0x01	; 1
     c46:	79 f4       	brne	.+30     	; 0xc66 <Task5+0x40>
		{
			LCD_SendString("Task 5");
     c48:	8e e6       	ldi	r24, 0x6E	; 110
     c4a:	90 e0       	ldi	r25, 0x00	; 0
     c4c:	0e 94 74 2c 	call	0x58e8	; 0x58e8 <LCD_SendString>
			xSemaphoreGive(xSemaphore);
     c50:	80 91 e7 04 	lds	r24, 0x04E7
     c54:	90 91 e8 04 	lds	r25, 0x04E8
     c58:	60 e0       	ldi	r22, 0x00	; 0
     c5a:	70 e0       	ldi	r23, 0x00	; 0
     c5c:	40 e0       	ldi	r20, 0x00	; 0
     c5e:	50 e0       	ldi	r21, 0x00	; 0
     c60:	20 e0       	ldi	r18, 0x00	; 0
     c62:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <xQueueGenericSend>
		}
		vTaskDelay(1000);
     c66:	88 ee       	ldi	r24, 0xE8	; 232
     c68:	93 e0       	ldi	r25, 0x03	; 3
     c6a:	0e 94 24 18 	call	0x3048	; 0x3048 <vTaskDelay>
     c6e:	e2 cf       	rjmp	.-60     	; 0xc34 <Task5+0xe>

00000c70 <Task6>:
	}
}

void Task6(void *pvParameter)
{
     c70:	df 93       	push	r29
     c72:	cf 93       	push	r28
     c74:	00 d0       	rcall	.+0      	; 0xc76 <Task6+0x6>
     c76:	cd b7       	in	r28, 0x3d	; 61
     c78:	de b7       	in	r29, 0x3e	; 62
     c7a:	9a 83       	std	Y+2, r25	; 0x02
     c7c:	89 83       	std	Y+1, r24	; 0x01

	while(1)
	{
		if(xSemaphoreTake(xSemaphore , (TickType_t) portMAX_DELAY) == pdTRUE)
     c7e:	80 91 e7 04 	lds	r24, 0x04E7
     c82:	90 91 e8 04 	lds	r25, 0x04E8
     c86:	6f ef       	ldi	r22, 0xFF	; 255
     c88:	7f ef       	ldi	r23, 0xFF	; 255
     c8a:	0e 94 84 11 	call	0x2308	; 0x2308 <xQueueSemaphoreTake>
     c8e:	81 30       	cpi	r24, 0x01	; 1
     c90:	79 f4       	brne	.+30     	; 0xcb0 <Task6+0x40>
		{
			LCD_SendString("Task 6");
     c92:	85 e7       	ldi	r24, 0x75	; 117
     c94:	90 e0       	ldi	r25, 0x00	; 0
     c96:	0e 94 74 2c 	call	0x58e8	; 0x58e8 <LCD_SendString>
			xSemaphoreGive(xSemaphore);
     c9a:	80 91 e7 04 	lds	r24, 0x04E7
     c9e:	90 91 e8 04 	lds	r25, 0x04E8
     ca2:	60 e0       	ldi	r22, 0x00	; 0
     ca4:	70 e0       	ldi	r23, 0x00	; 0
     ca6:	40 e0       	ldi	r20, 0x00	; 0
     ca8:	50 e0       	ldi	r21, 0x00	; 0
     caa:	20 e0       	ldi	r18, 0x00	; 0
     cac:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <xQueueGenericSend>
		}
		vTaskDelay(1000);
     cb0:	88 ee       	ldi	r24, 0xE8	; 232
     cb2:	93 e0       	ldi	r25, 0x03	; 3
     cb4:	0e 94 24 18 	call	0x3048	; 0x3048 <vTaskDelay>
     cb8:	e2 cf       	rjmp	.-60     	; 0xc7e <Task6+0xe>

00000cba <main>:

}


void main(void)
{
     cba:	ef 92       	push	r14
     cbc:	ff 92       	push	r15
     cbe:	0f 93       	push	r16
     cc0:	df 93       	push	r29
     cc2:	cf 93       	push	r28
     cc4:	cd b7       	in	r28, 0x3d	; 61
     cc6:	de b7       	in	r29, 0x3e	; 62

	LCD_InitPortDir();
     cc8:	0e 94 ac 28 	call	0x5158	; 0x5158 <LCD_InitPortDir>
	LCD_Init();
     ccc:	0e 94 02 2a 	call	0x5404	; 0x5404 <LCD_Init>

	// LEDs Init

	MDIO_vSetPinDir(DIO_PORTA , PIN0 , DIO_OUTPUT);
     cd0:	80 e0       	ldi	r24, 0x00	; 0
     cd2:	60 e0       	ldi	r22, 0x00	; 0
     cd4:	41 e0       	ldi	r20, 0x01	; 1
     cd6:	0e 94 b6 24 	call	0x496c	; 0x496c <MDIO_vSetPinDir>
	MDIO_vSetPinDir(DIO_PORTA , PIN1 , DIO_OUTPUT);
     cda:	80 e0       	ldi	r24, 0x00	; 0
     cdc:	61 e0       	ldi	r22, 0x01	; 1
     cde:	41 e0       	ldi	r20, 0x01	; 1
     ce0:	0e 94 b6 24 	call	0x496c	; 0x496c <MDIO_vSetPinDir>
	//	xTaskCreate(Task2 , NULL , 100 , NULL , 1, NULL );

//	xTaskCreate(Task3 , NULL , 100 , NULL , 1, NULL );
//	xTaskCreate(Task4 , NULL , 100 , NULL , 1, NULL );

	xTaskCreate(Task5 , NULL , 100 , NULL , 1, NULL );
     ce4:	83 e1       	ldi	r24, 0x13	; 19
     ce6:	96 e0       	ldi	r25, 0x06	; 6
     ce8:	60 e0       	ldi	r22, 0x00	; 0
     cea:	70 e0       	ldi	r23, 0x00	; 0
     cec:	44 e6       	ldi	r20, 0x64	; 100
     cee:	50 e0       	ldi	r21, 0x00	; 0
     cf0:	20 e0       	ldi	r18, 0x00	; 0
     cf2:	30 e0       	ldi	r19, 0x00	; 0
     cf4:	01 e0       	ldi	r16, 0x01	; 1
     cf6:	ee 24       	eor	r14, r14
     cf8:	ff 24       	eor	r15, r15
     cfa:	0e 94 94 15 	call	0x2b28	; 0x2b28 <xTaskCreate>
	xTaskCreate(Task6 , NULL , 100 , NULL , 1, NULL );
     cfe:	88 e3       	ldi	r24, 0x38	; 56
     d00:	96 e0       	ldi	r25, 0x06	; 6
     d02:	60 e0       	ldi	r22, 0x00	; 0
     d04:	70 e0       	ldi	r23, 0x00	; 0
     d06:	44 e6       	ldi	r20, 0x64	; 100
     d08:	50 e0       	ldi	r21, 0x00	; 0
     d0a:	20 e0       	ldi	r18, 0x00	; 0
     d0c:	30 e0       	ldi	r19, 0x00	; 0
     d0e:	01 e0       	ldi	r16, 0x01	; 1
     d10:	ee 24       	eor	r14, r14
     d12:	ff 24       	eor	r15, r15
     d14:	0e 94 94 15 	call	0x2b28	; 0x2b28 <xTaskCreate>

	vSemaphoreCreateBinary	(xSemaphore);
     d18:	81 e0       	ldi	r24, 0x01	; 1
     d1a:	60 e0       	ldi	r22, 0x00	; 0
     d1c:	43 e0       	ldi	r20, 0x03	; 3
     d1e:	0e 94 fa 0e 	call	0x1df4	; 0x1df4 <xQueueGenericCreate>
     d22:	90 93 e8 04 	sts	0x04E8, r25
     d26:	80 93 e7 04 	sts	0x04E7, r24
     d2a:	80 91 e7 04 	lds	r24, 0x04E7
     d2e:	90 91 e8 04 	lds	r25, 0x04E8
     d32:	00 97       	sbiw	r24, 0x00	; 0
     d34:	59 f0       	breq	.+22     	; 0xd4c <main+0x92>
     d36:	80 91 e7 04 	lds	r24, 0x04E7
     d3a:	90 91 e8 04 	lds	r25, 0x04E8
     d3e:	60 e0       	ldi	r22, 0x00	; 0
     d40:	70 e0       	ldi	r23, 0x00	; 0
     d42:	40 e0       	ldi	r20, 0x00	; 0
     d44:	50 e0       	ldi	r21, 0x00	; 0
     d46:	20 e0       	ldi	r18, 0x00	; 0
     d48:	0e 94 80 0f 	call	0x1f00	; 0x1f00 <xQueueGenericSend>

	// RTOS Start
	vTaskStartScheduler();
     d4c:	0e 94 d1 1a 	call	0x35a2	; 0x35a2 <vTaskStartScheduler>
     d50:	ff cf       	rjmp	.-2      	; 0xd50 <main+0x96>

00000d52 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	EventGroupHandle_t xEventGroupCreate( void )
	{
     d52:	df 93       	push	r29
     d54:	cf 93       	push	r28
     d56:	00 d0       	rcall	.+0      	; 0xd58 <xEventGroupCreate+0x6>
     d58:	cd b7       	in	r28, 0x3d	; 61
     d5a:	de b7       	in	r29, 0x3e	; 62
		TickType_t alignment requirements the cast is safe.  In other cases,
		where the natural word size of the architecture is less than
		sizeof( TickType_t ), the TickType_t variables will be accessed in two
		or more reads operations, and the alignment requirements is only that
		of each individual read. */
		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
     d5c:	8b e0       	ldi	r24, 0x0B	; 11
     d5e:	90 e0       	ldi	r25, 0x00	; 0
     d60:	0e 94 ee 09 	call	0x13dc	; 0x13dc <pvPortMalloc>
     d64:	9a 83       	std	Y+2, r25	; 0x02
     d66:	89 83       	std	Y+1, r24	; 0x01

		if( pxEventBits != NULL )
     d68:	89 81       	ldd	r24, Y+1	; 0x01
     d6a:	9a 81       	ldd	r25, Y+2	; 0x02
     d6c:	00 97       	sbiw	r24, 0x00	; 0
     d6e:	49 f0       	breq	.+18     	; 0xd82 <xEventGroupCreate+0x30>
		{
			pxEventBits->uxEventBits = 0;
     d70:	e9 81       	ldd	r30, Y+1	; 0x01
     d72:	fa 81       	ldd	r31, Y+2	; 0x02
     d74:	11 82       	std	Z+1, r1	; 0x01
     d76:	10 82       	st	Z, r1
			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
     d78:	89 81       	ldd	r24, Y+1	; 0x01
     d7a:	9a 81       	ldd	r25, Y+2	; 0x02
     d7c:	02 96       	adiw	r24, 0x02	; 2
     d7e:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vListInitialise>
		else
		{
			traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
		}

		return pxEventBits;
     d82:	89 81       	ldd	r24, Y+1	; 0x01
     d84:	9a 81       	ldd	r25, Y+2	; 0x02
	}
     d86:	0f 90       	pop	r0
     d88:	0f 90       	pop	r0
     d8a:	cf 91       	pop	r28
     d8c:	df 91       	pop	r29
     d8e:	08 95       	ret

00000d90 <xEventGroupSync>:

#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
{
     d90:	df 93       	push	r29
     d92:	cf 93       	push	r28
     d94:	cd b7       	in	r28, 0x3d	; 61
     d96:	de b7       	in	r29, 0x3e	; 62
     d98:	60 97       	sbiw	r28, 0x10	; 16
     d9a:	0f b6       	in	r0, 0x3f	; 63
     d9c:	f8 94       	cli
     d9e:	de bf       	out	0x3e, r29	; 62
     da0:	0f be       	out	0x3f, r0	; 63
     da2:	cd bf       	out	0x3d, r28	; 61
     da4:	9a 87       	std	Y+10, r25	; 0x0a
     da6:	89 87       	std	Y+9, r24	; 0x09
     da8:	7c 87       	std	Y+12, r23	; 0x0c
     daa:	6b 87       	std	Y+11, r22	; 0x0b
     dac:	5e 87       	std	Y+14, r21	; 0x0e
     dae:	4d 87       	std	Y+13, r20	; 0x0d
     db0:	38 8b       	std	Y+16, r19	; 0x10
     db2:	2f 87       	std	Y+15, r18	; 0x0f
EventBits_t uxOriginalBitValue, uxReturn;
EventGroup_t *pxEventBits = xEventGroup;
     db4:	89 85       	ldd	r24, Y+9	; 0x09
     db6:	9a 85       	ldd	r25, Y+10	; 0x0a
     db8:	9c 83       	std	Y+4, r25	; 0x04
     dba:	8b 83       	std	Y+3, r24	; 0x03
BaseType_t xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     dbc:	19 82       	std	Y+1, r1	; 0x01
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     dbe:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskSuspendAll>
	{
		uxOriginalBitValue = pxEventBits->uxEventBits;
     dc2:	eb 81       	ldd	r30, Y+3	; 0x03
     dc4:	fc 81       	ldd	r31, Y+4	; 0x04
     dc6:	80 81       	ld	r24, Z
     dc8:	91 81       	ldd	r25, Z+1	; 0x01
     dca:	98 87       	std	Y+8, r25	; 0x08
     dcc:	8f 83       	std	Y+7, r24	; 0x07

		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
     dce:	89 85       	ldd	r24, Y+9	; 0x09
     dd0:	9a 85       	ldd	r25, Y+10	; 0x0a
     dd2:	2b 85       	ldd	r18, Y+11	; 0x0b
     dd4:	3c 85       	ldd	r19, Y+12	; 0x0c
     dd6:	b9 01       	movw	r22, r18
     dd8:	0e 94 9f 08 	call	0x113e	; 0x113e <xEventGroupSetBits>

		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
     ddc:	2f 81       	ldd	r18, Y+7	; 0x07
     dde:	38 85       	ldd	r19, Y+8	; 0x08
     de0:	8b 85       	ldd	r24, Y+11	; 0x0b
     de2:	9c 85       	ldd	r25, Y+12	; 0x0c
     de4:	28 2b       	or	r18, r24
     de6:	39 2b       	or	r19, r25
     de8:	8d 85       	ldd	r24, Y+13	; 0x0d
     dea:	9e 85       	ldd	r25, Y+14	; 0x0e
     dec:	28 23       	and	r18, r24
     dee:	39 23       	and	r19, r25
     df0:	8d 85       	ldd	r24, Y+13	; 0x0d
     df2:	9e 85       	ldd	r25, Y+14	; 0x0e
     df4:	28 17       	cp	r18, r24
     df6:	39 07       	cpc	r19, r25
     df8:	c9 f4       	brne	.+50     	; 0xe2c <xEventGroupSync+0x9c>
		{
			/* All the rendezvous bits are now set - no need to block. */
			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
     dfa:	2f 81       	ldd	r18, Y+7	; 0x07
     dfc:	38 85       	ldd	r19, Y+8	; 0x08
     dfe:	8b 85       	ldd	r24, Y+11	; 0x0b
     e00:	9c 85       	ldd	r25, Y+12	; 0x0c
     e02:	82 2b       	or	r24, r18
     e04:	93 2b       	or	r25, r19
     e06:	9e 83       	std	Y+6, r25	; 0x06
     e08:	8d 83       	std	Y+5, r24	; 0x05

			/* Rendezvous always clear the bits.  They will have been cleared
			already unless this is the only task in the rendezvous. */
			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     e0a:	eb 81       	ldd	r30, Y+3	; 0x03
     e0c:	fc 81       	ldd	r31, Y+4	; 0x04
     e0e:	20 81       	ld	r18, Z
     e10:	31 81       	ldd	r19, Z+1	; 0x01
     e12:	8d 85       	ldd	r24, Y+13	; 0x0d
     e14:	9e 85       	ldd	r25, Y+14	; 0x0e
     e16:	80 95       	com	r24
     e18:	90 95       	com	r25
     e1a:	82 23       	and	r24, r18
     e1c:	93 23       	and	r25, r19
     e1e:	eb 81       	ldd	r30, Y+3	; 0x03
     e20:	fc 81       	ldd	r31, Y+4	; 0x04
     e22:	91 83       	std	Z+1, r25	; 0x01
     e24:	80 83       	st	Z, r24

			xTicksToWait = 0;
     e26:	18 8a       	std	Y+16, r1	; 0x10
     e28:	1f 86       	std	Y+15, r1	; 0x0f
     e2a:	1e c0       	rjmp	.+60     	; 0xe68 <xEventGroupSync+0xd8>
		}
		else
		{
			if( xTicksToWait != ( TickType_t ) 0 )
     e2c:	8f 85       	ldd	r24, Y+15	; 0x0f
     e2e:	98 89       	ldd	r25, Y+16	; 0x10
     e30:	00 97       	sbiw	r24, 0x00	; 0
     e32:	91 f0       	breq	.+36     	; 0xe58 <xEventGroupSync+0xc8>
				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

				/* Store the bits that the calling task is waiting for in the
				task's event list item so the kernel knows when a match is
				found.  Then enter the blocked state. */
				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
     e34:	8b 81       	ldd	r24, Y+3	; 0x03
     e36:	9c 81       	ldd	r25, Y+4	; 0x04
     e38:	bc 01       	movw	r22, r24
     e3a:	6e 5f       	subi	r22, 0xFE	; 254
     e3c:	7f 4f       	sbci	r23, 0xFF	; 255
     e3e:	8d 85       	ldd	r24, Y+13	; 0x0d
     e40:	9e 85       	ldd	r25, Y+14	; 0x0e
     e42:	9c 01       	movw	r18, r24
     e44:	35 60       	ori	r19, 0x05	; 5
     e46:	4f 85       	ldd	r20, Y+15	; 0x0f
     e48:	58 89       	ldd	r21, Y+16	; 0x10
     e4a:	cb 01       	movw	r24, r22
     e4c:	b9 01       	movw	r22, r18
     e4e:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <vTaskPlaceOnUnorderedEventList>

				/* This assignment is obsolete as uxReturn will get set after
				the task unblocks, but some compilers mistakenly generate a
				warning about uxReturn being returned without being set if the
				assignment is omitted. */
				uxReturn = 0;
     e52:	1e 82       	std	Y+6, r1	; 0x06
     e54:	1d 82       	std	Y+5, r1	; 0x05
     e56:	08 c0       	rjmp	.+16     	; 0xe68 <xEventGroupSync+0xd8>
			}
			else
			{
				/* The rendezvous bits were not set, but no block time was
				specified - just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
     e58:	eb 81       	ldd	r30, Y+3	; 0x03
     e5a:	fc 81       	ldd	r31, Y+4	; 0x04
     e5c:	80 81       	ld	r24, Z
     e5e:	91 81       	ldd	r25, Z+1	; 0x01
     e60:	9e 83       	std	Y+6, r25	; 0x06
     e62:	8d 83       	std	Y+5, r24	; 0x05
				xTimeoutOccurred = pdTRUE;
     e64:	81 e0       	ldi	r24, 0x01	; 1
     e66:	89 83       	std	Y+1, r24	; 0x01
			}
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     e68:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
     e6c:	8a 83       	std	Y+2, r24	; 0x02

	if( xTicksToWait != ( TickType_t ) 0 )
     e6e:	8f 85       	ldd	r24, Y+15	; 0x0f
     e70:	98 89       	ldd	r25, Y+16	; 0x10
     e72:	00 97       	sbiw	r24, 0x00	; 0
     e74:	09 f4       	brne	.+2      	; 0xe78 <xEventGroupSync+0xe8>
     e76:	3a c0       	rjmp	.+116    	; 0xeec <xEventGroupSync+0x15c>
	{
		if( xAlreadyYielded == pdFALSE )
     e78:	8a 81       	ldd	r24, Y+2	; 0x02
     e7a:	88 23       	and	r24, r24
     e7c:	11 f4       	brne	.+4      	; 0xe82 <xEventGroupSync+0xf2>
		{
			portYIELD_WITHIN_API();
     e7e:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
     e82:	0e 94 10 20 	call	0x4020	; 0x4020 <uxTaskResetEventItemValue>
     e86:	9e 83       	std	Y+6, r25	; 0x06
     e88:	8d 83       	std	Y+5, r24	; 0x05

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
     e8a:	8d 81       	ldd	r24, Y+5	; 0x05
     e8c:	9e 81       	ldd	r25, Y+6	; 0x06
     e8e:	80 70       	andi	r24, 0x00	; 0
     e90:	92 70       	andi	r25, 0x02	; 2
     e92:	00 97       	sbiw	r24, 0x00	; 0
     e94:	31 f5       	brne	.+76     	; 0xee2 <xEventGroupSync+0x152>
		{
			/* The task timed out, just return the current event bit value. */
			taskENTER_CRITICAL();
     e96:	0f b6       	in	r0, 0x3f	; 63
     e98:	f8 94       	cli
     e9a:	0f 92       	push	r0
			{
				uxReturn = pxEventBits->uxEventBits;
     e9c:	eb 81       	ldd	r30, Y+3	; 0x03
     e9e:	fc 81       	ldd	r31, Y+4	; 0x04
     ea0:	80 81       	ld	r24, Z
     ea2:	91 81       	ldd	r25, Z+1	; 0x01
     ea4:	9e 83       	std	Y+6, r25	; 0x06
     ea6:	8d 83       	std	Y+5, r24	; 0x05

				/* Although the task got here because it timed out before the
				bits it was waiting for were set, it is possible that since it
				unblocked another task has set the bits.  If this is the case
				then it needs to clear the bits before exiting. */
				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
     ea8:	2d 81       	ldd	r18, Y+5	; 0x05
     eaa:	3e 81       	ldd	r19, Y+6	; 0x06
     eac:	8d 85       	ldd	r24, Y+13	; 0x0d
     eae:	9e 85       	ldd	r25, Y+14	; 0x0e
     eb0:	28 23       	and	r18, r24
     eb2:	39 23       	and	r19, r25
     eb4:	8d 85       	ldd	r24, Y+13	; 0x0d
     eb6:	9e 85       	ldd	r25, Y+14	; 0x0e
     eb8:	28 17       	cp	r18, r24
     eba:	39 07       	cpc	r19, r25
     ebc:	71 f4       	brne	.+28     	; 0xeda <xEventGroupSync+0x14a>
				{
					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     ebe:	eb 81       	ldd	r30, Y+3	; 0x03
     ec0:	fc 81       	ldd	r31, Y+4	; 0x04
     ec2:	20 81       	ld	r18, Z
     ec4:	31 81       	ldd	r19, Z+1	; 0x01
     ec6:	8d 85       	ldd	r24, Y+13	; 0x0d
     ec8:	9e 85       	ldd	r25, Y+14	; 0x0e
     eca:	80 95       	com	r24
     ecc:	90 95       	com	r25
     ece:	82 23       	and	r24, r18
     ed0:	93 23       	and	r25, r19
     ed2:	eb 81       	ldd	r30, Y+3	; 0x03
     ed4:	fc 81       	ldd	r31, Y+4	; 0x04
     ed6:	91 83       	std	Z+1, r25	; 0x01
     ed8:	80 83       	st	Z, r24
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
     eda:	0f 90       	pop	r0
     edc:	0f be       	out	0x3f, r0	; 63

			xTimeoutOccurred = pdTRUE;
     ede:	81 e0       	ldi	r24, 0x01	; 1
     ee0:	89 83       	std	Y+1, r24	; 0x01
			/* The task unblocked because the bits were set. */
		}

		/* Control bits might be set as the task had blocked should not be
		returned. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
     ee2:	8d 81       	ldd	r24, Y+5	; 0x05
     ee4:	9e 81       	ldd	r25, Y+6	; 0x06
     ee6:	90 70       	andi	r25, 0x00	; 0
     ee8:	9e 83       	std	Y+6, r25	; 0x06
     eea:	8d 83       	std	Y+5, r24	; 0x05
	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
     eec:	8d 81       	ldd	r24, Y+5	; 0x05
     eee:	9e 81       	ldd	r25, Y+6	; 0x06
}
     ef0:	60 96       	adiw	r28, 0x10	; 16
     ef2:	0f b6       	in	r0, 0x3f	; 63
     ef4:	f8 94       	cli
     ef6:	de bf       	out	0x3e, r29	; 62
     ef8:	0f be       	out	0x3f, r0	; 63
     efa:	cd bf       	out	0x3d, r28	; 61
     efc:	cf 91       	pop	r28
     efe:	df 91       	pop	r29
     f00:	08 95       	ret

00000f02 <xEventGroupWaitBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
{
     f02:	0f 93       	push	r16
     f04:	1f 93       	push	r17
     f06:	df 93       	push	r29
     f08:	cf 93       	push	r28
     f0a:	cd b7       	in	r28, 0x3d	; 61
     f0c:	de b7       	in	r29, 0x3e	; 62
     f0e:	63 97       	sbiw	r28, 0x13	; 19
     f10:	0f b6       	in	r0, 0x3f	; 63
     f12:	f8 94       	cli
     f14:	de bf       	out	0x3e, r29	; 62
     f16:	0f be       	out	0x3f, r0	; 63
     f18:	cd bf       	out	0x3d, r28	; 61
     f1a:	9d 87       	std	Y+13, r25	; 0x0d
     f1c:	8c 87       	std	Y+12, r24	; 0x0c
     f1e:	7f 87       	std	Y+15, r23	; 0x0f
     f20:	6e 87       	std	Y+14, r22	; 0x0e
     f22:	48 8b       	std	Y+16, r20	; 0x10
     f24:	29 8b       	std	Y+17, r18	; 0x11
     f26:	1b 8b       	std	Y+19, r17	; 0x13
     f28:	0a 8b       	std	Y+18, r16	; 0x12
EventGroup_t *pxEventBits = xEventGroup;
     f2a:	8c 85       	ldd	r24, Y+12	; 0x0c
     f2c:	9d 85       	ldd	r25, Y+13	; 0x0d
     f2e:	9b 87       	std	Y+11, r25	; 0x0b
     f30:	8a 87       	std	Y+10, r24	; 0x0a
EventBits_t uxReturn, uxControlBits = 0;
     f32:	1f 82       	std	Y+7, r1	; 0x07
     f34:	1e 82       	std	Y+6, r1	; 0x06
BaseType_t xWaitConditionMet, xAlreadyYielded;
BaseType_t xTimeoutOccurred = pdFALSE;
     f36:	1b 82       	std	Y+3, r1	; 0x03
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
	}
	#endif

	vTaskSuspendAll();
     f38:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskSuspendAll>
	{
		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
     f3c:	ea 85       	ldd	r30, Y+10	; 0x0a
     f3e:	fb 85       	ldd	r31, Y+11	; 0x0b
     f40:	80 81       	ld	r24, Z
     f42:	91 81       	ldd	r25, Z+1	; 0x01
     f44:	9a 83       	std	Y+2, r25	; 0x02
     f46:	89 83       	std	Y+1, r24	; 0x01

		/* Check to see if the wait condition is already met or not. */
		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
     f48:	89 81       	ldd	r24, Y+1	; 0x01
     f4a:	9a 81       	ldd	r25, Y+2	; 0x02
     f4c:	2e 85       	ldd	r18, Y+14	; 0x0e
     f4e:	3f 85       	ldd	r19, Y+15	; 0x0f
     f50:	b9 01       	movw	r22, r18
     f52:	49 89       	ldd	r20, Y+17	; 0x11
     f54:	0e 94 bc 09 	call	0x1378	; 0x1378 <prvTestWaitCondition>
     f58:	8d 83       	std	Y+5, r24	; 0x05

		if( xWaitConditionMet != pdFALSE )
     f5a:	8d 81       	ldd	r24, Y+5	; 0x05
     f5c:	88 23       	and	r24, r24
     f5e:	c1 f0       	breq	.+48     	; 0xf90 <xEventGroupWaitBits+0x8e>
		{
			/* The wait condition has already been met so there is no need to
			block. */
			uxReturn = uxCurrentEventBits;
     f60:	89 81       	ldd	r24, Y+1	; 0x01
     f62:	9a 81       	ldd	r25, Y+2	; 0x02
     f64:	99 87       	std	Y+9, r25	; 0x09
     f66:	88 87       	std	Y+8, r24	; 0x08
			xTicksToWait = ( TickType_t ) 0;
     f68:	1b 8a       	std	Y+19, r1	; 0x13
     f6a:	1a 8a       	std	Y+18, r1	; 0x12

			/* Clear the wait bits if requested to do so. */
			if( xClearOnExit != pdFALSE )
     f6c:	88 89       	ldd	r24, Y+16	; 0x10
     f6e:	88 23       	and	r24, r24
     f70:	e9 f1       	breq	.+122    	; 0xfec <xEventGroupWaitBits+0xea>
			{
				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
     f72:	ea 85       	ldd	r30, Y+10	; 0x0a
     f74:	fb 85       	ldd	r31, Y+11	; 0x0b
     f76:	20 81       	ld	r18, Z
     f78:	31 81       	ldd	r19, Z+1	; 0x01
     f7a:	8e 85       	ldd	r24, Y+14	; 0x0e
     f7c:	9f 85       	ldd	r25, Y+15	; 0x0f
     f7e:	80 95       	com	r24
     f80:	90 95       	com	r25
     f82:	82 23       	and	r24, r18
     f84:	93 23       	and	r25, r19
     f86:	ea 85       	ldd	r30, Y+10	; 0x0a
     f88:	fb 85       	ldd	r31, Y+11	; 0x0b
     f8a:	91 83       	std	Z+1, r25	; 0x01
     f8c:	80 83       	st	Z, r24
     f8e:	2e c0       	rjmp	.+92     	; 0xfec <xEventGroupWaitBits+0xea>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		else if( xTicksToWait == ( TickType_t ) 0 )
     f90:	8a 89       	ldd	r24, Y+18	; 0x12
     f92:	9b 89       	ldd	r25, Y+19	; 0x13
     f94:	00 97       	sbiw	r24, 0x00	; 0
     f96:	39 f4       	brne	.+14     	; 0xfa6 <xEventGroupWaitBits+0xa4>
		{
			/* The wait condition has not been met, but no block time was
			specified, so just return the current value. */
			uxReturn = uxCurrentEventBits;
     f98:	89 81       	ldd	r24, Y+1	; 0x01
     f9a:	9a 81       	ldd	r25, Y+2	; 0x02
     f9c:	99 87       	std	Y+9, r25	; 0x09
     f9e:	88 87       	std	Y+8, r24	; 0x08
			xTimeoutOccurred = pdTRUE;
     fa0:	81 e0       	ldi	r24, 0x01	; 1
     fa2:	8b 83       	std	Y+3, r24	; 0x03
     fa4:	23 c0       	rjmp	.+70     	; 0xfec <xEventGroupWaitBits+0xea>
		{
			/* The task is going to block to wait for its required bits to be
			set.  uxControlBits are used to remember the specified behaviour of
			this call to xEventGroupWaitBits() - for use when the event bits
			unblock the task. */
			if( xClearOnExit != pdFALSE )
     fa6:	88 89       	ldd	r24, Y+16	; 0x10
     fa8:	88 23       	and	r24, r24
     faa:	29 f0       	breq	.+10     	; 0xfb6 <xEventGroupWaitBits+0xb4>
			{
				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
     fac:	8e 81       	ldd	r24, Y+6	; 0x06
     fae:	9f 81       	ldd	r25, Y+7	; 0x07
     fb0:	91 60       	ori	r25, 0x01	; 1
     fb2:	9f 83       	std	Y+7, r25	; 0x07
     fb4:	8e 83       	std	Y+6, r24	; 0x06
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( xWaitForAllBits != pdFALSE )
     fb6:	89 89       	ldd	r24, Y+17	; 0x11
     fb8:	88 23       	and	r24, r24
     fba:	29 f0       	breq	.+10     	; 0xfc6 <xEventGroupWaitBits+0xc4>
			{
				uxControlBits |= eventWAIT_FOR_ALL_BITS;
     fbc:	8e 81       	ldd	r24, Y+6	; 0x06
     fbe:	9f 81       	ldd	r25, Y+7	; 0x07
     fc0:	94 60       	ori	r25, 0x04	; 4
     fc2:	9f 83       	std	Y+7, r25	; 0x07
     fc4:	8e 83       	std	Y+6, r24	; 0x06
			}

			/* Store the bits that the calling task is waiting for in the
			task's event list item so the kernel knows when a match is
			found.  Then enter the blocked state. */
			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
     fc6:	8a 85       	ldd	r24, Y+10	; 0x0a
     fc8:	9b 85       	ldd	r25, Y+11	; 0x0b
     fca:	bc 01       	movw	r22, r24
     fcc:	6e 5f       	subi	r22, 0xFE	; 254
     fce:	7f 4f       	sbci	r23, 0xFF	; 255
     fd0:	2e 85       	ldd	r18, Y+14	; 0x0e
     fd2:	3f 85       	ldd	r19, Y+15	; 0x0f
     fd4:	8e 81       	ldd	r24, Y+6	; 0x06
     fd6:	9f 81       	ldd	r25, Y+7	; 0x07
     fd8:	28 2b       	or	r18, r24
     fda:	39 2b       	or	r19, r25
     fdc:	4a 89       	ldd	r20, Y+18	; 0x12
     fde:	5b 89       	ldd	r21, Y+19	; 0x13
     fe0:	cb 01       	movw	r24, r22
     fe2:	b9 01       	movw	r22, r18
     fe4:	0e 94 af 1d 	call	0x3b5e	; 0x3b5e <vTaskPlaceOnUnorderedEventList>

			/* This is obsolete as it will get set after the task unblocks, but
			some compilers mistakenly generate a warning about the variable
			being returned without being set if it is not done. */
			uxReturn = 0;
     fe8:	19 86       	std	Y+9, r1	; 0x09
     fea:	18 86       	std	Y+8, r1	; 0x08

			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
		}
	}
	xAlreadyYielded = xTaskResumeAll();
     fec:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
     ff0:	8c 83       	std	Y+4, r24	; 0x04

	if( xTicksToWait != ( TickType_t ) 0 )
     ff2:	8a 89       	ldd	r24, Y+18	; 0x12
     ff4:	9b 89       	ldd	r25, Y+19	; 0x13
     ff6:	00 97       	sbiw	r24, 0x00	; 0
     ff8:	09 f4       	brne	.+2      	; 0xffc <xEventGroupWaitBits+0xfa>
     ffa:	3c c0       	rjmp	.+120    	; 0x1074 <xEventGroupWaitBits+0x172>
	{
		if( xAlreadyYielded == pdFALSE )
     ffc:	8c 81       	ldd	r24, Y+4	; 0x04
     ffe:	88 23       	and	r24, r24
    1000:	11 f4       	brne	.+4      	; 0x1006 <xEventGroupWaitBits+0x104>
		{
			portYIELD_WITHIN_API();
    1002:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>

		/* The task blocked to wait for its required bits to be set - at this
		point either the required bits were set or the block time expired.  If
		the required bits were set they will have been stored in the task's
		event list item, and they should now be retrieved then cleared. */
		uxReturn = uxTaskResetEventItemValue();
    1006:	0e 94 10 20 	call	0x4020	; 0x4020 <uxTaskResetEventItemValue>
    100a:	99 87       	std	Y+9, r25	; 0x09
    100c:	88 87       	std	Y+8, r24	; 0x08

		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    100e:	88 85       	ldd	r24, Y+8	; 0x08
    1010:	99 85       	ldd	r25, Y+9	; 0x09
    1012:	80 70       	andi	r24, 0x00	; 0
    1014:	92 70       	andi	r25, 0x02	; 2
    1016:	00 97       	sbiw	r24, 0x00	; 0
    1018:	41 f5       	brne	.+80     	; 0x106a <xEventGroupWaitBits+0x168>
		{
			taskENTER_CRITICAL();
    101a:	0f b6       	in	r0, 0x3f	; 63
    101c:	f8 94       	cli
    101e:	0f 92       	push	r0
			{
				/* The task timed out, just return the current event bit value. */
				uxReturn = pxEventBits->uxEventBits;
    1020:	ea 85       	ldd	r30, Y+10	; 0x0a
    1022:	fb 85       	ldd	r31, Y+11	; 0x0b
    1024:	80 81       	ld	r24, Z
    1026:	91 81       	ldd	r25, Z+1	; 0x01
    1028:	99 87       	std	Y+9, r25	; 0x09
    102a:	88 87       	std	Y+8, r24	; 0x08

				/* It is possible that the event bits were updated between this
				task leaving the Blocked state and running again. */
				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    102c:	88 85       	ldd	r24, Y+8	; 0x08
    102e:	99 85       	ldd	r25, Y+9	; 0x09
    1030:	2e 85       	ldd	r18, Y+14	; 0x0e
    1032:	3f 85       	ldd	r19, Y+15	; 0x0f
    1034:	b9 01       	movw	r22, r18
    1036:	49 89       	ldd	r20, Y+17	; 0x11
    1038:	0e 94 bc 09 	call	0x1378	; 0x1378 <prvTestWaitCondition>
    103c:	88 23       	and	r24, r24
    103e:	89 f0       	breq	.+34     	; 0x1062 <xEventGroupWaitBits+0x160>
				{
					if( xClearOnExit != pdFALSE )
    1040:	88 89       	ldd	r24, Y+16	; 0x10
    1042:	88 23       	and	r24, r24
    1044:	71 f0       	breq	.+28     	; 0x1062 <xEventGroupWaitBits+0x160>
					{
						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    1046:	ea 85       	ldd	r30, Y+10	; 0x0a
    1048:	fb 85       	ldd	r31, Y+11	; 0x0b
    104a:	20 81       	ld	r18, Z
    104c:	31 81       	ldd	r19, Z+1	; 0x01
    104e:	8e 85       	ldd	r24, Y+14	; 0x0e
    1050:	9f 85       	ldd	r25, Y+15	; 0x0f
    1052:	80 95       	com	r24
    1054:	90 95       	com	r25
    1056:	82 23       	and	r24, r18
    1058:	93 23       	and	r25, r19
    105a:	ea 85       	ldd	r30, Y+10	; 0x0a
    105c:	fb 85       	ldd	r31, Y+11	; 0x0b
    105e:	91 83       	std	Z+1, r25	; 0x01
    1060:	80 83       	st	Z, r24
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				xTimeoutOccurred = pdTRUE;
    1062:	81 e0       	ldi	r24, 0x01	; 1
    1064:	8b 83       	std	Y+3, r24	; 0x03
			}
			taskEXIT_CRITICAL();
    1066:	0f 90       	pop	r0
    1068:	0f be       	out	0x3f, r0	; 63
		{
			/* The task unblocked because the bits were set. */
		}

		/* The task blocked so control bits may have been set. */
		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    106a:	88 85       	ldd	r24, Y+8	; 0x08
    106c:	99 85       	ldd	r25, Y+9	; 0x09
    106e:	90 70       	andi	r25, 0x00	; 0
    1070:	99 87       	std	Y+9, r25	; 0x09
    1072:	88 87       	std	Y+8, r24	; 0x08
	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );

	/* Prevent compiler warnings when trace macros are not used. */
	( void ) xTimeoutOccurred;

	return uxReturn;
    1074:	88 85       	ldd	r24, Y+8	; 0x08
    1076:	99 85       	ldd	r25, Y+9	; 0x09
}
    1078:	63 96       	adiw	r28, 0x13	; 19
    107a:	0f b6       	in	r0, 0x3f	; 63
    107c:	f8 94       	cli
    107e:	de bf       	out	0x3e, r29	; 62
    1080:	0f be       	out	0x3f, r0	; 63
    1082:	cd bf       	out	0x3d, r28	; 61
    1084:	cf 91       	pop	r28
    1086:	df 91       	pop	r29
    1088:	1f 91       	pop	r17
    108a:	0f 91       	pop	r16
    108c:	08 95       	ret

0000108e <xEventGroupClearBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
{
    108e:	df 93       	push	r29
    1090:	cf 93       	push	r28
    1092:	cd b7       	in	r28, 0x3d	; 61
    1094:	de b7       	in	r29, 0x3e	; 62
    1096:	28 97       	sbiw	r28, 0x08	; 8
    1098:	0f b6       	in	r0, 0x3f	; 63
    109a:	f8 94       	cli
    109c:	de bf       	out	0x3e, r29	; 62
    109e:	0f be       	out	0x3f, r0	; 63
    10a0:	cd bf       	out	0x3d, r28	; 61
    10a2:	9e 83       	std	Y+6, r25	; 0x06
    10a4:	8d 83       	std	Y+5, r24	; 0x05
    10a6:	78 87       	std	Y+8, r23	; 0x08
    10a8:	6f 83       	std	Y+7, r22	; 0x07
EventGroup_t *pxEventBits = xEventGroup;
    10aa:	8d 81       	ldd	r24, Y+5	; 0x05
    10ac:	9e 81       	ldd	r25, Y+6	; 0x06
    10ae:	9c 83       	std	Y+4, r25	; 0x04
    10b0:	8b 83       	std	Y+3, r24	; 0x03
	/* Check the user is not attempting to clear the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	taskENTER_CRITICAL();
    10b2:	0f b6       	in	r0, 0x3f	; 63
    10b4:	f8 94       	cli
    10b6:	0f 92       	push	r0
	{
		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

		/* The value returned is the event group value prior to the bits being
		cleared. */
		uxReturn = pxEventBits->uxEventBits;
    10b8:	eb 81       	ldd	r30, Y+3	; 0x03
    10ba:	fc 81       	ldd	r31, Y+4	; 0x04
    10bc:	80 81       	ld	r24, Z
    10be:	91 81       	ldd	r25, Z+1	; 0x01
    10c0:	9a 83       	std	Y+2, r25	; 0x02
    10c2:	89 83       	std	Y+1, r24	; 0x01

		/* Clear the bits. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    10c4:	eb 81       	ldd	r30, Y+3	; 0x03
    10c6:	fc 81       	ldd	r31, Y+4	; 0x04
    10c8:	20 81       	ld	r18, Z
    10ca:	31 81       	ldd	r19, Z+1	; 0x01
    10cc:	8f 81       	ldd	r24, Y+7	; 0x07
    10ce:	98 85       	ldd	r25, Y+8	; 0x08
    10d0:	80 95       	com	r24
    10d2:	90 95       	com	r25
    10d4:	82 23       	and	r24, r18
    10d6:	93 23       	and	r25, r19
    10d8:	eb 81       	ldd	r30, Y+3	; 0x03
    10da:	fc 81       	ldd	r31, Y+4	; 0x04
    10dc:	91 83       	std	Z+1, r25	; 0x01
    10de:	80 83       	st	Z, r24
	}
	taskEXIT_CRITICAL();
    10e0:	0f 90       	pop	r0
    10e2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    10e4:	89 81       	ldd	r24, Y+1	; 0x01
    10e6:	9a 81       	ldd	r25, Y+2	; 0x02
}
    10e8:	28 96       	adiw	r28, 0x08	; 8
    10ea:	0f b6       	in	r0, 0x3f	; 63
    10ec:	f8 94       	cli
    10ee:	de bf       	out	0x3e, r29	; 62
    10f0:	0f be       	out	0x3f, r0	; 63
    10f2:	cd bf       	out	0x3d, r28	; 61
    10f4:	cf 91       	pop	r28
    10f6:	df 91       	pop	r29
    10f8:	08 95       	ret

000010fa <xEventGroupGetBitsFromISR>:

#endif
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    10fa:	df 93       	push	r29
    10fc:	cf 93       	push	r28
    10fe:	cd b7       	in	r28, 0x3d	; 61
    1100:	de b7       	in	r29, 0x3e	; 62
    1102:	27 97       	sbiw	r28, 0x07	; 7
    1104:	0f b6       	in	r0, 0x3f	; 63
    1106:	f8 94       	cli
    1108:	de bf       	out	0x3e, r29	; 62
    110a:	0f be       	out	0x3f, r0	; 63
    110c:	cd bf       	out	0x3d, r28	; 61
    110e:	9f 83       	std	Y+7, r25	; 0x07
    1110:	8e 83       	std	Y+6, r24	; 0x06
UBaseType_t uxSavedInterruptStatus;
EventGroup_t const * const pxEventBits = xEventGroup;
    1112:	8e 81       	ldd	r24, Y+6	; 0x06
    1114:	9f 81       	ldd	r25, Y+7	; 0x07
    1116:	9c 83       	std	Y+4, r25	; 0x04
    1118:	8b 83       	std	Y+3, r24	; 0x03
EventBits_t uxReturn;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    111a:	1d 82       	std	Y+5, r1	; 0x05
	{
		uxReturn = pxEventBits->uxEventBits;
    111c:	eb 81       	ldd	r30, Y+3	; 0x03
    111e:	fc 81       	ldd	r31, Y+4	; 0x04
    1120:	80 81       	ld	r24, Z
    1122:	91 81       	ldd	r25, Z+1	; 0x01
    1124:	9a 83       	std	Y+2, r25	; 0x02
    1126:	89 83       	std	Y+1, r24	; 0x01
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return uxReturn;
    1128:	89 81       	ldd	r24, Y+1	; 0x01
    112a:	9a 81       	ldd	r25, Y+2	; 0x02
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    112c:	27 96       	adiw	r28, 0x07	; 7
    112e:	0f b6       	in	r0, 0x3f	; 63
    1130:	f8 94       	cli
    1132:	de bf       	out	0x3e, r29	; 62
    1134:	0f be       	out	0x3f, r0	; 63
    1136:	cd bf       	out	0x3d, r28	; 61
    1138:	cf 91       	pop	r28
    113a:	df 91       	pop	r29
    113c:	08 95       	ret

0000113e <xEventGroupSetBits>:
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
    113e:	df 93       	push	r29
    1140:	cf 93       	push	r28
    1142:	cd b7       	in	r28, 0x3d	; 61
    1144:	de b7       	in	r29, 0x3e	; 62
    1146:	65 97       	sbiw	r28, 0x15	; 21
    1148:	0f b6       	in	r0, 0x3f	; 63
    114a:	f8 94       	cli
    114c:	de bf       	out	0x3e, r29	; 62
    114e:	0f be       	out	0x3f, r0	; 63
    1150:	cd bf       	out	0x3d, r28	; 61
    1152:	9b 8b       	std	Y+19, r25	; 0x13
    1154:	8a 8b       	std	Y+18, r24	; 0x12
    1156:	7d 8b       	std	Y+21, r23	; 0x15
    1158:	6c 8b       	std	Y+20, r22	; 0x14
ListItem_t *pxListItem, *pxNext;
ListItem_t const *pxListEnd;
List_t const * pxList;
EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
    115a:	19 86       	std	Y+9, r1	; 0x09
    115c:	18 86       	std	Y+8, r1	; 0x08
EventGroup_t *pxEventBits = xEventGroup;
    115e:	8a 89       	ldd	r24, Y+18	; 0x12
    1160:	9b 89       	ldd	r25, Y+19	; 0x13
    1162:	9b 83       	std	Y+3, r25	; 0x03
    1164:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xMatchFound = pdFALSE;
    1166:	19 82       	std	Y+1, r1	; 0x01
	/* Check the user is not attempting to set the bits used by the kernel
	itself. */
	configASSERT( xEventGroup );
	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

	pxList = &( pxEventBits->xTasksWaitingForBits );
    1168:	8a 81       	ldd	r24, Y+2	; 0x02
    116a:	9b 81       	ldd	r25, Y+3	; 0x03
    116c:	02 96       	adiw	r24, 0x02	; 2
    116e:	9b 87       	std	Y+11, r25	; 0x0b
    1170:	8a 87       	std	Y+10, r24	; 0x0a
	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1172:	8a 85       	ldd	r24, Y+10	; 0x0a
    1174:	9b 85       	ldd	r25, Y+11	; 0x0b
    1176:	03 96       	adiw	r24, 0x03	; 3
    1178:	9d 87       	std	Y+13, r25	; 0x0d
    117a:	8c 87       	std	Y+12, r24	; 0x0c
	vTaskSuspendAll();
    117c:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskSuspendAll>
	{
		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

		pxListItem = listGET_HEAD_ENTRY( pxList );
    1180:	ea 85       	ldd	r30, Y+10	; 0x0a
    1182:	fb 85       	ldd	r31, Y+11	; 0x0b
    1184:	85 81       	ldd	r24, Z+5	; 0x05
    1186:	96 81       	ldd	r25, Z+6	; 0x06
    1188:	99 8b       	std	Y+17, r25	; 0x11
    118a:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;
    118c:	ea 81       	ldd	r30, Y+2	; 0x02
    118e:	fb 81       	ldd	r31, Y+3	; 0x03
    1190:	20 81       	ld	r18, Z
    1192:	31 81       	ldd	r19, Z+1	; 0x01
    1194:	8c 89       	ldd	r24, Y+20	; 0x14
    1196:	9d 89       	ldd	r25, Y+21	; 0x15
    1198:	82 2b       	or	r24, r18
    119a:	93 2b       	or	r25, r19
    119c:	ea 81       	ldd	r30, Y+2	; 0x02
    119e:	fb 81       	ldd	r31, Y+3	; 0x03
    11a0:	91 83       	std	Z+1, r25	; 0x01
    11a2:	80 83       	st	Z, r24
    11a4:	59 c0       	rjmp	.+178    	; 0x1258 <xEventGroupSetBits+0x11a>

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
		{
			pxNext = listGET_NEXT( pxListItem );
    11a6:	e8 89       	ldd	r30, Y+16	; 0x10
    11a8:	f9 89       	ldd	r31, Y+17	; 0x11
    11aa:	82 81       	ldd	r24, Z+2	; 0x02
    11ac:	93 81       	ldd	r25, Z+3	; 0x03
    11ae:	9f 87       	std	Y+15, r25	; 0x0f
    11b0:	8e 87       	std	Y+14, r24	; 0x0e
			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    11b2:	e8 89       	ldd	r30, Y+16	; 0x10
    11b4:	f9 89       	ldd	r31, Y+17	; 0x11
    11b6:	80 81       	ld	r24, Z
    11b8:	91 81       	ldd	r25, Z+1	; 0x01
    11ba:	9f 83       	std	Y+7, r25	; 0x07
    11bc:	8e 83       	std	Y+6, r24	; 0x06
			xMatchFound = pdFALSE;
    11be:	19 82       	std	Y+1, r1	; 0x01

			/* Split the bits waited for from the control bits. */
			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    11c0:	8e 81       	ldd	r24, Y+6	; 0x06
    11c2:	9f 81       	ldd	r25, Y+7	; 0x07
    11c4:	80 70       	andi	r24, 0x00	; 0
    11c6:	9d 83       	std	Y+5, r25	; 0x05
    11c8:	8c 83       	std	Y+4, r24	; 0x04
			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    11ca:	8e 81       	ldd	r24, Y+6	; 0x06
    11cc:	9f 81       	ldd	r25, Y+7	; 0x07
    11ce:	90 70       	andi	r25, 0x00	; 0
    11d0:	9f 83       	std	Y+7, r25	; 0x07
    11d2:	8e 83       	std	Y+6, r24	; 0x06

			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    11d4:	8c 81       	ldd	r24, Y+4	; 0x04
    11d6:	9d 81       	ldd	r25, Y+5	; 0x05
    11d8:	80 70       	andi	r24, 0x00	; 0
    11da:	94 70       	andi	r25, 0x04	; 4
    11dc:	00 97       	sbiw	r24, 0x00	; 0
    11de:	69 f4       	brne	.+26     	; 0x11fa <xEventGroupSetBits+0xbc>
			{
				/* Just looking for single bit being set. */
				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    11e0:	ea 81       	ldd	r30, Y+2	; 0x02
    11e2:	fb 81       	ldd	r31, Y+3	; 0x03
    11e4:	20 81       	ld	r18, Z
    11e6:	31 81       	ldd	r19, Z+1	; 0x01
    11e8:	8e 81       	ldd	r24, Y+6	; 0x06
    11ea:	9f 81       	ldd	r25, Y+7	; 0x07
    11ec:	82 23       	and	r24, r18
    11ee:	93 23       	and	r25, r19
    11f0:	00 97       	sbiw	r24, 0x00	; 0
    11f2:	91 f0       	breq	.+36     	; 0x1218 <xEventGroupSetBits+0xda>
				{
					xMatchFound = pdTRUE;
    11f4:	81 e0       	ldi	r24, 0x01	; 1
    11f6:	89 83       	std	Y+1, r24	; 0x01
    11f8:	0f c0       	rjmp	.+30     	; 0x1218 <xEventGroupSetBits+0xda>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    11fa:	ea 81       	ldd	r30, Y+2	; 0x02
    11fc:	fb 81       	ldd	r31, Y+3	; 0x03
    11fe:	20 81       	ld	r18, Z
    1200:	31 81       	ldd	r19, Z+1	; 0x01
    1202:	8e 81       	ldd	r24, Y+6	; 0x06
    1204:	9f 81       	ldd	r25, Y+7	; 0x07
    1206:	28 23       	and	r18, r24
    1208:	39 23       	and	r19, r25
    120a:	8e 81       	ldd	r24, Y+6	; 0x06
    120c:	9f 81       	ldd	r25, Y+7	; 0x07
    120e:	28 17       	cp	r18, r24
    1210:	39 07       	cpc	r19, r25
    1212:	11 f4       	brne	.+4      	; 0x1218 <xEventGroupSetBits+0xda>
			{
				/* All bits are set. */
				xMatchFound = pdTRUE;
    1214:	81 e0       	ldi	r24, 0x01	; 1
    1216:	89 83       	std	Y+1, r24	; 0x01
			else
			{
				/* Need all bits to be set, but not all the bits were set. */
			}

			if( xMatchFound != pdFALSE )
    1218:	89 81       	ldd	r24, Y+1	; 0x01
    121a:	88 23       	and	r24, r24
    121c:	c9 f0       	breq	.+50     	; 0x1250 <xEventGroupSetBits+0x112>
			{
				/* The bits match.  Should the bits be cleared on exit? */
				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    121e:	8c 81       	ldd	r24, Y+4	; 0x04
    1220:	9d 81       	ldd	r25, Y+5	; 0x05
    1222:	80 70       	andi	r24, 0x00	; 0
    1224:	91 70       	andi	r25, 0x01	; 1
    1226:	00 97       	sbiw	r24, 0x00	; 0
    1228:	41 f0       	breq	.+16     	; 0x123a <xEventGroupSetBits+0xfc>
				{
					uxBitsToClear |= uxBitsWaitedFor;
    122a:	88 85       	ldd	r24, Y+8	; 0x08
    122c:	99 85       	ldd	r25, Y+9	; 0x09
    122e:	2e 81       	ldd	r18, Y+6	; 0x06
    1230:	3f 81       	ldd	r19, Y+7	; 0x07
    1232:	82 2b       	or	r24, r18
    1234:	93 2b       	or	r25, r19
    1236:	99 87       	std	Y+9, r25	; 0x09
    1238:	88 87       	std	Y+8, r24	; 0x08
				/* Store the actual event flag value in the task's event list
				item before removing the task from the event list.  The
				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
				that is was unblocked due to its required bits matching, rather
				than because it timed out. */
				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    123a:	ea 81       	ldd	r30, Y+2	; 0x02
    123c:	fb 81       	ldd	r31, Y+3	; 0x03
    123e:	80 81       	ld	r24, Z
    1240:	91 81       	ldd	r25, Z+1	; 0x01
    1242:	9c 01       	movw	r18, r24
    1244:	32 60       	ori	r19, 0x02	; 2
    1246:	88 89       	ldd	r24, Y+16	; 0x10
    1248:	99 89       	ldd	r25, Y+17	; 0x11
    124a:	b9 01       	movw	r22, r18
    124c:	0e 94 4a 1e 	call	0x3c94	; 0x3c94 <vTaskRemoveFromUnorderedEventList>
			}

			/* Move onto the next list item.  Note pxListItem->pxNext is not
			used here as the list item may have been removed from the event list
			and inserted into the ready/pending reading list. */
			pxListItem = pxNext;
    1250:	8e 85       	ldd	r24, Y+14	; 0x0e
    1252:	9f 85       	ldd	r25, Y+15	; 0x0f
    1254:	99 8b       	std	Y+17, r25	; 0x11
    1256:	88 8b       	std	Y+16, r24	; 0x10

		/* Set the bits. */
		pxEventBits->uxEventBits |= uxBitsToSet;

		/* See if the new bit value should unblock any tasks. */
		while( pxListItem != pxListEnd )
    1258:	28 89       	ldd	r18, Y+16	; 0x10
    125a:	39 89       	ldd	r19, Y+17	; 0x11
    125c:	8c 85       	ldd	r24, Y+12	; 0x0c
    125e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1260:	28 17       	cp	r18, r24
    1262:	39 07       	cpc	r19, r25
    1264:	09 f0       	breq	.+2      	; 0x1268 <xEventGroupSetBits+0x12a>
    1266:	9f cf       	rjmp	.-194    	; 0x11a6 <xEventGroupSetBits+0x68>
			pxListItem = pxNext;
		}

		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
		bit was set in the control word. */
		pxEventBits->uxEventBits &= ~uxBitsToClear;
    1268:	ea 81       	ldd	r30, Y+2	; 0x02
    126a:	fb 81       	ldd	r31, Y+3	; 0x03
    126c:	20 81       	ld	r18, Z
    126e:	31 81       	ldd	r19, Z+1	; 0x01
    1270:	88 85       	ldd	r24, Y+8	; 0x08
    1272:	99 85       	ldd	r25, Y+9	; 0x09
    1274:	80 95       	com	r24
    1276:	90 95       	com	r25
    1278:	82 23       	and	r24, r18
    127a:	93 23       	and	r25, r19
    127c:	ea 81       	ldd	r30, Y+2	; 0x02
    127e:	fb 81       	ldd	r31, Y+3	; 0x03
    1280:	91 83       	std	Z+1, r25	; 0x01
    1282:	80 83       	st	Z, r24
	}
	( void ) xTaskResumeAll();
    1284:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>

	return pxEventBits->uxEventBits;
    1288:	ea 81       	ldd	r30, Y+2	; 0x02
    128a:	fb 81       	ldd	r31, Y+3	; 0x03
    128c:	80 81       	ld	r24, Z
    128e:	91 81       	ldd	r25, Z+1	; 0x01
}
    1290:	65 96       	adiw	r28, 0x15	; 21
    1292:	0f b6       	in	r0, 0x3f	; 63
    1294:	f8 94       	cli
    1296:	de bf       	out	0x3e, r29	; 62
    1298:	0f be       	out	0x3f, r0	; 63
    129a:	cd bf       	out	0x3d, r28	; 61
    129c:	cf 91       	pop	r28
    129e:	df 91       	pop	r29
    12a0:	08 95       	ret

000012a2 <vEventGroupDelete>:
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    12a2:	df 93       	push	r29
    12a4:	cf 93       	push	r28
    12a6:	00 d0       	rcall	.+0      	; 0x12a8 <vEventGroupDelete+0x6>
    12a8:	00 d0       	rcall	.+0      	; 0x12aa <vEventGroupDelete+0x8>
    12aa:	00 d0       	rcall	.+0      	; 0x12ac <vEventGroupDelete+0xa>
    12ac:	cd b7       	in	r28, 0x3d	; 61
    12ae:	de b7       	in	r29, 0x3e	; 62
    12b0:	9e 83       	std	Y+6, r25	; 0x06
    12b2:	8d 83       	std	Y+5, r24	; 0x05
EventGroup_t *pxEventBits = xEventGroup;
    12b4:	8d 81       	ldd	r24, Y+5	; 0x05
    12b6:	9e 81       	ldd	r25, Y+6	; 0x06
    12b8:	9c 83       	std	Y+4, r25	; 0x04
    12ba:	8b 83       	std	Y+3, r24	; 0x03
const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
    12bc:	8b 81       	ldd	r24, Y+3	; 0x03
    12be:	9c 81       	ldd	r25, Y+4	; 0x04
    12c0:	02 96       	adiw	r24, 0x02	; 2
    12c2:	9a 83       	std	Y+2, r25	; 0x02
    12c4:	89 83       	std	Y+1, r24	; 0x01

	vTaskSuspendAll();
    12c6:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskSuspendAll>
    12ca:	08 c0       	rjmp	.+16     	; 0x12dc <vEventGroupDelete+0x3a>
		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
		{
			/* Unblock the task, returning 0 as the event list is being deleted
			and cannot therefore have any bits set. */
			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    12cc:	e9 81       	ldd	r30, Y+1	; 0x01
    12ce:	fa 81       	ldd	r31, Y+2	; 0x02
    12d0:	85 81       	ldd	r24, Z+5	; 0x05
    12d2:	96 81       	ldd	r25, Z+6	; 0x06
    12d4:	60 e0       	ldi	r22, 0x00	; 0
    12d6:	72 e0       	ldi	r23, 0x02	; 2
    12d8:	0e 94 4a 1e 	call	0x3c94	; 0x3c94 <vTaskRemoveFromUnorderedEventList>

	vTaskSuspendAll();
	{
		traceEVENT_GROUP_DELETE( xEventGroup );

		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    12dc:	e9 81       	ldd	r30, Y+1	; 0x01
    12de:	fa 81       	ldd	r31, Y+2	; 0x02
    12e0:	80 81       	ld	r24, Z
    12e2:	88 23       	and	r24, r24
    12e4:	99 f7       	brne	.-26     	; 0x12cc <vEventGroupDelete+0x2a>

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
		{
			/* The event group can only have been allocated dynamically - free
			it again. */
			vPortFree( pxEventBits );
    12e6:	8b 81       	ldd	r24, Y+3	; 0x03
    12e8:	9c 81       	ldd	r25, Y+4	; 0x04
    12ea:	0e 94 44 0a 	call	0x1488	; 0x1488 <vPortFree>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
	( void ) xTaskResumeAll();
    12ee:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
}
    12f2:	26 96       	adiw	r28, 0x06	; 6
    12f4:	0f b6       	in	r0, 0x3f	; 63
    12f6:	f8 94       	cli
    12f8:	de bf       	out	0x3e, r29	; 62
    12fa:	0f be       	out	0x3f, r0	; 63
    12fc:	cd bf       	out	0x3d, r28	; 61
    12fe:	cf 91       	pop	r28
    1300:	df 91       	pop	r29
    1302:	08 95       	ret

00001304 <vEventGroupSetBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'set bits' command that was pended from
an interrupt. */
void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
{
    1304:	df 93       	push	r29
    1306:	cf 93       	push	r28
    1308:	00 d0       	rcall	.+0      	; 0x130a <vEventGroupSetBitsCallback+0x6>
    130a:	00 d0       	rcall	.+0      	; 0x130c <vEventGroupSetBitsCallback+0x8>
    130c:	00 d0       	rcall	.+0      	; 0x130e <vEventGroupSetBitsCallback+0xa>
    130e:	cd b7       	in	r28, 0x3d	; 61
    1310:	de b7       	in	r29, 0x3e	; 62
    1312:	9a 83       	std	Y+2, r25	; 0x02
    1314:	89 83       	std	Y+1, r24	; 0x01
    1316:	4b 83       	std	Y+3, r20	; 0x03
    1318:	5c 83       	std	Y+4, r21	; 0x04
    131a:	6d 83       	std	Y+5, r22	; 0x05
    131c:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    131e:	89 81       	ldd	r24, Y+1	; 0x01
    1320:	9a 81       	ldd	r25, Y+2	; 0x02
    1322:	2b 81       	ldd	r18, Y+3	; 0x03
    1324:	3c 81       	ldd	r19, Y+4	; 0x04
    1326:	b9 01       	movw	r22, r18
    1328:	0e 94 9f 08 	call	0x113e	; 0x113e <xEventGroupSetBits>
}
    132c:	26 96       	adiw	r28, 0x06	; 6
    132e:	0f b6       	in	r0, 0x3f	; 63
    1330:	f8 94       	cli
    1332:	de bf       	out	0x3e, r29	; 62
    1334:	0f be       	out	0x3f, r0	; 63
    1336:	cd bf       	out	0x3d, r28	; 61
    1338:	cf 91       	pop	r28
    133a:	df 91       	pop	r29
    133c:	08 95       	ret

0000133e <vEventGroupClearBitsCallback>:
/*-----------------------------------------------------------*/

/* For internal use only - execute a 'clear bits' command that was pended from
an interrupt. */
void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
{
    133e:	df 93       	push	r29
    1340:	cf 93       	push	r28
    1342:	00 d0       	rcall	.+0      	; 0x1344 <vEventGroupClearBitsCallback+0x6>
    1344:	00 d0       	rcall	.+0      	; 0x1346 <vEventGroupClearBitsCallback+0x8>
    1346:	00 d0       	rcall	.+0      	; 0x1348 <vEventGroupClearBitsCallback+0xa>
    1348:	cd b7       	in	r28, 0x3d	; 61
    134a:	de b7       	in	r29, 0x3e	; 62
    134c:	9a 83       	std	Y+2, r25	; 0x02
    134e:	89 83       	std	Y+1, r24	; 0x01
    1350:	4b 83       	std	Y+3, r20	; 0x03
    1352:	5c 83       	std	Y+4, r21	; 0x04
    1354:	6d 83       	std	Y+5, r22	; 0x05
    1356:	7e 83       	std	Y+6, r23	; 0x06
	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    1358:	89 81       	ldd	r24, Y+1	; 0x01
    135a:	9a 81       	ldd	r25, Y+2	; 0x02
    135c:	2b 81       	ldd	r18, Y+3	; 0x03
    135e:	3c 81       	ldd	r19, Y+4	; 0x04
    1360:	b9 01       	movw	r22, r18
    1362:	0e 94 47 08 	call	0x108e	; 0x108e <xEventGroupClearBits>
}
    1366:	26 96       	adiw	r28, 0x06	; 6
    1368:	0f b6       	in	r0, 0x3f	; 63
    136a:	f8 94       	cli
    136c:	de bf       	out	0x3e, r29	; 62
    136e:	0f be       	out	0x3f, r0	; 63
    1370:	cd bf       	out	0x3d, r28	; 61
    1372:	cf 91       	pop	r28
    1374:	df 91       	pop	r29
    1376:	08 95       	ret

00001378 <prvTestWaitCondition>:
/*-----------------------------------------------------------*/

static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
{
    1378:	df 93       	push	r29
    137a:	cf 93       	push	r28
    137c:	00 d0       	rcall	.+0      	; 0x137e <prvTestWaitCondition+0x6>
    137e:	00 d0       	rcall	.+0      	; 0x1380 <prvTestWaitCondition+0x8>
    1380:	00 d0       	rcall	.+0      	; 0x1382 <prvTestWaitCondition+0xa>
    1382:	cd b7       	in	r28, 0x3d	; 61
    1384:	de b7       	in	r29, 0x3e	; 62
    1386:	9b 83       	std	Y+3, r25	; 0x03
    1388:	8a 83       	std	Y+2, r24	; 0x02
    138a:	7d 83       	std	Y+5, r23	; 0x05
    138c:	6c 83       	std	Y+4, r22	; 0x04
    138e:	4e 83       	std	Y+6, r20	; 0x06
BaseType_t xWaitConditionMet = pdFALSE;
    1390:	19 82       	std	Y+1, r1	; 0x01

	if( xWaitForAllBits == pdFALSE )
    1392:	8e 81       	ldd	r24, Y+6	; 0x06
    1394:	88 23       	and	r24, r24
    1396:	59 f4       	brne	.+22     	; 0x13ae <prvTestWaitCondition+0x36>
	{
		/* Task only has to wait for one bit within uxBitsToWaitFor to be
		set.  Is one already set? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
    1398:	8a 81       	ldd	r24, Y+2	; 0x02
    139a:	9b 81       	ldd	r25, Y+3	; 0x03
    139c:	2c 81       	ldd	r18, Y+4	; 0x04
    139e:	3d 81       	ldd	r19, Y+5	; 0x05
    13a0:	82 23       	and	r24, r18
    13a2:	93 23       	and	r25, r19
    13a4:	00 97       	sbiw	r24, 0x00	; 0
    13a6:	81 f0       	breq	.+32     	; 0x13c8 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    13a8:	81 e0       	ldi	r24, 0x01	; 1
    13aa:	89 83       	std	Y+1, r24	; 0x01
    13ac:	0d c0       	rjmp	.+26     	; 0x13c8 <prvTestWaitCondition+0x50>
	}
	else
	{
		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
		Are they set already? */
		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
    13ae:	2a 81       	ldd	r18, Y+2	; 0x02
    13b0:	3b 81       	ldd	r19, Y+3	; 0x03
    13b2:	8c 81       	ldd	r24, Y+4	; 0x04
    13b4:	9d 81       	ldd	r25, Y+5	; 0x05
    13b6:	28 23       	and	r18, r24
    13b8:	39 23       	and	r19, r25
    13ba:	8c 81       	ldd	r24, Y+4	; 0x04
    13bc:	9d 81       	ldd	r25, Y+5	; 0x05
    13be:	28 17       	cp	r18, r24
    13c0:	39 07       	cpc	r19, r25
    13c2:	11 f4       	brne	.+4      	; 0x13c8 <prvTestWaitCondition+0x50>
		{
			xWaitConditionMet = pdTRUE;
    13c4:	81 e0       	ldi	r24, 0x01	; 1
    13c6:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xWaitConditionMet;
    13c8:	89 81       	ldd	r24, Y+1	; 0x01
}
    13ca:	26 96       	adiw	r28, 0x06	; 6
    13cc:	0f b6       	in	r0, 0x3f	; 63
    13ce:	f8 94       	cli
    13d0:	de bf       	out	0x3e, r29	; 62
    13d2:	0f be       	out	0x3f, r0	; 63
    13d4:	cd bf       	out	0x3d, r28	; 61
    13d6:	cf 91       	pop	r28
    13d8:	df 91       	pop	r29
    13da:	08 95       	ret

000013dc <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    13dc:	df 93       	push	r29
    13de:	cf 93       	push	r28
    13e0:	00 d0       	rcall	.+0      	; 0x13e2 <pvPortMalloc+0x6>
    13e2:	00 d0       	rcall	.+0      	; 0x13e4 <pvPortMalloc+0x8>
    13e4:	cd b7       	in	r28, 0x3d	; 61
    13e6:	de b7       	in	r29, 0x3e	; 62
    13e8:	9c 83       	std	Y+4, r25	; 0x04
    13ea:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL;
    13ec:	1a 82       	std	Y+2, r1	; 0x02
    13ee:	19 82       	std	Y+1, r1	; 0x01
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
    13f0:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    13f4:	80 91 8d 00 	lds	r24, 0x008D
    13f8:	90 91 8e 00 	lds	r25, 0x008E
    13fc:	00 97       	sbiw	r24, 0x00	; 0
    13fe:	31 f4       	brne	.+12     	; 0x140c <pvPortMalloc+0x30>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    1400:	80 e9       	ldi	r24, 0x90	; 144
    1402:	90 e0       	ldi	r25, 0x00	; 0
    1404:	90 93 8e 00 	sts	0x008E, r25
    1408:	80 93 8d 00 	sts	0x008D, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    140c:	80 91 8b 00 	lds	r24, 0x008B
    1410:	90 91 8c 00 	lds	r25, 0x008C
    1414:	2b 81       	ldd	r18, Y+3	; 0x03
    1416:	3c 81       	ldd	r19, Y+4	; 0x04
    1418:	82 0f       	add	r24, r18
    141a:	93 1f       	adc	r25, r19
    141c:	23 e0       	ldi	r18, 0x03	; 3
    141e:	87 3e       	cpi	r24, 0xE7	; 231
    1420:	92 07       	cpc	r25, r18
    1422:	38 f5       	brcc	.+78     	; 0x1472 <pvPortMalloc+0x96>
    1424:	20 91 8b 00 	lds	r18, 0x008B
    1428:	30 91 8c 00 	lds	r19, 0x008C
    142c:	8b 81       	ldd	r24, Y+3	; 0x03
    142e:	9c 81       	ldd	r25, Y+4	; 0x04
    1430:	28 0f       	add	r18, r24
    1432:	39 1f       	adc	r19, r25
    1434:	80 91 8b 00 	lds	r24, 0x008B
    1438:	90 91 8c 00 	lds	r25, 0x008C
    143c:	82 17       	cp	r24, r18
    143e:	93 07       	cpc	r25, r19
    1440:	c0 f4       	brcc	.+48     	; 0x1472 <pvPortMalloc+0x96>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1442:	20 91 8d 00 	lds	r18, 0x008D
    1446:	30 91 8e 00 	lds	r19, 0x008E
    144a:	80 91 8b 00 	lds	r24, 0x008B
    144e:	90 91 8c 00 	lds	r25, 0x008C
    1452:	82 0f       	add	r24, r18
    1454:	93 1f       	adc	r25, r19
    1456:	9a 83       	std	Y+2, r25	; 0x02
    1458:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;
    145a:	20 91 8b 00 	lds	r18, 0x008B
    145e:	30 91 8c 00 	lds	r19, 0x008C
    1462:	8b 81       	ldd	r24, Y+3	; 0x03
    1464:	9c 81       	ldd	r25, Y+4	; 0x04
    1466:	82 0f       	add	r24, r18
    1468:	93 1f       	adc	r25, r19
    146a:	90 93 8c 00 	sts	0x008C, r25
    146e:	80 93 8b 00 	sts	0x008B, r24
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1472:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif

	return pvReturn;
    1476:	89 81       	ldd	r24, Y+1	; 0x01
    1478:	9a 81       	ldd	r25, Y+2	; 0x02
}
    147a:	0f 90       	pop	r0
    147c:	0f 90       	pop	r0
    147e:	0f 90       	pop	r0
    1480:	0f 90       	pop	r0
    1482:	cf 91       	pop	r28
    1484:	df 91       	pop	r29
    1486:	08 95       	ret

00001488 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1488:	df 93       	push	r29
    148a:	cf 93       	push	r28
    148c:	00 d0       	rcall	.+0      	; 0x148e <vPortFree+0x6>
    148e:	cd b7       	in	r28, 0x3d	; 61
    1490:	de b7       	in	r29, 0x3e	; 62
    1492:	9a 83       	std	Y+2, r25	; 0x02
    1494:	89 83       	std	Y+1, r24	; 0x01
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1496:	0f 90       	pop	r0
    1498:	0f 90       	pop	r0
    149a:	cf 91       	pop	r28
    149c:	df 91       	pop	r29
    149e:	08 95       	ret

000014a0 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    14a0:	df 93       	push	r29
    14a2:	cf 93       	push	r28
    14a4:	cd b7       	in	r28, 0x3d	; 61
    14a6:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    14a8:	10 92 8c 00 	sts	0x008C, r1
    14ac:	10 92 8b 00 	sts	0x008B, r1
}
    14b0:	cf 91       	pop	r28
    14b2:	df 91       	pop	r29
    14b4:	08 95       	ret

000014b6 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    14b6:	df 93       	push	r29
    14b8:	cf 93       	push	r28
    14ba:	cd b7       	in	r28, 0x3d	; 61
    14bc:	de b7       	in	r29, 0x3e	; 62
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
    14be:	20 91 8b 00 	lds	r18, 0x008B
    14c2:	30 91 8c 00 	lds	r19, 0x008C
    14c6:	87 ee       	ldi	r24, 0xE7	; 231
    14c8:	93 e0       	ldi	r25, 0x03	; 3
    14ca:	82 1b       	sub	r24, r18
    14cc:	93 0b       	sbc	r25, r19
}
    14ce:	cf 91       	pop	r28
    14d0:	df 91       	pop	r29
    14d2:	08 95       	ret

000014d4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    14d4:	df 93       	push	r29
    14d6:	cf 93       	push	r28
    14d8:	00 d0       	rcall	.+0      	; 0x14da <vListInitialise+0x6>
    14da:	cd b7       	in	r28, 0x3d	; 61
    14dc:	de b7       	in	r29, 0x3e	; 62
    14de:	9a 83       	std	Y+2, r25	; 0x02
    14e0:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    14e2:	89 81       	ldd	r24, Y+1	; 0x01
    14e4:	9a 81       	ldd	r25, Y+2	; 0x02
    14e6:	03 96       	adiw	r24, 0x03	; 3
    14e8:	e9 81       	ldd	r30, Y+1	; 0x01
    14ea:	fa 81       	ldd	r31, Y+2	; 0x02
    14ec:	92 83       	std	Z+2, r25	; 0x02
    14ee:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    14f0:	e9 81       	ldd	r30, Y+1	; 0x01
    14f2:	fa 81       	ldd	r31, Y+2	; 0x02
    14f4:	8f ef       	ldi	r24, 0xFF	; 255
    14f6:	9f ef       	ldi	r25, 0xFF	; 255
    14f8:	94 83       	std	Z+4, r25	; 0x04
    14fa:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    14fc:	89 81       	ldd	r24, Y+1	; 0x01
    14fe:	9a 81       	ldd	r25, Y+2	; 0x02
    1500:	03 96       	adiw	r24, 0x03	; 3
    1502:	e9 81       	ldd	r30, Y+1	; 0x01
    1504:	fa 81       	ldd	r31, Y+2	; 0x02
    1506:	96 83       	std	Z+6, r25	; 0x06
    1508:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    150a:	89 81       	ldd	r24, Y+1	; 0x01
    150c:	9a 81       	ldd	r25, Y+2	; 0x02
    150e:	03 96       	adiw	r24, 0x03	; 3
    1510:	e9 81       	ldd	r30, Y+1	; 0x01
    1512:	fa 81       	ldd	r31, Y+2	; 0x02
    1514:	90 87       	std	Z+8, r25	; 0x08
    1516:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1518:	e9 81       	ldd	r30, Y+1	; 0x01
    151a:	fa 81       	ldd	r31, Y+2	; 0x02
    151c:	10 82       	st	Z, r1

	/* Write known values into the list if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
	listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    151e:	0f 90       	pop	r0
    1520:	0f 90       	pop	r0
    1522:	cf 91       	pop	r28
    1524:	df 91       	pop	r29
    1526:	08 95       	ret

00001528 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    1528:	df 93       	push	r29
    152a:	cf 93       	push	r28
    152c:	00 d0       	rcall	.+0      	; 0x152e <vListInitialiseItem+0x6>
    152e:	cd b7       	in	r28, 0x3d	; 61
    1530:	de b7       	in	r29, 0x3e	; 62
    1532:	9a 83       	std	Y+2, r25	; 0x02
    1534:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1536:	e9 81       	ldd	r30, Y+1	; 0x01
    1538:	fa 81       	ldd	r31, Y+2	; 0x02
    153a:	11 86       	std	Z+9, r1	; 0x09
    153c:	10 86       	std	Z+8, r1	; 0x08

	/* Write known values into the list item if
	configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
	listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    153e:	0f 90       	pop	r0
    1540:	0f 90       	pop	r0
    1542:	cf 91       	pop	r28
    1544:	df 91       	pop	r29
    1546:	08 95       	ret

00001548 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1548:	df 93       	push	r29
    154a:	cf 93       	push	r28
    154c:	00 d0       	rcall	.+0      	; 0x154e <vListInsertEnd+0x6>
    154e:	00 d0       	rcall	.+0      	; 0x1550 <vListInsertEnd+0x8>
    1550:	00 d0       	rcall	.+0      	; 0x1552 <vListInsertEnd+0xa>
    1552:	cd b7       	in	r28, 0x3d	; 61
    1554:	de b7       	in	r29, 0x3e	; 62
    1556:	9c 83       	std	Y+4, r25	; 0x04
    1558:	8b 83       	std	Y+3, r24	; 0x03
    155a:	7e 83       	std	Y+6, r23	; 0x06
    155c:	6d 83       	std	Y+5, r22	; 0x05
ListItem_t * const pxIndex = pxList->pxIndex;
    155e:	eb 81       	ldd	r30, Y+3	; 0x03
    1560:	fc 81       	ldd	r31, Y+4	; 0x04
    1562:	81 81       	ldd	r24, Z+1	; 0x01
    1564:	92 81       	ldd	r25, Z+2	; 0x02
    1566:	9a 83       	std	Y+2, r25	; 0x02
    1568:	89 83       	std	Y+1, r24	; 0x01
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    156a:	ed 81       	ldd	r30, Y+5	; 0x05
    156c:	fe 81       	ldd	r31, Y+6	; 0x06
    156e:	89 81       	ldd	r24, Y+1	; 0x01
    1570:	9a 81       	ldd	r25, Y+2	; 0x02
    1572:	93 83       	std	Z+3, r25	; 0x03
    1574:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1576:	e9 81       	ldd	r30, Y+1	; 0x01
    1578:	fa 81       	ldd	r31, Y+2	; 0x02
    157a:	84 81       	ldd	r24, Z+4	; 0x04
    157c:	95 81       	ldd	r25, Z+5	; 0x05
    157e:	ed 81       	ldd	r30, Y+5	; 0x05
    1580:	fe 81       	ldd	r31, Y+6	; 0x06
    1582:	95 83       	std	Z+5, r25	; 0x05
    1584:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1586:	e9 81       	ldd	r30, Y+1	; 0x01
    1588:	fa 81       	ldd	r31, Y+2	; 0x02
    158a:	04 80       	ldd	r0, Z+4	; 0x04
    158c:	f5 81       	ldd	r31, Z+5	; 0x05
    158e:	e0 2d       	mov	r30, r0
    1590:	8d 81       	ldd	r24, Y+5	; 0x05
    1592:	9e 81       	ldd	r25, Y+6	; 0x06
    1594:	93 83       	std	Z+3, r25	; 0x03
    1596:	82 83       	std	Z+2, r24	; 0x02
	pxIndex->pxPrevious = pxNewListItem;
    1598:	e9 81       	ldd	r30, Y+1	; 0x01
    159a:	fa 81       	ldd	r31, Y+2	; 0x02
    159c:	8d 81       	ldd	r24, Y+5	; 0x05
    159e:	9e 81       	ldd	r25, Y+6	; 0x06
    15a0:	95 83       	std	Z+5, r25	; 0x05
    15a2:	84 83       	std	Z+4, r24	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    15a4:	ed 81       	ldd	r30, Y+5	; 0x05
    15a6:	fe 81       	ldd	r31, Y+6	; 0x06
    15a8:	8b 81       	ldd	r24, Y+3	; 0x03
    15aa:	9c 81       	ldd	r25, Y+4	; 0x04
    15ac:	91 87       	std	Z+9, r25	; 0x09
    15ae:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    15b0:	eb 81       	ldd	r30, Y+3	; 0x03
    15b2:	fc 81       	ldd	r31, Y+4	; 0x04
    15b4:	80 81       	ld	r24, Z
    15b6:	8f 5f       	subi	r24, 0xFF	; 255
    15b8:	eb 81       	ldd	r30, Y+3	; 0x03
    15ba:	fc 81       	ldd	r31, Y+4	; 0x04
    15bc:	80 83       	st	Z, r24
}
    15be:	26 96       	adiw	r28, 0x06	; 6
    15c0:	0f b6       	in	r0, 0x3f	; 63
    15c2:	f8 94       	cli
    15c4:	de bf       	out	0x3e, r29	; 62
    15c6:	0f be       	out	0x3f, r0	; 63
    15c8:	cd bf       	out	0x3d, r28	; 61
    15ca:	cf 91       	pop	r28
    15cc:	df 91       	pop	r29
    15ce:	08 95       	ret

000015d0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    15d0:	df 93       	push	r29
    15d2:	cf 93       	push	r28
    15d4:	cd b7       	in	r28, 0x3d	; 61
    15d6:	de b7       	in	r29, 0x3e	; 62
    15d8:	28 97       	sbiw	r28, 0x08	; 8
    15da:	0f b6       	in	r0, 0x3f	; 63
    15dc:	f8 94       	cli
    15de:	de bf       	out	0x3e, r29	; 62
    15e0:	0f be       	out	0x3f, r0	; 63
    15e2:	cd bf       	out	0x3d, r28	; 61
    15e4:	9e 83       	std	Y+6, r25	; 0x06
    15e6:	8d 83       	std	Y+5, r24	; 0x05
    15e8:	78 87       	std	Y+8, r23	; 0x08
    15ea:	6f 83       	std	Y+7, r22	; 0x07
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    15ec:	ef 81       	ldd	r30, Y+7	; 0x07
    15ee:	f8 85       	ldd	r31, Y+8	; 0x08
    15f0:	80 81       	ld	r24, Z
    15f2:	91 81       	ldd	r25, Z+1	; 0x01
    15f4:	9a 83       	std	Y+2, r25	; 0x02
    15f6:	89 83       	std	Y+1, r24	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    15f8:	89 81       	ldd	r24, Y+1	; 0x01
    15fa:	9a 81       	ldd	r25, Y+2	; 0x02
    15fc:	2f ef       	ldi	r18, 0xFF	; 255
    15fe:	8f 3f       	cpi	r24, 0xFF	; 255
    1600:	92 07       	cpc	r25, r18
    1602:	39 f4       	brne	.+14     	; 0x1612 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1604:	ed 81       	ldd	r30, Y+5	; 0x05
    1606:	fe 81       	ldd	r31, Y+6	; 0x06
    1608:	87 81       	ldd	r24, Z+7	; 0x07
    160a:	90 85       	ldd	r25, Z+8	; 0x08
    160c:	9c 83       	std	Y+4, r25	; 0x04
    160e:	8b 83       	std	Y+3, r24	; 0x03
    1610:	18 c0       	rjmp	.+48     	; 0x1642 <vListInsert+0x72>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    1612:	8d 81       	ldd	r24, Y+5	; 0x05
    1614:	9e 81       	ldd	r25, Y+6	; 0x06
    1616:	03 96       	adiw	r24, 0x03	; 3
    1618:	9c 83       	std	Y+4, r25	; 0x04
    161a:	8b 83       	std	Y+3, r24	; 0x03
    161c:	06 c0       	rjmp	.+12     	; 0x162a <vListInsert+0x5a>
    161e:	eb 81       	ldd	r30, Y+3	; 0x03
    1620:	fc 81       	ldd	r31, Y+4	; 0x04
    1622:	82 81       	ldd	r24, Z+2	; 0x02
    1624:	93 81       	ldd	r25, Z+3	; 0x03
    1626:	9c 83       	std	Y+4, r25	; 0x04
    1628:	8b 83       	std	Y+3, r24	; 0x03
    162a:	eb 81       	ldd	r30, Y+3	; 0x03
    162c:	fc 81       	ldd	r31, Y+4	; 0x04
    162e:	02 80       	ldd	r0, Z+2	; 0x02
    1630:	f3 81       	ldd	r31, Z+3	; 0x03
    1632:	e0 2d       	mov	r30, r0
    1634:	20 81       	ld	r18, Z
    1636:	31 81       	ldd	r19, Z+1	; 0x01
    1638:	89 81       	ldd	r24, Y+1	; 0x01
    163a:	9a 81       	ldd	r25, Y+2	; 0x02
    163c:	82 17       	cp	r24, r18
    163e:	93 07       	cpc	r25, r19
    1640:	70 f7       	brcc	.-36     	; 0x161e <vListInsert+0x4e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1642:	eb 81       	ldd	r30, Y+3	; 0x03
    1644:	fc 81       	ldd	r31, Y+4	; 0x04
    1646:	82 81       	ldd	r24, Z+2	; 0x02
    1648:	93 81       	ldd	r25, Z+3	; 0x03
    164a:	ef 81       	ldd	r30, Y+7	; 0x07
    164c:	f8 85       	ldd	r31, Y+8	; 0x08
    164e:	93 83       	std	Z+3, r25	; 0x03
    1650:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1652:	ef 81       	ldd	r30, Y+7	; 0x07
    1654:	f8 85       	ldd	r31, Y+8	; 0x08
    1656:	02 80       	ldd	r0, Z+2	; 0x02
    1658:	f3 81       	ldd	r31, Z+3	; 0x03
    165a:	e0 2d       	mov	r30, r0
    165c:	8f 81       	ldd	r24, Y+7	; 0x07
    165e:	98 85       	ldd	r25, Y+8	; 0x08
    1660:	95 83       	std	Z+5, r25	; 0x05
    1662:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1664:	ef 81       	ldd	r30, Y+7	; 0x07
    1666:	f8 85       	ldd	r31, Y+8	; 0x08
    1668:	8b 81       	ldd	r24, Y+3	; 0x03
    166a:	9c 81       	ldd	r25, Y+4	; 0x04
    166c:	95 83       	std	Z+5, r25	; 0x05
    166e:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1670:	eb 81       	ldd	r30, Y+3	; 0x03
    1672:	fc 81       	ldd	r31, Y+4	; 0x04
    1674:	8f 81       	ldd	r24, Y+7	; 0x07
    1676:	98 85       	ldd	r25, Y+8	; 0x08
    1678:	93 83       	std	Z+3, r25	; 0x03
    167a:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    167c:	ef 81       	ldd	r30, Y+7	; 0x07
    167e:	f8 85       	ldd	r31, Y+8	; 0x08
    1680:	8d 81       	ldd	r24, Y+5	; 0x05
    1682:	9e 81       	ldd	r25, Y+6	; 0x06
    1684:	91 87       	std	Z+9, r25	; 0x09
    1686:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1688:	ed 81       	ldd	r30, Y+5	; 0x05
    168a:	fe 81       	ldd	r31, Y+6	; 0x06
    168c:	80 81       	ld	r24, Z
    168e:	8f 5f       	subi	r24, 0xFF	; 255
    1690:	ed 81       	ldd	r30, Y+5	; 0x05
    1692:	fe 81       	ldd	r31, Y+6	; 0x06
    1694:	80 83       	st	Z, r24
}
    1696:	28 96       	adiw	r28, 0x08	; 8
    1698:	0f b6       	in	r0, 0x3f	; 63
    169a:	f8 94       	cli
    169c:	de bf       	out	0x3e, r29	; 62
    169e:	0f be       	out	0x3f, r0	; 63
    16a0:	cd bf       	out	0x3d, r28	; 61
    16a2:	cf 91       	pop	r28
    16a4:	df 91       	pop	r29
    16a6:	08 95       	ret

000016a8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    16a8:	df 93       	push	r29
    16aa:	cf 93       	push	r28
    16ac:	00 d0       	rcall	.+0      	; 0x16ae <uxListRemove+0x6>
    16ae:	00 d0       	rcall	.+0      	; 0x16b0 <uxListRemove+0x8>
    16b0:	cd b7       	in	r28, 0x3d	; 61
    16b2:	de b7       	in	r29, 0x3e	; 62
    16b4:	9c 83       	std	Y+4, r25	; 0x04
    16b6:	8b 83       	std	Y+3, r24	; 0x03
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    16b8:	eb 81       	ldd	r30, Y+3	; 0x03
    16ba:	fc 81       	ldd	r31, Y+4	; 0x04
    16bc:	80 85       	ldd	r24, Z+8	; 0x08
    16be:	91 85       	ldd	r25, Z+9	; 0x09
    16c0:	9a 83       	std	Y+2, r25	; 0x02
    16c2:	89 83       	std	Y+1, r24	; 0x01

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    16c4:	eb 81       	ldd	r30, Y+3	; 0x03
    16c6:	fc 81       	ldd	r31, Y+4	; 0x04
    16c8:	a2 81       	ldd	r26, Z+2	; 0x02
    16ca:	b3 81       	ldd	r27, Z+3	; 0x03
    16cc:	eb 81       	ldd	r30, Y+3	; 0x03
    16ce:	fc 81       	ldd	r31, Y+4	; 0x04
    16d0:	84 81       	ldd	r24, Z+4	; 0x04
    16d2:	95 81       	ldd	r25, Z+5	; 0x05
    16d4:	15 96       	adiw	r26, 0x05	; 5
    16d6:	9c 93       	st	X, r25
    16d8:	8e 93       	st	-X, r24
    16da:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    16dc:	eb 81       	ldd	r30, Y+3	; 0x03
    16de:	fc 81       	ldd	r31, Y+4	; 0x04
    16e0:	a4 81       	ldd	r26, Z+4	; 0x04
    16e2:	b5 81       	ldd	r27, Z+5	; 0x05
    16e4:	eb 81       	ldd	r30, Y+3	; 0x03
    16e6:	fc 81       	ldd	r31, Y+4	; 0x04
    16e8:	82 81       	ldd	r24, Z+2	; 0x02
    16ea:	93 81       	ldd	r25, Z+3	; 0x03
    16ec:	13 96       	adiw	r26, 0x03	; 3
    16ee:	9c 93       	st	X, r25
    16f0:	8e 93       	st	-X, r24
    16f2:	12 97       	sbiw	r26, 0x02	; 2

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    16f4:	e9 81       	ldd	r30, Y+1	; 0x01
    16f6:	fa 81       	ldd	r31, Y+2	; 0x02
    16f8:	21 81       	ldd	r18, Z+1	; 0x01
    16fa:	32 81       	ldd	r19, Z+2	; 0x02
    16fc:	8b 81       	ldd	r24, Y+3	; 0x03
    16fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1700:	28 17       	cp	r18, r24
    1702:	39 07       	cpc	r19, r25
    1704:	41 f4       	brne	.+16     	; 0x1716 <uxListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1706:	eb 81       	ldd	r30, Y+3	; 0x03
    1708:	fc 81       	ldd	r31, Y+4	; 0x04
    170a:	84 81       	ldd	r24, Z+4	; 0x04
    170c:	95 81       	ldd	r25, Z+5	; 0x05
    170e:	e9 81       	ldd	r30, Y+1	; 0x01
    1710:	fa 81       	ldd	r31, Y+2	; 0x02
    1712:	92 83       	std	Z+2, r25	; 0x02
    1714:	81 83       	std	Z+1, r24	; 0x01
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    1716:	eb 81       	ldd	r30, Y+3	; 0x03
    1718:	fc 81       	ldd	r31, Y+4	; 0x04
    171a:	11 86       	std	Z+9, r1	; 0x09
    171c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    171e:	e9 81       	ldd	r30, Y+1	; 0x01
    1720:	fa 81       	ldd	r31, Y+2	; 0x02
    1722:	80 81       	ld	r24, Z
    1724:	81 50       	subi	r24, 0x01	; 1
    1726:	e9 81       	ldd	r30, Y+1	; 0x01
    1728:	fa 81       	ldd	r31, Y+2	; 0x02
    172a:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    172c:	e9 81       	ldd	r30, Y+1	; 0x01
    172e:	fa 81       	ldd	r31, Y+2	; 0x02
    1730:	80 81       	ld	r24, Z
}
    1732:	0f 90       	pop	r0
    1734:	0f 90       	pop	r0
    1736:	0f 90       	pop	r0
    1738:	0f 90       	pop	r0
    173a:	cf 91       	pop	r28
    173c:	df 91       	pop	r29
    173e:	08 95       	ret

00001740 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1740:	df 93       	push	r29
    1742:	cf 93       	push	r28
    1744:	cd b7       	in	r28, 0x3d	; 61
    1746:	de b7       	in	r29, 0x3e	; 62
    1748:	28 97       	sbiw	r28, 0x08	; 8
    174a:	0f b6       	in	r0, 0x3f	; 63
    174c:	f8 94       	cli
    174e:	de bf       	out	0x3e, r29	; 62
    1750:	0f be       	out	0x3f, r0	; 63
    1752:	cd bf       	out	0x3d, r28	; 61
    1754:	9c 83       	std	Y+4, r25	; 0x04
    1756:	8b 83       	std	Y+3, r24	; 0x03
    1758:	7e 83       	std	Y+6, r23	; 0x06
    175a:	6d 83       	std	Y+5, r22	; 0x05
    175c:	58 87       	std	Y+8, r21	; 0x08
    175e:	4f 83       	std	Y+7, r20	; 0x07
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1760:	eb 81       	ldd	r30, Y+3	; 0x03
    1762:	fc 81       	ldd	r31, Y+4	; 0x04
    1764:	81 e1       	ldi	r24, 0x11	; 17
    1766:	80 83       	st	Z, r24
	pxTopOfStack--;
    1768:	8b 81       	ldd	r24, Y+3	; 0x03
    176a:	9c 81       	ldd	r25, Y+4	; 0x04
    176c:	01 97       	sbiw	r24, 0x01	; 1
    176e:	9c 83       	std	Y+4, r25	; 0x04
    1770:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    1772:	eb 81       	ldd	r30, Y+3	; 0x03
    1774:	fc 81       	ldd	r31, Y+4	; 0x04
    1776:	82 e2       	ldi	r24, 0x22	; 34
    1778:	80 83       	st	Z, r24
	pxTopOfStack--;
    177a:	8b 81       	ldd	r24, Y+3	; 0x03
    177c:	9c 81       	ldd	r25, Y+4	; 0x04
    177e:	01 97       	sbiw	r24, 0x01	; 1
    1780:	9c 83       	std	Y+4, r25	; 0x04
    1782:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1784:	eb 81       	ldd	r30, Y+3	; 0x03
    1786:	fc 81       	ldd	r31, Y+4	; 0x04
    1788:	83 e3       	ldi	r24, 0x33	; 51
    178a:	80 83       	st	Z, r24
	pxTopOfStack--;
    178c:	8b 81       	ldd	r24, Y+3	; 0x03
    178e:	9c 81       	ldd	r25, Y+4	; 0x04
    1790:	01 97       	sbiw	r24, 0x01	; 1
    1792:	9c 83       	std	Y+4, r25	; 0x04
    1794:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
    1796:	8d 81       	ldd	r24, Y+5	; 0x05
    1798:	9e 81       	ldd	r25, Y+6	; 0x06
    179a:	9a 83       	std	Y+2, r25	; 0x02
    179c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    179e:	89 81       	ldd	r24, Y+1	; 0x01
    17a0:	eb 81       	ldd	r30, Y+3	; 0x03
    17a2:	fc 81       	ldd	r31, Y+4	; 0x04
    17a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    17a6:	8b 81       	ldd	r24, Y+3	; 0x03
    17a8:	9c 81       	ldd	r25, Y+4	; 0x04
    17aa:	01 97       	sbiw	r24, 0x01	; 1
    17ac:	9c 83       	std	Y+4, r25	; 0x04
    17ae:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    17b0:	89 81       	ldd	r24, Y+1	; 0x01
    17b2:	9a 81       	ldd	r25, Y+2	; 0x02
    17b4:	89 2f       	mov	r24, r25
    17b6:	99 27       	eor	r25, r25
    17b8:	9a 83       	std	Y+2, r25	; 0x02
    17ba:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    17bc:	89 81       	ldd	r24, Y+1	; 0x01
    17be:	eb 81       	ldd	r30, Y+3	; 0x03
    17c0:	fc 81       	ldd	r31, Y+4	; 0x04
    17c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    17c4:	8b 81       	ldd	r24, Y+3	; 0x03
    17c6:	9c 81       	ldd	r25, Y+4	; 0x04
    17c8:	01 97       	sbiw	r24, 0x01	; 1
    17ca:	9c 83       	std	Y+4, r25	; 0x04
    17cc:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    17ce:	eb 81       	ldd	r30, Y+3	; 0x03
    17d0:	fc 81       	ldd	r31, Y+4	; 0x04
    17d2:	10 82       	st	Z, r1
	pxTopOfStack--;
    17d4:	8b 81       	ldd	r24, Y+3	; 0x03
    17d6:	9c 81       	ldd	r25, Y+4	; 0x04
    17d8:	01 97       	sbiw	r24, 0x01	; 1
    17da:	9c 83       	std	Y+4, r25	; 0x04
    17dc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    17de:	eb 81       	ldd	r30, Y+3	; 0x03
    17e0:	fc 81       	ldd	r31, Y+4	; 0x04
    17e2:	80 e8       	ldi	r24, 0x80	; 128
    17e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    17e6:	8b 81       	ldd	r24, Y+3	; 0x03
    17e8:	9c 81       	ldd	r25, Y+4	; 0x04
    17ea:	01 97       	sbiw	r24, 0x01	; 1
    17ec:	9c 83       	std	Y+4, r25	; 0x04
    17ee:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    17f0:	eb 81       	ldd	r30, Y+3	; 0x03
    17f2:	fc 81       	ldd	r31, Y+4	; 0x04
    17f4:	10 82       	st	Z, r1
	pxTopOfStack--;
    17f6:	8b 81       	ldd	r24, Y+3	; 0x03
    17f8:	9c 81       	ldd	r25, Y+4	; 0x04
    17fa:	01 97       	sbiw	r24, 0x01	; 1
    17fc:	9c 83       	std	Y+4, r25	; 0x04
    17fe:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    1800:	eb 81       	ldd	r30, Y+3	; 0x03
    1802:	fc 81       	ldd	r31, Y+4	; 0x04
    1804:	82 e0       	ldi	r24, 0x02	; 2
    1806:	80 83       	st	Z, r24
	pxTopOfStack--;
    1808:	8b 81       	ldd	r24, Y+3	; 0x03
    180a:	9c 81       	ldd	r25, Y+4	; 0x04
    180c:	01 97       	sbiw	r24, 0x01	; 1
    180e:	9c 83       	std	Y+4, r25	; 0x04
    1810:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    1812:	eb 81       	ldd	r30, Y+3	; 0x03
    1814:	fc 81       	ldd	r31, Y+4	; 0x04
    1816:	83 e0       	ldi	r24, 0x03	; 3
    1818:	80 83       	st	Z, r24
	pxTopOfStack--;
    181a:	8b 81       	ldd	r24, Y+3	; 0x03
    181c:	9c 81       	ldd	r25, Y+4	; 0x04
    181e:	01 97       	sbiw	r24, 0x01	; 1
    1820:	9c 83       	std	Y+4, r25	; 0x04
    1822:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    1824:	eb 81       	ldd	r30, Y+3	; 0x03
    1826:	fc 81       	ldd	r31, Y+4	; 0x04
    1828:	84 e0       	ldi	r24, 0x04	; 4
    182a:	80 83       	st	Z, r24
	pxTopOfStack--;
    182c:	8b 81       	ldd	r24, Y+3	; 0x03
    182e:	9c 81       	ldd	r25, Y+4	; 0x04
    1830:	01 97       	sbiw	r24, 0x01	; 1
    1832:	9c 83       	std	Y+4, r25	; 0x04
    1834:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    1836:	eb 81       	ldd	r30, Y+3	; 0x03
    1838:	fc 81       	ldd	r31, Y+4	; 0x04
    183a:	85 e0       	ldi	r24, 0x05	; 5
    183c:	80 83       	st	Z, r24
	pxTopOfStack--;
    183e:	8b 81       	ldd	r24, Y+3	; 0x03
    1840:	9c 81       	ldd	r25, Y+4	; 0x04
    1842:	01 97       	sbiw	r24, 0x01	; 1
    1844:	9c 83       	std	Y+4, r25	; 0x04
    1846:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    1848:	eb 81       	ldd	r30, Y+3	; 0x03
    184a:	fc 81       	ldd	r31, Y+4	; 0x04
    184c:	86 e0       	ldi	r24, 0x06	; 6
    184e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1850:	8b 81       	ldd	r24, Y+3	; 0x03
    1852:	9c 81       	ldd	r25, Y+4	; 0x04
    1854:	01 97       	sbiw	r24, 0x01	; 1
    1856:	9c 83       	std	Y+4, r25	; 0x04
    1858:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    185a:	eb 81       	ldd	r30, Y+3	; 0x03
    185c:	fc 81       	ldd	r31, Y+4	; 0x04
    185e:	87 e0       	ldi	r24, 0x07	; 7
    1860:	80 83       	st	Z, r24
	pxTopOfStack--;
    1862:	8b 81       	ldd	r24, Y+3	; 0x03
    1864:	9c 81       	ldd	r25, Y+4	; 0x04
    1866:	01 97       	sbiw	r24, 0x01	; 1
    1868:	9c 83       	std	Y+4, r25	; 0x04
    186a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    186c:	eb 81       	ldd	r30, Y+3	; 0x03
    186e:	fc 81       	ldd	r31, Y+4	; 0x04
    1870:	88 e0       	ldi	r24, 0x08	; 8
    1872:	80 83       	st	Z, r24
	pxTopOfStack--;
    1874:	8b 81       	ldd	r24, Y+3	; 0x03
    1876:	9c 81       	ldd	r25, Y+4	; 0x04
    1878:	01 97       	sbiw	r24, 0x01	; 1
    187a:	9c 83       	std	Y+4, r25	; 0x04
    187c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    187e:	eb 81       	ldd	r30, Y+3	; 0x03
    1880:	fc 81       	ldd	r31, Y+4	; 0x04
    1882:	89 e0       	ldi	r24, 0x09	; 9
    1884:	80 83       	st	Z, r24
	pxTopOfStack--;
    1886:	8b 81       	ldd	r24, Y+3	; 0x03
    1888:	9c 81       	ldd	r25, Y+4	; 0x04
    188a:	01 97       	sbiw	r24, 0x01	; 1
    188c:	9c 83       	std	Y+4, r25	; 0x04
    188e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    1890:	eb 81       	ldd	r30, Y+3	; 0x03
    1892:	fc 81       	ldd	r31, Y+4	; 0x04
    1894:	80 e1       	ldi	r24, 0x10	; 16
    1896:	80 83       	st	Z, r24
	pxTopOfStack--;
    1898:	8b 81       	ldd	r24, Y+3	; 0x03
    189a:	9c 81       	ldd	r25, Y+4	; 0x04
    189c:	01 97       	sbiw	r24, 0x01	; 1
    189e:	9c 83       	std	Y+4, r25	; 0x04
    18a0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    18a2:	eb 81       	ldd	r30, Y+3	; 0x03
    18a4:	fc 81       	ldd	r31, Y+4	; 0x04
    18a6:	81 e1       	ldi	r24, 0x11	; 17
    18a8:	80 83       	st	Z, r24
	pxTopOfStack--;
    18aa:	8b 81       	ldd	r24, Y+3	; 0x03
    18ac:	9c 81       	ldd	r25, Y+4	; 0x04
    18ae:	01 97       	sbiw	r24, 0x01	; 1
    18b0:	9c 83       	std	Y+4, r25	; 0x04
    18b2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    18b4:	eb 81       	ldd	r30, Y+3	; 0x03
    18b6:	fc 81       	ldd	r31, Y+4	; 0x04
    18b8:	82 e1       	ldi	r24, 0x12	; 18
    18ba:	80 83       	st	Z, r24
	pxTopOfStack--;
    18bc:	8b 81       	ldd	r24, Y+3	; 0x03
    18be:	9c 81       	ldd	r25, Y+4	; 0x04
    18c0:	01 97       	sbiw	r24, 0x01	; 1
    18c2:	9c 83       	std	Y+4, r25	; 0x04
    18c4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    18c6:	eb 81       	ldd	r30, Y+3	; 0x03
    18c8:	fc 81       	ldd	r31, Y+4	; 0x04
    18ca:	83 e1       	ldi	r24, 0x13	; 19
    18cc:	80 83       	st	Z, r24
	pxTopOfStack--;
    18ce:	8b 81       	ldd	r24, Y+3	; 0x03
    18d0:	9c 81       	ldd	r25, Y+4	; 0x04
    18d2:	01 97       	sbiw	r24, 0x01	; 1
    18d4:	9c 83       	std	Y+4, r25	; 0x04
    18d6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    18d8:	eb 81       	ldd	r30, Y+3	; 0x03
    18da:	fc 81       	ldd	r31, Y+4	; 0x04
    18dc:	84 e1       	ldi	r24, 0x14	; 20
    18de:	80 83       	st	Z, r24
	pxTopOfStack--;
    18e0:	8b 81       	ldd	r24, Y+3	; 0x03
    18e2:	9c 81       	ldd	r25, Y+4	; 0x04
    18e4:	01 97       	sbiw	r24, 0x01	; 1
    18e6:	9c 83       	std	Y+4, r25	; 0x04
    18e8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    18ea:	eb 81       	ldd	r30, Y+3	; 0x03
    18ec:	fc 81       	ldd	r31, Y+4	; 0x04
    18ee:	85 e1       	ldi	r24, 0x15	; 21
    18f0:	80 83       	st	Z, r24
	pxTopOfStack--;
    18f2:	8b 81       	ldd	r24, Y+3	; 0x03
    18f4:	9c 81       	ldd	r25, Y+4	; 0x04
    18f6:	01 97       	sbiw	r24, 0x01	; 1
    18f8:	9c 83       	std	Y+4, r25	; 0x04
    18fa:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    18fc:	eb 81       	ldd	r30, Y+3	; 0x03
    18fe:	fc 81       	ldd	r31, Y+4	; 0x04
    1900:	86 e1       	ldi	r24, 0x16	; 22
    1902:	80 83       	st	Z, r24
	pxTopOfStack--;
    1904:	8b 81       	ldd	r24, Y+3	; 0x03
    1906:	9c 81       	ldd	r25, Y+4	; 0x04
    1908:	01 97       	sbiw	r24, 0x01	; 1
    190a:	9c 83       	std	Y+4, r25	; 0x04
    190c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    190e:	eb 81       	ldd	r30, Y+3	; 0x03
    1910:	fc 81       	ldd	r31, Y+4	; 0x04
    1912:	87 e1       	ldi	r24, 0x17	; 23
    1914:	80 83       	st	Z, r24
	pxTopOfStack--;
    1916:	8b 81       	ldd	r24, Y+3	; 0x03
    1918:	9c 81       	ldd	r25, Y+4	; 0x04
    191a:	01 97       	sbiw	r24, 0x01	; 1
    191c:	9c 83       	std	Y+4, r25	; 0x04
    191e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    1920:	eb 81       	ldd	r30, Y+3	; 0x03
    1922:	fc 81       	ldd	r31, Y+4	; 0x04
    1924:	88 e1       	ldi	r24, 0x18	; 24
    1926:	80 83       	st	Z, r24
	pxTopOfStack--;
    1928:	8b 81       	ldd	r24, Y+3	; 0x03
    192a:	9c 81       	ldd	r25, Y+4	; 0x04
    192c:	01 97       	sbiw	r24, 0x01	; 1
    192e:	9c 83       	std	Y+4, r25	; 0x04
    1930:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    1932:	eb 81       	ldd	r30, Y+3	; 0x03
    1934:	fc 81       	ldd	r31, Y+4	; 0x04
    1936:	89 e1       	ldi	r24, 0x19	; 25
    1938:	80 83       	st	Z, r24
	pxTopOfStack--;
    193a:	8b 81       	ldd	r24, Y+3	; 0x03
    193c:	9c 81       	ldd	r25, Y+4	; 0x04
    193e:	01 97       	sbiw	r24, 0x01	; 1
    1940:	9c 83       	std	Y+4, r25	; 0x04
    1942:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    1944:	eb 81       	ldd	r30, Y+3	; 0x03
    1946:	fc 81       	ldd	r31, Y+4	; 0x04
    1948:	80 e2       	ldi	r24, 0x20	; 32
    194a:	80 83       	st	Z, r24
	pxTopOfStack--;
    194c:	8b 81       	ldd	r24, Y+3	; 0x03
    194e:	9c 81       	ldd	r25, Y+4	; 0x04
    1950:	01 97       	sbiw	r24, 0x01	; 1
    1952:	9c 83       	std	Y+4, r25	; 0x04
    1954:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    1956:	eb 81       	ldd	r30, Y+3	; 0x03
    1958:	fc 81       	ldd	r31, Y+4	; 0x04
    195a:	81 e2       	ldi	r24, 0x21	; 33
    195c:	80 83       	st	Z, r24
	pxTopOfStack--;
    195e:	8b 81       	ldd	r24, Y+3	; 0x03
    1960:	9c 81       	ldd	r25, Y+4	; 0x04
    1962:	01 97       	sbiw	r24, 0x01	; 1
    1964:	9c 83       	std	Y+4, r25	; 0x04
    1966:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    1968:	eb 81       	ldd	r30, Y+3	; 0x03
    196a:	fc 81       	ldd	r31, Y+4	; 0x04
    196c:	82 e2       	ldi	r24, 0x22	; 34
    196e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1970:	8b 81       	ldd	r24, Y+3	; 0x03
    1972:	9c 81       	ldd	r25, Y+4	; 0x04
    1974:	01 97       	sbiw	r24, 0x01	; 1
    1976:	9c 83       	std	Y+4, r25	; 0x04
    1978:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    197a:	eb 81       	ldd	r30, Y+3	; 0x03
    197c:	fc 81       	ldd	r31, Y+4	; 0x04
    197e:	83 e2       	ldi	r24, 0x23	; 35
    1980:	80 83       	st	Z, r24
	pxTopOfStack--;
    1982:	8b 81       	ldd	r24, Y+3	; 0x03
    1984:	9c 81       	ldd	r25, Y+4	; 0x04
    1986:	01 97       	sbiw	r24, 0x01	; 1
    1988:	9c 83       	std	Y+4, r25	; 0x04
    198a:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
    198c:	8f 81       	ldd	r24, Y+7	; 0x07
    198e:	98 85       	ldd	r25, Y+8	; 0x08
    1990:	9a 83       	std	Y+2, r25	; 0x02
    1992:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    1994:	89 81       	ldd	r24, Y+1	; 0x01
    1996:	eb 81       	ldd	r30, Y+3	; 0x03
    1998:	fc 81       	ldd	r31, Y+4	; 0x04
    199a:	80 83       	st	Z, r24
	pxTopOfStack--;
    199c:	8b 81       	ldd	r24, Y+3	; 0x03
    199e:	9c 81       	ldd	r25, Y+4	; 0x04
    19a0:	01 97       	sbiw	r24, 0x01	; 1
    19a2:	9c 83       	std	Y+4, r25	; 0x04
    19a4:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    19a6:	89 81       	ldd	r24, Y+1	; 0x01
    19a8:	9a 81       	ldd	r25, Y+2	; 0x02
    19aa:	89 2f       	mov	r24, r25
    19ac:	99 27       	eor	r25, r25
    19ae:	9a 83       	std	Y+2, r25	; 0x02
    19b0:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    19b2:	89 81       	ldd	r24, Y+1	; 0x01
    19b4:	eb 81       	ldd	r30, Y+3	; 0x03
    19b6:	fc 81       	ldd	r31, Y+4	; 0x04
    19b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    19ba:	8b 81       	ldd	r24, Y+3	; 0x03
    19bc:	9c 81       	ldd	r25, Y+4	; 0x04
    19be:	01 97       	sbiw	r24, 0x01	; 1
    19c0:	9c 83       	std	Y+4, r25	; 0x04
    19c2:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    19c4:	eb 81       	ldd	r30, Y+3	; 0x03
    19c6:	fc 81       	ldd	r31, Y+4	; 0x04
    19c8:	86 e2       	ldi	r24, 0x26	; 38
    19ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    19cc:	8b 81       	ldd	r24, Y+3	; 0x03
    19ce:	9c 81       	ldd	r25, Y+4	; 0x04
    19d0:	01 97       	sbiw	r24, 0x01	; 1
    19d2:	9c 83       	std	Y+4, r25	; 0x04
    19d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    19d6:	eb 81       	ldd	r30, Y+3	; 0x03
    19d8:	fc 81       	ldd	r31, Y+4	; 0x04
    19da:	87 e2       	ldi	r24, 0x27	; 39
    19dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    19de:	8b 81       	ldd	r24, Y+3	; 0x03
    19e0:	9c 81       	ldd	r25, Y+4	; 0x04
    19e2:	01 97       	sbiw	r24, 0x01	; 1
    19e4:	9c 83       	std	Y+4, r25	; 0x04
    19e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    19e8:	eb 81       	ldd	r30, Y+3	; 0x03
    19ea:	fc 81       	ldd	r31, Y+4	; 0x04
    19ec:	88 e2       	ldi	r24, 0x28	; 40
    19ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    19f0:	8b 81       	ldd	r24, Y+3	; 0x03
    19f2:	9c 81       	ldd	r25, Y+4	; 0x04
    19f4:	01 97       	sbiw	r24, 0x01	; 1
    19f6:	9c 83       	std	Y+4, r25	; 0x04
    19f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    19fa:	eb 81       	ldd	r30, Y+3	; 0x03
    19fc:	fc 81       	ldd	r31, Y+4	; 0x04
    19fe:	89 e2       	ldi	r24, 0x29	; 41
    1a00:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a02:	8b 81       	ldd	r24, Y+3	; 0x03
    1a04:	9c 81       	ldd	r25, Y+4	; 0x04
    1a06:	01 97       	sbiw	r24, 0x01	; 1
    1a08:	9c 83       	std	Y+4, r25	; 0x04
    1a0a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    1a0c:	eb 81       	ldd	r30, Y+3	; 0x03
    1a0e:	fc 81       	ldd	r31, Y+4	; 0x04
    1a10:	80 e3       	ldi	r24, 0x30	; 48
    1a12:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a14:	8b 81       	ldd	r24, Y+3	; 0x03
    1a16:	9c 81       	ldd	r25, Y+4	; 0x04
    1a18:	01 97       	sbiw	r24, 0x01	; 1
    1a1a:	9c 83       	std	Y+4, r25	; 0x04
    1a1c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    1a1e:	eb 81       	ldd	r30, Y+3	; 0x03
    1a20:	fc 81       	ldd	r31, Y+4	; 0x04
    1a22:	81 e3       	ldi	r24, 0x31	; 49
    1a24:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a26:	8b 81       	ldd	r24, Y+3	; 0x03
    1a28:	9c 81       	ldd	r25, Y+4	; 0x04
    1a2a:	01 97       	sbiw	r24, 0x01	; 1
    1a2c:	9c 83       	std	Y+4, r25	; 0x04
    1a2e:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1a30:	8b 81       	ldd	r24, Y+3	; 0x03
    1a32:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1a34:	28 96       	adiw	r28, 0x08	; 8
    1a36:	0f b6       	in	r0, 0x3f	; 63
    1a38:	f8 94       	cli
    1a3a:	de bf       	out	0x3e, r29	; 62
    1a3c:	0f be       	out	0x3f, r0	; 63
    1a3e:	cd bf       	out	0x3d, r28	; 61
    1a40:	cf 91       	pop	r28
    1a42:	df 91       	pop	r29
    1a44:	08 95       	ret

00001a46 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

BaseType_t xPortStartScheduler( void )
{
    1a46:	df 93       	push	r29
    1a48:	cf 93       	push	r28
    1a4a:	cd b7       	in	r28, 0x3d	; 61
    1a4c:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1a4e:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1a52:	a0 91 77 04 	lds	r26, 0x0477
    1a56:	b0 91 78 04 	lds	r27, 0x0478
    1a5a:	cd 91       	ld	r28, X+
    1a5c:	cd bf       	out	0x3d, r28	; 61
    1a5e:	dd 91       	ld	r29, X+
    1a60:	de bf       	out	0x3e, r29	; 62
    1a62:	ff 91       	pop	r31
    1a64:	ef 91       	pop	r30
    1a66:	df 91       	pop	r29
    1a68:	cf 91       	pop	r28
    1a6a:	bf 91       	pop	r27
    1a6c:	af 91       	pop	r26
    1a6e:	9f 91       	pop	r25
    1a70:	8f 91       	pop	r24
    1a72:	7f 91       	pop	r23
    1a74:	6f 91       	pop	r22
    1a76:	5f 91       	pop	r21
    1a78:	4f 91       	pop	r20
    1a7a:	3f 91       	pop	r19
    1a7c:	2f 91       	pop	r18
    1a7e:	1f 91       	pop	r17
    1a80:	0f 91       	pop	r16
    1a82:	ff 90       	pop	r15
    1a84:	ef 90       	pop	r14
    1a86:	df 90       	pop	r13
    1a88:	cf 90       	pop	r12
    1a8a:	bf 90       	pop	r11
    1a8c:	af 90       	pop	r10
    1a8e:	9f 90       	pop	r9
    1a90:	8f 90       	pop	r8
    1a92:	7f 90       	pop	r7
    1a94:	6f 90       	pop	r6
    1a96:	5f 90       	pop	r5
    1a98:	4f 90       	pop	r4
    1a9a:	3f 90       	pop	r3
    1a9c:	2f 90       	pop	r2
    1a9e:	1f 90       	pop	r1
    1aa0:	0f 90       	pop	r0
    1aa2:	0f be       	out	0x3f, r0	; 63
    1aa4:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1aa6:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1aa8:	81 e0       	ldi	r24, 0x01	; 1
}
    1aaa:	cf 91       	pop	r28
    1aac:	df 91       	pop	r29
    1aae:	08 95       	ret

00001ab0 <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1ab0:	df 93       	push	r29
    1ab2:	cf 93       	push	r28
    1ab4:	cd b7       	in	r28, 0x3d	; 61
    1ab6:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1ab8:	cf 91       	pop	r28
    1aba:	df 91       	pop	r29
    1abc:	08 95       	ret

00001abe <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1abe:	0f 92       	push	r0
    1ac0:	0f b6       	in	r0, 0x3f	; 63
    1ac2:	f8 94       	cli
    1ac4:	0f 92       	push	r0
    1ac6:	1f 92       	push	r1
    1ac8:	11 24       	eor	r1, r1
    1aca:	2f 92       	push	r2
    1acc:	3f 92       	push	r3
    1ace:	4f 92       	push	r4
    1ad0:	5f 92       	push	r5
    1ad2:	6f 92       	push	r6
    1ad4:	7f 92       	push	r7
    1ad6:	8f 92       	push	r8
    1ad8:	9f 92       	push	r9
    1ada:	af 92       	push	r10
    1adc:	bf 92       	push	r11
    1ade:	cf 92       	push	r12
    1ae0:	df 92       	push	r13
    1ae2:	ef 92       	push	r14
    1ae4:	ff 92       	push	r15
    1ae6:	0f 93       	push	r16
    1ae8:	1f 93       	push	r17
    1aea:	2f 93       	push	r18
    1aec:	3f 93       	push	r19
    1aee:	4f 93       	push	r20
    1af0:	5f 93       	push	r21
    1af2:	6f 93       	push	r22
    1af4:	7f 93       	push	r23
    1af6:	8f 93       	push	r24
    1af8:	9f 93       	push	r25
    1afa:	af 93       	push	r26
    1afc:	bf 93       	push	r27
    1afe:	cf 93       	push	r28
    1b00:	df 93       	push	r29
    1b02:	ef 93       	push	r30
    1b04:	ff 93       	push	r31
    1b06:	a0 91 77 04 	lds	r26, 0x0477
    1b0a:	b0 91 78 04 	lds	r27, 0x0478
    1b0e:	0d b6       	in	r0, 0x3d	; 61
    1b10:	0d 92       	st	X+, r0
    1b12:	0e b6       	in	r0, 0x3e	; 62
    1b14:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1b16:	0e 94 20 1d 	call	0x3a40	; 0x3a40 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1b1a:	a0 91 77 04 	lds	r26, 0x0477
    1b1e:	b0 91 78 04 	lds	r27, 0x0478
    1b22:	cd 91       	ld	r28, X+
    1b24:	cd bf       	out	0x3d, r28	; 61
    1b26:	dd 91       	ld	r29, X+
    1b28:	de bf       	out	0x3e, r29	; 62
    1b2a:	ff 91       	pop	r31
    1b2c:	ef 91       	pop	r30
    1b2e:	df 91       	pop	r29
    1b30:	cf 91       	pop	r28
    1b32:	bf 91       	pop	r27
    1b34:	af 91       	pop	r26
    1b36:	9f 91       	pop	r25
    1b38:	8f 91       	pop	r24
    1b3a:	7f 91       	pop	r23
    1b3c:	6f 91       	pop	r22
    1b3e:	5f 91       	pop	r21
    1b40:	4f 91       	pop	r20
    1b42:	3f 91       	pop	r19
    1b44:	2f 91       	pop	r18
    1b46:	1f 91       	pop	r17
    1b48:	0f 91       	pop	r16
    1b4a:	ff 90       	pop	r15
    1b4c:	ef 90       	pop	r14
    1b4e:	df 90       	pop	r13
    1b50:	cf 90       	pop	r12
    1b52:	bf 90       	pop	r11
    1b54:	af 90       	pop	r10
    1b56:	9f 90       	pop	r9
    1b58:	8f 90       	pop	r8
    1b5a:	7f 90       	pop	r7
    1b5c:	6f 90       	pop	r6
    1b5e:	5f 90       	pop	r5
    1b60:	4f 90       	pop	r4
    1b62:	3f 90       	pop	r3
    1b64:	2f 90       	pop	r2
    1b66:	1f 90       	pop	r1
    1b68:	0f 90       	pop	r0
    1b6a:	0f be       	out	0x3f, r0	; 63
    1b6c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b6e:	08 95       	ret

00001b70 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1b70:	0f 92       	push	r0
    1b72:	0f b6       	in	r0, 0x3f	; 63
    1b74:	f8 94       	cli
    1b76:	0f 92       	push	r0
    1b78:	1f 92       	push	r1
    1b7a:	11 24       	eor	r1, r1
    1b7c:	2f 92       	push	r2
    1b7e:	3f 92       	push	r3
    1b80:	4f 92       	push	r4
    1b82:	5f 92       	push	r5
    1b84:	6f 92       	push	r6
    1b86:	7f 92       	push	r7
    1b88:	8f 92       	push	r8
    1b8a:	9f 92       	push	r9
    1b8c:	af 92       	push	r10
    1b8e:	bf 92       	push	r11
    1b90:	cf 92       	push	r12
    1b92:	df 92       	push	r13
    1b94:	ef 92       	push	r14
    1b96:	ff 92       	push	r15
    1b98:	0f 93       	push	r16
    1b9a:	1f 93       	push	r17
    1b9c:	2f 93       	push	r18
    1b9e:	3f 93       	push	r19
    1ba0:	4f 93       	push	r20
    1ba2:	5f 93       	push	r21
    1ba4:	6f 93       	push	r22
    1ba6:	7f 93       	push	r23
    1ba8:	8f 93       	push	r24
    1baa:	9f 93       	push	r25
    1bac:	af 93       	push	r26
    1bae:	bf 93       	push	r27
    1bb0:	cf 93       	push	r28
    1bb2:	df 93       	push	r29
    1bb4:	ef 93       	push	r30
    1bb6:	ff 93       	push	r31
    1bb8:	a0 91 77 04 	lds	r26, 0x0477
    1bbc:	b0 91 78 04 	lds	r27, 0x0478
    1bc0:	0d b6       	in	r0, 0x3d	; 61
    1bc2:	0d 92       	st	X+, r0
    1bc4:	0e b6       	in	r0, 0x3e	; 62
    1bc6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1bc8:	0e 94 37 1c 	call	0x386e	; 0x386e <xTaskIncrementTick>
    1bcc:	88 23       	and	r24, r24
    1bce:	11 f0       	breq	.+4      	; 0x1bd4 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    1bd0:	0e 94 20 1d 	call	0x3a40	; 0x3a40 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    1bd4:	a0 91 77 04 	lds	r26, 0x0477
    1bd8:	b0 91 78 04 	lds	r27, 0x0478
    1bdc:	cd 91       	ld	r28, X+
    1bde:	cd bf       	out	0x3d, r28	; 61
    1be0:	dd 91       	ld	r29, X+
    1be2:	de bf       	out	0x3e, r29	; 62
    1be4:	ff 91       	pop	r31
    1be6:	ef 91       	pop	r30
    1be8:	df 91       	pop	r29
    1bea:	cf 91       	pop	r28
    1bec:	bf 91       	pop	r27
    1bee:	af 91       	pop	r26
    1bf0:	9f 91       	pop	r25
    1bf2:	8f 91       	pop	r24
    1bf4:	7f 91       	pop	r23
    1bf6:	6f 91       	pop	r22
    1bf8:	5f 91       	pop	r21
    1bfa:	4f 91       	pop	r20
    1bfc:	3f 91       	pop	r19
    1bfe:	2f 91       	pop	r18
    1c00:	1f 91       	pop	r17
    1c02:	0f 91       	pop	r16
    1c04:	ff 90       	pop	r15
    1c06:	ef 90       	pop	r14
    1c08:	df 90       	pop	r13
    1c0a:	cf 90       	pop	r12
    1c0c:	bf 90       	pop	r11
    1c0e:	af 90       	pop	r10
    1c10:	9f 90       	pop	r9
    1c12:	8f 90       	pop	r8
    1c14:	7f 90       	pop	r7
    1c16:	6f 90       	pop	r6
    1c18:	5f 90       	pop	r5
    1c1a:	4f 90       	pop	r4
    1c1c:	3f 90       	pop	r3
    1c1e:	2f 90       	pop	r2
    1c20:	1f 90       	pop	r1
    1c22:	0f 90       	pop	r0
    1c24:	0f be       	out	0x3f, r0	; 63
    1c26:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c28:	08 95       	ret

00001c2a <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1c2a:	df 93       	push	r29
    1c2c:	cf 93       	push	r28
    1c2e:	00 d0       	rcall	.+0      	; 0x1c30 <prvSetupTimerInterrupt+0x6>
    1c30:	00 d0       	rcall	.+0      	; 0x1c32 <prvSetupTimerInterrupt+0x8>
    1c32:	00 d0       	rcall	.+0      	; 0x1c34 <prvSetupTimerInterrupt+0xa>
    1c34:	cd b7       	in	r28, 0x3d	; 61
    1c36:	de b7       	in	r29, 0x3e	; 62
uint8_t ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1c38:	80 e4       	ldi	r24, 0x40	; 64
    1c3a:	9f e1       	ldi	r25, 0x1F	; 31
    1c3c:	a0 e0       	ldi	r26, 0x00	; 0
    1c3e:	b0 e0       	ldi	r27, 0x00	; 0
    1c40:	8b 83       	std	Y+3, r24	; 0x03
    1c42:	9c 83       	std	Y+4, r25	; 0x04
    1c44:	ad 83       	std	Y+5, r26	; 0x05
    1c46:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1c48:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c4c:	ad 81       	ldd	r26, Y+5	; 0x05
    1c4e:	be 81       	ldd	r27, Y+6	; 0x06
    1c50:	68 94       	set
    1c52:	15 f8       	bld	r1, 5
    1c54:	b6 95       	lsr	r27
    1c56:	a7 95       	ror	r26
    1c58:	97 95       	ror	r25
    1c5a:	87 95       	ror	r24
    1c5c:	16 94       	lsr	r1
    1c5e:	d1 f7       	brne	.-12     	; 0x1c54 <prvSetupTimerInterrupt+0x2a>
    1c60:	8b 83       	std	Y+3, r24	; 0x03
    1c62:	9c 83       	std	Y+4, r25	; 0x04
    1c64:	ad 83       	std	Y+5, r26	; 0x05
    1c66:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( uint32_t ) 1;
    1c68:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6a:	9c 81       	ldd	r25, Y+4	; 0x04
    1c6c:	ad 81       	ldd	r26, Y+5	; 0x05
    1c6e:	be 81       	ldd	r27, Y+6	; 0x06
    1c70:	01 97       	sbiw	r24, 0x01	; 1
    1c72:	a1 09       	sbc	r26, r1
    1c74:	b1 09       	sbc	r27, r1
    1c76:	8b 83       	std	Y+3, r24	; 0x03
    1c78:	9c 83       	std	Y+4, r25	; 0x04
    1c7a:	ad 83       	std	Y+5, r26	; 0x05
    1c7c:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1c7e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c80:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1c82:	8b 81       	ldd	r24, Y+3	; 0x03
    1c84:	9c 81       	ldd	r25, Y+4	; 0x04
    1c86:	ad 81       	ldd	r26, Y+5	; 0x05
    1c88:	be 81       	ldd	r27, Y+6	; 0x06
    1c8a:	89 2f       	mov	r24, r25
    1c8c:	9a 2f       	mov	r25, r26
    1c8e:	ab 2f       	mov	r26, r27
    1c90:	bb 27       	eor	r27, r27
    1c92:	8b 83       	std	Y+3, r24	; 0x03
    1c94:	9c 83       	std	Y+4, r25	; 0x04
    1c96:	ad 83       	std	Y+5, r26	; 0x05
    1c98:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
    1c9a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c9c:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1c9e:	eb e4       	ldi	r30, 0x4B	; 75
    1ca0:	f0 e0       	ldi	r31, 0x00	; 0
    1ca2:	8a 81       	ldd	r24, Y+2	; 0x02
    1ca4:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1ca6:	ea e4       	ldi	r30, 0x4A	; 74
    1ca8:	f0 e0       	ldi	r31, 0x00	; 0
    1caa:	89 81       	ldd	r24, Y+1	; 0x01
    1cac:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1cae:	8b e0       	ldi	r24, 0x0B	; 11
    1cb0:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1cb2:	ee e4       	ldi	r30, 0x4E	; 78
    1cb4:	f0 e0       	ldi	r31, 0x00	; 0
    1cb6:	89 81       	ldd	r24, Y+1	; 0x01
    1cb8:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1cba:	e9 e5       	ldi	r30, 0x59	; 89
    1cbc:	f0 e0       	ldi	r31, 0x00	; 0
    1cbe:	80 81       	ld	r24, Z
    1cc0:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1cc2:	89 81       	ldd	r24, Y+1	; 0x01
    1cc4:	80 61       	ori	r24, 0x10	; 16
    1cc6:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1cc8:	e9 e5       	ldi	r30, 0x59	; 89
    1cca:	f0 e0       	ldi	r31, 0x00	; 0
    1ccc:	89 81       	ldd	r24, Y+1	; 0x01
    1cce:	80 83       	st	Z, r24
}
    1cd0:	26 96       	adiw	r28, 0x06	; 6
    1cd2:	0f b6       	in	r0, 0x3f	; 63
    1cd4:	f8 94       	cli
    1cd6:	de bf       	out	0x3e, r29	; 62
    1cd8:	0f be       	out	0x3f, r0	; 63
    1cda:	cd bf       	out	0x3d, r28	; 61
    1cdc:	cf 91       	pop	r28
    1cde:	df 91       	pop	r29
    1ce0:	08 95       	ret

00001ce2 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    1ce2:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1ce6:	18 95       	reti

00001ce8 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
    1ce8:	df 93       	push	r29
    1cea:	cf 93       	push	r28
    1cec:	00 d0       	rcall	.+0      	; 0x1cee <xQueueGenericReset+0x6>
    1cee:	00 d0       	rcall	.+0      	; 0x1cf0 <xQueueGenericReset+0x8>
    1cf0:	0f 92       	push	r0
    1cf2:	cd b7       	in	r28, 0x3d	; 61
    1cf4:	de b7       	in	r29, 0x3e	; 62
    1cf6:	9c 83       	std	Y+4, r25	; 0x04
    1cf8:	8b 83       	std	Y+3, r24	; 0x03
    1cfa:	6d 83       	std	Y+5, r22	; 0x05
Queue_t * const pxQueue = xQueue;
    1cfc:	8b 81       	ldd	r24, Y+3	; 0x03
    1cfe:	9c 81       	ldd	r25, Y+4	; 0x04
    1d00:	9a 83       	std	Y+2, r25	; 0x02
    1d02:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    1d04:	0f b6       	in	r0, 0x3f	; 63
    1d06:	f8 94       	cli
    1d08:	0f 92       	push	r0
	{
		pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1d0a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d0c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d0e:	40 81       	ld	r20, Z
    1d10:	51 81       	ldd	r21, Z+1	; 0x01
    1d12:	e9 81       	ldd	r30, Y+1	; 0x01
    1d14:	fa 81       	ldd	r31, Y+2	; 0x02
    1d16:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d18:	28 2f       	mov	r18, r24
    1d1a:	30 e0       	ldi	r19, 0x00	; 0
    1d1c:	e9 81       	ldd	r30, Y+1	; 0x01
    1d1e:	fa 81       	ldd	r31, Y+2	; 0x02
    1d20:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d22:	88 2f       	mov	r24, r24
    1d24:	90 e0       	ldi	r25, 0x00	; 0
    1d26:	bc 01       	movw	r22, r24
    1d28:	26 9f       	mul	r18, r22
    1d2a:	c0 01       	movw	r24, r0
    1d2c:	27 9f       	mul	r18, r23
    1d2e:	90 0d       	add	r25, r0
    1d30:	36 9f       	mul	r19, r22
    1d32:	90 0d       	add	r25, r0
    1d34:	11 24       	eor	r1, r1
    1d36:	84 0f       	add	r24, r20
    1d38:	95 1f       	adc	r25, r21
    1d3a:	e9 81       	ldd	r30, Y+1	; 0x01
    1d3c:	fa 81       	ldd	r31, Y+2	; 0x02
    1d3e:	95 83       	std	Z+5, r25	; 0x05
    1d40:	84 83       	std	Z+4, r24	; 0x04
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    1d42:	e9 81       	ldd	r30, Y+1	; 0x01
    1d44:	fa 81       	ldd	r31, Y+2	; 0x02
    1d46:	12 8e       	std	Z+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    1d48:	e9 81       	ldd	r30, Y+1	; 0x01
    1d4a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d4c:	80 81       	ld	r24, Z
    1d4e:	91 81       	ldd	r25, Z+1	; 0x01
    1d50:	e9 81       	ldd	r30, Y+1	; 0x01
    1d52:	fa 81       	ldd	r31, Y+2	; 0x02
    1d54:	93 83       	std	Z+3, r25	; 0x03
    1d56:	82 83       	std	Z+2, r24	; 0x02
		pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1d58:	e9 81       	ldd	r30, Y+1	; 0x01
    1d5a:	fa 81       	ldd	r31, Y+2	; 0x02
    1d5c:	40 81       	ld	r20, Z
    1d5e:	51 81       	ldd	r21, Z+1	; 0x01
    1d60:	e9 81       	ldd	r30, Y+1	; 0x01
    1d62:	fa 81       	ldd	r31, Y+2	; 0x02
    1d64:	83 8d       	ldd	r24, Z+27	; 0x1b
    1d66:	88 2f       	mov	r24, r24
    1d68:	90 e0       	ldi	r25, 0x00	; 0
    1d6a:	9c 01       	movw	r18, r24
    1d6c:	21 50       	subi	r18, 0x01	; 1
    1d6e:	30 40       	sbci	r19, 0x00	; 0
    1d70:	e9 81       	ldd	r30, Y+1	; 0x01
    1d72:	fa 81       	ldd	r31, Y+2	; 0x02
    1d74:	84 8d       	ldd	r24, Z+28	; 0x1c
    1d76:	88 2f       	mov	r24, r24
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	bc 01       	movw	r22, r24
    1d7c:	26 9f       	mul	r18, r22
    1d7e:	c0 01       	movw	r24, r0
    1d80:	27 9f       	mul	r18, r23
    1d82:	90 0d       	add	r25, r0
    1d84:	36 9f       	mul	r19, r22
    1d86:	90 0d       	add	r25, r0
    1d88:	11 24       	eor	r1, r1
    1d8a:	84 0f       	add	r24, r20
    1d8c:	95 1f       	adc	r25, r21
    1d8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1d90:	fa 81       	ldd	r31, Y+2	; 0x02
    1d92:	97 83       	std	Z+7, r25	; 0x07
    1d94:	86 83       	std	Z+6, r24	; 0x06
		pxQueue->cRxLock = queueUNLOCKED;
    1d96:	e9 81       	ldd	r30, Y+1	; 0x01
    1d98:	fa 81       	ldd	r31, Y+2	; 0x02
    1d9a:	8f ef       	ldi	r24, 0xFF	; 255
    1d9c:	85 8f       	std	Z+29, r24	; 0x1d
		pxQueue->cTxLock = queueUNLOCKED;
    1d9e:	e9 81       	ldd	r30, Y+1	; 0x01
    1da0:	fa 81       	ldd	r31, Y+2	; 0x02
    1da2:	8f ef       	ldi	r24, 0xFF	; 255
    1da4:	86 8f       	std	Z+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1da6:	8d 81       	ldd	r24, Y+5	; 0x05
    1da8:	88 23       	and	r24, r24
    1daa:	79 f4       	brne	.+30     	; 0x1dca <xQueueGenericReset+0xe2>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1dac:	e9 81       	ldd	r30, Y+1	; 0x01
    1dae:	fa 81       	ldd	r31, Y+2	; 0x02
    1db0:	80 85       	ldd	r24, Z+8	; 0x08
    1db2:	88 23       	and	r24, r24
    1db4:	a1 f0       	breq	.+40     	; 0x1dde <xQueueGenericReset+0xf6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1db6:	89 81       	ldd	r24, Y+1	; 0x01
    1db8:	9a 81       	ldd	r25, Y+2	; 0x02
    1dba:	08 96       	adiw	r24, 0x08	; 8
    1dbc:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <xTaskRemoveFromEventList>
    1dc0:	88 23       	and	r24, r24
    1dc2:	69 f0       	breq	.+26     	; 0x1dde <xQueueGenericReset+0xf6>
				{
					queueYIELD_IF_USING_PREEMPTION();
    1dc4:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
    1dc8:	0a c0       	rjmp	.+20     	; 0x1dde <xQueueGenericReset+0xf6>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    1dca:	89 81       	ldd	r24, Y+1	; 0x01
    1dcc:	9a 81       	ldd	r25, Y+2	; 0x02
    1dce:	08 96       	adiw	r24, 0x08	; 8
    1dd0:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1dd4:	89 81       	ldd	r24, Y+1	; 0x01
    1dd6:	9a 81       	ldd	r25, Y+2	; 0x02
    1dd8:	41 96       	adiw	r24, 0x11	; 17
    1dda:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    1dde:	0f 90       	pop	r0
    1de0:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
    1de2:	81 e0       	ldi	r24, 0x01	; 1
}
    1de4:	0f 90       	pop	r0
    1de6:	0f 90       	pop	r0
    1de8:	0f 90       	pop	r0
    1dea:	0f 90       	pop	r0
    1dec:	0f 90       	pop	r0
    1dee:	cf 91       	pop	r28
    1df0:	df 91       	pop	r29
    1df2:	08 95       	ret

00001df4 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
	{
    1df4:	0f 93       	push	r16
    1df6:	1f 93       	push	r17
    1df8:	df 93       	push	r29
    1dfa:	cf 93       	push	r28
    1dfc:	cd b7       	in	r28, 0x3d	; 61
    1dfe:	de b7       	in	r29, 0x3e	; 62
    1e00:	29 97       	sbiw	r28, 0x09	; 9
    1e02:	0f b6       	in	r0, 0x3f	; 63
    1e04:	f8 94       	cli
    1e06:	de bf       	out	0x3e, r29	; 62
    1e08:	0f be       	out	0x3f, r0	; 63
    1e0a:	cd bf       	out	0x3d, r28	; 61
    1e0c:	8f 83       	std	Y+7, r24	; 0x07
    1e0e:	68 87       	std	Y+8, r22	; 0x08
    1e10:	49 87       	std	Y+9, r20	; 0x09
		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

		/* Allocate enough space to hold the maximum number of items that
		can be in the queue at any time.  It is valid for uxItemSize to be
		zero in the case the queue is used as a semaphore. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1e12:	8f 81       	ldd	r24, Y+7	; 0x07
    1e14:	28 2f       	mov	r18, r24
    1e16:	30 e0       	ldi	r19, 0x00	; 0
    1e18:	88 85       	ldd	r24, Y+8	; 0x08
    1e1a:	88 2f       	mov	r24, r24
    1e1c:	90 e0       	ldi	r25, 0x00	; 0
    1e1e:	ac 01       	movw	r20, r24
    1e20:	24 9f       	mul	r18, r20
    1e22:	c0 01       	movw	r24, r0
    1e24:	25 9f       	mul	r18, r21
    1e26:	90 0d       	add	r25, r0
    1e28:	34 9f       	mul	r19, r20
    1e2a:	90 0d       	add	r25, r0
    1e2c:	11 24       	eor	r1, r1
    1e2e:	9c 83       	std	Y+4, r25	; 0x04
    1e30:	8b 83       	std	Y+3, r24	; 0x03
		alignment requirements of the Queue_t structure - which in this case
		is an int8_t *.  Therefore, whenever the stack alignment requirements
		are greater than or equal to the pointer to char requirements the cast
		is safe.  In other cases alignment requirements are not strict (one or
		two bytes). */
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    1e32:	8b 81       	ldd	r24, Y+3	; 0x03
    1e34:	9c 81       	ldd	r25, Y+4	; 0x04
    1e36:	4f 96       	adiw	r24, 0x1f	; 31
    1e38:	0e 94 ee 09 	call	0x13dc	; 0x13dc <pvPortMalloc>
    1e3c:	9e 83       	std	Y+6, r25	; 0x06
    1e3e:	8d 83       	std	Y+5, r24	; 0x05

		if( pxNewQueue != NULL )
    1e40:	8d 81       	ldd	r24, Y+5	; 0x05
    1e42:	9e 81       	ldd	r25, Y+6	; 0x06
    1e44:	00 97       	sbiw	r24, 0x00	; 0
    1e46:	a1 f0       	breq	.+40     	; 0x1e70 <xQueueGenericCreate+0x7c>
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pucQueueStorage = ( uint8_t * ) pxNewQueue;
    1e48:	8d 81       	ldd	r24, Y+5	; 0x05
    1e4a:	9e 81       	ldd	r25, Y+6	; 0x06
    1e4c:	9a 83       	std	Y+2, r25	; 0x02
    1e4e:	89 83       	std	Y+1, r24	; 0x01
			pucQueueStorage += sizeof( Queue_t ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    1e50:	89 81       	ldd	r24, Y+1	; 0x01
    1e52:	9a 81       	ldd	r25, Y+2	; 0x02
    1e54:	4f 96       	adiw	r24, 0x1f	; 31
    1e56:	9a 83       	std	Y+2, r25	; 0x02
    1e58:	89 83       	std	Y+1, r24	; 0x01
				deleted. */
				pxNewQueue->ucStaticallyAllocated = pdFALSE;
			}
			#endif /* configSUPPORT_STATIC_ALLOCATION */

			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
    1e5a:	29 81       	ldd	r18, Y+1	; 0x01
    1e5c:	3a 81       	ldd	r19, Y+2	; 0x02
    1e5e:	ed 81       	ldd	r30, Y+5	; 0x05
    1e60:	fe 81       	ldd	r31, Y+6	; 0x06
    1e62:	8f 81       	ldd	r24, Y+7	; 0x07
    1e64:	68 85       	ldd	r22, Y+8	; 0x08
    1e66:	a9 01       	movw	r20, r18
    1e68:	29 85       	ldd	r18, Y+9	; 0x09
    1e6a:	8f 01       	movw	r16, r30
    1e6c:	0e 94 45 0f 	call	0x1e8a	; 0x1e8a <prvInitialiseNewQueue>
		{
			traceQUEUE_CREATE_FAILED( ucQueueType );
			mtCOVERAGE_TEST_MARKER();
		}

		return pxNewQueue;
    1e70:	8d 81       	ldd	r24, Y+5	; 0x05
    1e72:	9e 81       	ldd	r25, Y+6	; 0x06
	}
    1e74:	29 96       	adiw	r28, 0x09	; 9
    1e76:	0f b6       	in	r0, 0x3f	; 63
    1e78:	f8 94       	cli
    1e7a:	de bf       	out	0x3e, r29	; 62
    1e7c:	0f be       	out	0x3f, r0	; 63
    1e7e:	cd bf       	out	0x3d, r28	; 61
    1e80:	cf 91       	pop	r28
    1e82:	df 91       	pop	r29
    1e84:	1f 91       	pop	r17
    1e86:	0f 91       	pop	r16
    1e88:	08 95       	ret

00001e8a <prvInitialiseNewQueue>:

#endif /* configSUPPORT_STATIC_ALLOCATION */
/*-----------------------------------------------------------*/

static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
{
    1e8a:	0f 93       	push	r16
    1e8c:	1f 93       	push	r17
    1e8e:	df 93       	push	r29
    1e90:	cf 93       	push	r28
    1e92:	cd b7       	in	r28, 0x3d	; 61
    1e94:	de b7       	in	r29, 0x3e	; 62
    1e96:	27 97       	sbiw	r28, 0x07	; 7
    1e98:	0f b6       	in	r0, 0x3f	; 63
    1e9a:	f8 94       	cli
    1e9c:	de bf       	out	0x3e, r29	; 62
    1e9e:	0f be       	out	0x3f, r0	; 63
    1ea0:	cd bf       	out	0x3d, r28	; 61
    1ea2:	89 83       	std	Y+1, r24	; 0x01
    1ea4:	6a 83       	std	Y+2, r22	; 0x02
    1ea6:	5c 83       	std	Y+4, r21	; 0x04
    1ea8:	4b 83       	std	Y+3, r20	; 0x03
    1eaa:	2d 83       	std	Y+5, r18	; 0x05
    1eac:	1f 83       	std	Y+7, r17	; 0x07
    1eae:	0e 83       	std	Y+6, r16	; 0x06
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	if( uxItemSize == ( UBaseType_t ) 0 )
    1eb0:	8a 81       	ldd	r24, Y+2	; 0x02
    1eb2:	88 23       	and	r24, r24
    1eb4:	39 f4       	brne	.+14     	; 0x1ec4 <prvInitialiseNewQueue+0x3a>
	{
		/* No RAM was allocated for the queue storage area, but PC head cannot
		be set to NULL because NULL is used as a key to say the queue is used as
		a mutex.  Therefore just set pcHead to point to the queue as a benign
		value that is known to be within the memory map. */
		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    1eb6:	8e 81       	ldd	r24, Y+6	; 0x06
    1eb8:	9f 81       	ldd	r25, Y+7	; 0x07
    1eba:	ee 81       	ldd	r30, Y+6	; 0x06
    1ebc:	ff 81       	ldd	r31, Y+7	; 0x07
    1ebe:	91 83       	std	Z+1, r25	; 0x01
    1ec0:	80 83       	st	Z, r24
    1ec2:	06 c0       	rjmp	.+12     	; 0x1ed0 <prvInitialiseNewQueue+0x46>
	}
	else
	{
		/* Set the head to the start of the queue storage area. */
		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    1ec4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ec6:	9c 81       	ldd	r25, Y+4	; 0x04
    1ec8:	ee 81       	ldd	r30, Y+6	; 0x06
    1eca:	ff 81       	ldd	r31, Y+7	; 0x07
    1ecc:	91 83       	std	Z+1, r25	; 0x01
    1ece:	80 83       	st	Z, r24
	}

	/* Initialise the queue members as described where the queue type is
	defined. */
	pxNewQueue->uxLength = uxQueueLength;
    1ed0:	ee 81       	ldd	r30, Y+6	; 0x06
    1ed2:	ff 81       	ldd	r31, Y+7	; 0x07
    1ed4:	89 81       	ldd	r24, Y+1	; 0x01
    1ed6:	83 8f       	std	Z+27, r24	; 0x1b
	pxNewQueue->uxItemSize = uxItemSize;
    1ed8:	ee 81       	ldd	r30, Y+6	; 0x06
    1eda:	ff 81       	ldd	r31, Y+7	; 0x07
    1edc:	8a 81       	ldd	r24, Y+2	; 0x02
    1ede:	84 8f       	std	Z+28, r24	; 0x1c
	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    1ee0:	8e 81       	ldd	r24, Y+6	; 0x06
    1ee2:	9f 81       	ldd	r25, Y+7	; 0x07
    1ee4:	61 e0       	ldi	r22, 0x01	; 1
    1ee6:	0e 94 74 0e 	call	0x1ce8	; 0x1ce8 <xQueueGenericReset>
		pxNewQueue->pxQueueSetContainer = NULL;
	}
	#endif /* configUSE_QUEUE_SETS */

	traceQUEUE_CREATE( pxNewQueue );
}
    1eea:	27 96       	adiw	r28, 0x07	; 7
    1eec:	0f b6       	in	r0, 0x3f	; 63
    1eee:	f8 94       	cli
    1ef0:	de bf       	out	0x3e, r29	; 62
    1ef2:	0f be       	out	0x3f, r0	; 63
    1ef4:	cd bf       	out	0x3d, r28	; 61
    1ef6:	cf 91       	pop	r28
    1ef8:	df 91       	pop	r29
    1efa:	1f 91       	pop	r17
    1efc:	0f 91       	pop	r16
    1efe:	08 95       	ret

00001f00 <xQueueGenericSend>:

#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
    1f00:	df 93       	push	r29
    1f02:	cf 93       	push	r28
    1f04:	cd b7       	in	r28, 0x3d	; 61
    1f06:	de b7       	in	r29, 0x3e	; 62
    1f08:	2f 97       	sbiw	r28, 0x0f	; 15
    1f0a:	0f b6       	in	r0, 0x3f	; 63
    1f0c:	f8 94       	cli
    1f0e:	de bf       	out	0x3e, r29	; 62
    1f10:	0f be       	out	0x3f, r0	; 63
    1f12:	cd bf       	out	0x3d, r28	; 61
    1f14:	99 87       	std	Y+9, r25	; 0x09
    1f16:	88 87       	std	Y+8, r24	; 0x08
    1f18:	7b 87       	std	Y+11, r23	; 0x0b
    1f1a:	6a 87       	std	Y+10, r22	; 0x0a
    1f1c:	5d 87       	std	Y+13, r21	; 0x0d
    1f1e:	4c 87       	std	Y+12, r20	; 0x0c
    1f20:	2e 87       	std	Y+14, r18	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
    1f22:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    1f24:	88 85       	ldd	r24, Y+8	; 0x08
    1f26:	99 85       	ldd	r25, Y+9	; 0x09
    1f28:	9a 83       	std	Y+2, r25	; 0x02
    1f2a:	89 83       	std	Y+1, r24	; 0x01
	/*lint -save -e904 This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1f2c:	0f b6       	in	r0, 0x3f	; 63
    1f2e:	f8 94       	cli
    1f30:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    1f32:	e9 81       	ldd	r30, Y+1	; 0x01
    1f34:	fa 81       	ldd	r31, Y+2	; 0x02
    1f36:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f38:	e9 81       	ldd	r30, Y+1	; 0x01
    1f3a:	fa 81       	ldd	r31, Y+2	; 0x02
    1f3c:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f3e:	98 17       	cp	r25, r24
    1f40:	18 f0       	brcs	.+6      	; 0x1f48 <xQueueGenericSend+0x48>
    1f42:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f44:	82 30       	cpi	r24, 0x02	; 2
    1f46:	11 f5       	brne	.+68     	; 0x1f8c <xQueueGenericSend+0x8c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1f48:	89 81       	ldd	r24, Y+1	; 0x01
    1f4a:	9a 81       	ldd	r25, Y+2	; 0x02
    1f4c:	2a 85       	ldd	r18, Y+10	; 0x0a
    1f4e:	3b 85       	ldd	r19, Y+11	; 0x0b
    1f50:	b9 01       	movw	r22, r18
    1f52:	4e 85       	ldd	r20, Y+14	; 0x0e
    1f54:	0e 94 d6 13 	call	0x27ac	; 0x27ac <prvCopyDataToQueue>
    1f58:	8b 83       	std	Y+3, r24	; 0x03

					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f5a:	e9 81       	ldd	r30, Y+1	; 0x01
    1f5c:	fa 81       	ldd	r31, Y+2	; 0x02
    1f5e:	81 89       	ldd	r24, Z+17	; 0x11
    1f60:	88 23       	and	r24, r24
    1f62:	51 f0       	breq	.+20     	; 0x1f78 <xQueueGenericSend+0x78>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f64:	89 81       	ldd	r24, Y+1	; 0x01
    1f66:	9a 81       	ldd	r25, Y+2	; 0x02
    1f68:	41 96       	adiw	r24, 0x11	; 17
    1f6a:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <xTaskRemoveFromEventList>
    1f6e:	88 23       	and	r24, r24
    1f70:	41 f0       	breq	.+16     	; 0x1f82 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
    1f72:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
    1f76:	05 c0       	rjmp	.+10     	; 0x1f82 <xQueueGenericSend+0x82>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
    1f78:	8b 81       	ldd	r24, Y+3	; 0x03
    1f7a:	88 23       	and	r24, r24
    1f7c:	11 f0       	breq	.+4      	; 0x1f82 <xQueueGenericSend+0x82>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
    1f7e:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1f82:	0f 90       	pop	r0
    1f84:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f86:	81 e0       	ldi	r24, 0x01	; 1
    1f88:	8f 87       	std	Y+15, r24	; 0x0f
    1f8a:	5c c0       	rjmp	.+184    	; 0x2044 <xQueueGenericSend+0x144>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1f8c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f8e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f90:	00 97       	sbiw	r24, 0x00	; 0
    1f92:	21 f4       	brne	.+8      	; 0x1f9c <xQueueGenericSend+0x9c>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f94:	0f 90       	pop	r0
    1f96:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1f98:	1f 86       	std	Y+15, r1	; 0x0f
    1f9a:	54 c0       	rjmp	.+168    	; 0x2044 <xQueueGenericSend+0x144>
				}
				else if( xEntryTimeSet == pdFALSE )
    1f9c:	8c 81       	ldd	r24, Y+4	; 0x04
    1f9e:	88 23       	and	r24, r24
    1fa0:	31 f4       	brne	.+12     	; 0x1fae <xQueueGenericSend+0xae>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    1fa2:	ce 01       	movw	r24, r28
    1fa4:	05 96       	adiw	r24, 0x05	; 5
    1fa6:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1faa:	81 e0       	ldi	r24, 0x01	; 1
    1fac:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1fae:	0f 90       	pop	r0
    1fb0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1fb2:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1fb6:	0f b6       	in	r0, 0x3f	; 63
    1fb8:	f8 94       	cli
    1fba:	0f 92       	push	r0
    1fbc:	e9 81       	ldd	r30, Y+1	; 0x01
    1fbe:	fa 81       	ldd	r31, Y+2	; 0x02
    1fc0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fc2:	8f 3f       	cpi	r24, 0xFF	; 255
    1fc4:	19 f4       	brne	.+6      	; 0x1fcc <xQueueGenericSend+0xcc>
    1fc6:	e9 81       	ldd	r30, Y+1	; 0x01
    1fc8:	fa 81       	ldd	r31, Y+2	; 0x02
    1fca:	15 8e       	std	Z+29, r1	; 0x1d
    1fcc:	e9 81       	ldd	r30, Y+1	; 0x01
    1fce:	fa 81       	ldd	r31, Y+2	; 0x02
    1fd0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fd2:	8f 3f       	cpi	r24, 0xFF	; 255
    1fd4:	19 f4       	brne	.+6      	; 0x1fdc <xQueueGenericSend+0xdc>
    1fd6:	e9 81       	ldd	r30, Y+1	; 0x01
    1fd8:	fa 81       	ldd	r31, Y+2	; 0x02
    1fda:	16 8e       	std	Z+30, r1	; 0x1e
    1fdc:	0f 90       	pop	r0
    1fde:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1fe0:	ce 01       	movw	r24, r28
    1fe2:	05 96       	adiw	r24, 0x05	; 5
    1fe4:	9e 01       	movw	r18, r28
    1fe6:	24 5f       	subi	r18, 0xF4	; 244
    1fe8:	3f 4f       	sbci	r19, 0xFF	; 255
    1fea:	b9 01       	movw	r22, r18
    1fec:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskCheckForTimeOut>
    1ff0:	88 23       	and	r24, r24
    1ff2:	09 f5       	brne	.+66     	; 0x2036 <xQueueGenericSend+0x136>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1ff4:	89 81       	ldd	r24, Y+1	; 0x01
    1ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    1ff8:	0e 94 52 15 	call	0x2aa4	; 0x2aa4 <prvIsQueueFull>
    1ffc:	88 23       	and	r24, r24
    1ffe:	a1 f0       	breq	.+40     	; 0x2028 <xQueueGenericSend+0x128>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    2000:	89 81       	ldd	r24, Y+1	; 0x01
    2002:	9a 81       	ldd	r25, Y+2	; 0x02
    2004:	08 96       	adiw	r24, 0x08	; 8
    2006:	2c 85       	ldd	r18, Y+12	; 0x0c
    2008:	3d 85       	ldd	r19, Y+13	; 0x0d
    200a:	b9 01       	movw	r22, r18
    200c:	0e 94 8d 1d 	call	0x3b1a	; 0x3b1a <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible that interrupts occurring now
				remove this task from the event list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    2010:	89 81       	ldd	r24, Y+1	; 0x01
    2012:	9a 81       	ldd	r25, Y+2	; 0x02
    2014:	0e 94 c3 14 	call	0x2986	; 0x2986 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    2018:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
    201c:	88 23       	and	r24, r24
    201e:	09 f0       	breq	.+2      	; 0x2022 <xQueueGenericSend+0x122>
    2020:	85 cf       	rjmp	.-246    	; 0x1f2c <xQueueGenericSend+0x2c>
				{
					portYIELD_WITHIN_API();
    2022:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
    2026:	82 cf       	rjmp	.-252    	; 0x1f2c <xQueueGenericSend+0x2c>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2028:	89 81       	ldd	r24, Y+1	; 0x01
    202a:	9a 81       	ldd	r25, Y+2	; 0x02
    202c:	0e 94 c3 14 	call	0x2986	; 0x2986 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2030:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
    2034:	7b cf       	rjmp	.-266    	; 0x1f2c <xQueueGenericSend+0x2c>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    2036:	89 81       	ldd	r24, Y+1	; 0x01
    2038:	9a 81       	ldd	r25, Y+2	; 0x02
    203a:	0e 94 c3 14 	call	0x2986	; 0x2986 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    203e:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>

			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    2042:	1f 86       	std	Y+15, r1	; 0x0f
    2044:	8f 85       	ldd	r24, Y+15	; 0x0f
		}
	} /*lint -restore */
}
    2046:	2f 96       	adiw	r28, 0x0f	; 15
    2048:	0f b6       	in	r0, 0x3f	; 63
    204a:	f8 94       	cli
    204c:	de bf       	out	0x3e, r29	; 62
    204e:	0f be       	out	0x3f, r0	; 63
    2050:	cd bf       	out	0x3d, r28	; 61
    2052:	cf 91       	pop	r28
    2054:	df 91       	pop	r29
    2056:	08 95       	ret

00002058 <xQueueGenericSendFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
    2058:	df 93       	push	r29
    205a:	cf 93       	push	r28
    205c:	cd b7       	in	r28, 0x3d	; 61
    205e:	de b7       	in	r29, 0x3e	; 62
    2060:	2d 97       	sbiw	r28, 0x0d	; 13
    2062:	0f b6       	in	r0, 0x3f	; 63
    2064:	f8 94       	cli
    2066:	de bf       	out	0x3e, r29	; 62
    2068:	0f be       	out	0x3f, r0	; 63
    206a:	cd bf       	out	0x3d, r28	; 61
    206c:	98 87       	std	Y+8, r25	; 0x08
    206e:	8f 83       	std	Y+7, r24	; 0x07
    2070:	7a 87       	std	Y+10, r23	; 0x0a
    2072:	69 87       	std	Y+9, r22	; 0x09
    2074:	5c 87       	std	Y+12, r21	; 0x0c
    2076:	4b 87       	std	Y+11, r20	; 0x0b
    2078:	2d 87       	std	Y+13, r18	; 0x0d
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    207a:	8f 81       	ldd	r24, Y+7	; 0x07
    207c:	98 85       	ldd	r25, Y+8	; 0x08
    207e:	9c 83       	std	Y+4, r25	; 0x04
    2080:	8b 83       	std	Y+3, r24	; 0x03
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2082:	1d 82       	std	Y+5, r1	; 0x05
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    2084:	eb 81       	ldd	r30, Y+3	; 0x03
    2086:	fc 81       	ldd	r31, Y+4	; 0x04
    2088:	92 8d       	ldd	r25, Z+26	; 0x1a
    208a:	eb 81       	ldd	r30, Y+3	; 0x03
    208c:	fc 81       	ldd	r31, Y+4	; 0x04
    208e:	83 8d       	ldd	r24, Z+27	; 0x1b
    2090:	98 17       	cp	r25, r24
    2092:	18 f0       	brcs	.+6      	; 0x209a <xQueueGenericSendFromISR+0x42>
    2094:	8d 85       	ldd	r24, Y+13	; 0x0d
    2096:	82 30       	cpi	r24, 0x02	; 2
    2098:	81 f5       	brne	.+96     	; 0x20fa <xQueueGenericSendFromISR+0xa2>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    209a:	eb 81       	ldd	r30, Y+3	; 0x03
    209c:	fc 81       	ldd	r31, Y+4	; 0x04
    209e:	86 8d       	ldd	r24, Z+30	; 0x1e
    20a0:	8a 83       	std	Y+2, r24	; 0x02
			const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    20a2:	eb 81       	ldd	r30, Y+3	; 0x03
    20a4:	fc 81       	ldd	r31, Y+4	; 0x04
    20a6:	82 8d       	ldd	r24, Z+26	; 0x1a
    20a8:	89 83       	std	Y+1, r24	; 0x01
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    20aa:	8b 81       	ldd	r24, Y+3	; 0x03
    20ac:	9c 81       	ldd	r25, Y+4	; 0x04
    20ae:	29 85       	ldd	r18, Y+9	; 0x09
    20b0:	3a 85       	ldd	r19, Y+10	; 0x0a
    20b2:	b9 01       	movw	r22, r18
    20b4:	4d 85       	ldd	r20, Y+13	; 0x0d
    20b6:	0e 94 d6 13 	call	0x27ac	; 0x27ac <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    20ba:	8a 81       	ldd	r24, Y+2	; 0x02
    20bc:	8f 3f       	cpi	r24, 0xFF	; 255
    20be:	a9 f4       	brne	.+42     	; 0x20ea <xQueueGenericSendFromISR+0x92>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20c0:	eb 81       	ldd	r30, Y+3	; 0x03
    20c2:	fc 81       	ldd	r31, Y+4	; 0x04
    20c4:	81 89       	ldd	r24, Z+17	; 0x11
    20c6:	88 23       	and	r24, r24
    20c8:	a9 f0       	breq	.+42     	; 0x20f4 <xQueueGenericSendFromISR+0x9c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20ca:	8b 81       	ldd	r24, Y+3	; 0x03
    20cc:	9c 81       	ldd	r25, Y+4	; 0x04
    20ce:	41 96       	adiw	r24, 0x11	; 17
    20d0:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <xTaskRemoveFromEventList>
    20d4:	88 23       	and	r24, r24
    20d6:	71 f0       	breq	.+28     	; 0x20f4 <xQueueGenericSendFromISR+0x9c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    20d8:	8b 85       	ldd	r24, Y+11	; 0x0b
    20da:	9c 85       	ldd	r25, Y+12	; 0x0c
    20dc:	00 97       	sbiw	r24, 0x00	; 0
    20de:	51 f0       	breq	.+20     	; 0x20f4 <xQueueGenericSendFromISR+0x9c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    20e0:	eb 85       	ldd	r30, Y+11	; 0x0b
    20e2:	fc 85       	ldd	r31, Y+12	; 0x0c
    20e4:	81 e0       	ldi	r24, 0x01	; 1
    20e6:	80 83       	st	Z, r24
    20e8:	05 c0       	rjmp	.+10     	; 0x20f4 <xQueueGenericSendFromISR+0x9c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    20ea:	8a 81       	ldd	r24, Y+2	; 0x02
    20ec:	8f 5f       	subi	r24, 0xFF	; 255
    20ee:	eb 81       	ldd	r30, Y+3	; 0x03
    20f0:	fc 81       	ldd	r31, Y+4	; 0x04
    20f2:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	8e 83       	std	Y+6, r24	; 0x06
    20f8:	01 c0       	rjmp	.+2      	; 0x20fc <xQueueGenericSendFromISR+0xa4>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    20fa:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    20fc:	8e 81       	ldd	r24, Y+6	; 0x06
}
    20fe:	2d 96       	adiw	r28, 0x0d	; 13
    2100:	0f b6       	in	r0, 0x3f	; 63
    2102:	f8 94       	cli
    2104:	de bf       	out	0x3e, r29	; 62
    2106:	0f be       	out	0x3f, r0	; 63
    2108:	cd bf       	out	0x3d, r28	; 61
    210a:	cf 91       	pop	r28
    210c:	df 91       	pop	r29
    210e:	08 95       	ret

00002110 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2110:	df 93       	push	r29
    2112:	cf 93       	push	r28
    2114:	cd b7       	in	r28, 0x3d	; 61
    2116:	de b7       	in	r29, 0x3e	; 62
    2118:	2a 97       	sbiw	r28, 0x0a	; 10
    211a:	0f b6       	in	r0, 0x3f	; 63
    211c:	f8 94       	cli
    211e:	de bf       	out	0x3e, r29	; 62
    2120:	0f be       	out	0x3f, r0	; 63
    2122:	cd bf       	out	0x3d, r28	; 61
    2124:	98 87       	std	Y+8, r25	; 0x08
    2126:	8f 83       	std	Y+7, r24	; 0x07
    2128:	7a 87       	std	Y+10, r23	; 0x0a
    212a:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    212c:	8f 81       	ldd	r24, Y+7	; 0x07
    212e:	98 85       	ldd	r25, Y+8	; 0x08
    2130:	9c 83       	std	Y+4, r25	; 0x04
    2132:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2134:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    2136:	eb 81       	ldd	r30, Y+3	; 0x03
    2138:	fc 81       	ldd	r31, Y+4	; 0x04
    213a:	82 8d       	ldd	r24, Z+26	; 0x1a
    213c:	8a 83       	std	Y+2, r24	; 0x02

		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( uxMessagesWaiting < pxQueue->uxLength )
    213e:	eb 81       	ldd	r30, Y+3	; 0x03
    2140:	fc 81       	ldd	r31, Y+4	; 0x04
    2142:	93 8d       	ldd	r25, Z+27	; 0x1b
    2144:	8a 81       	ldd	r24, Y+2	; 0x02
    2146:	89 17       	cp	r24, r25
    2148:	48 f5       	brcc	.+82     	; 0x219c <xQueueGiveFromISR+0x8c>
		{
			const int8_t cTxLock = pxQueue->cTxLock;
    214a:	eb 81       	ldd	r30, Y+3	; 0x03
    214c:	fc 81       	ldd	r31, Y+4	; 0x04
    214e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2150:	89 83       	std	Y+1, r24	; 0x01
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    2152:	8a 81       	ldd	r24, Y+2	; 0x02
    2154:	8f 5f       	subi	r24, 0xFF	; 255
    2156:	eb 81       	ldd	r30, Y+3	; 0x03
    2158:	fc 81       	ldd	r31, Y+4	; 0x04
    215a:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( cTxLock == queueUNLOCKED )
    215c:	89 81       	ldd	r24, Y+1	; 0x01
    215e:	8f 3f       	cpi	r24, 0xFF	; 255
    2160:	a9 f4       	brne	.+42     	; 0x218c <xQueueGiveFromISR+0x7c>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2162:	eb 81       	ldd	r30, Y+3	; 0x03
    2164:	fc 81       	ldd	r31, Y+4	; 0x04
    2166:	81 89       	ldd	r24, Z+17	; 0x11
    2168:	88 23       	and	r24, r24
    216a:	a9 f0       	breq	.+42     	; 0x2196 <xQueueGiveFromISR+0x86>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    216c:	8b 81       	ldd	r24, Y+3	; 0x03
    216e:	9c 81       	ldd	r25, Y+4	; 0x04
    2170:	41 96       	adiw	r24, 0x11	; 17
    2172:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <xTaskRemoveFromEventList>
    2176:	88 23       	and	r24, r24
    2178:	71 f0       	breq	.+28     	; 0x2196 <xQueueGiveFromISR+0x86>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    217a:	89 85       	ldd	r24, Y+9	; 0x09
    217c:	9a 85       	ldd	r25, Y+10	; 0x0a
    217e:	00 97       	sbiw	r24, 0x00	; 0
    2180:	51 f0       	breq	.+20     	; 0x2196 <xQueueGiveFromISR+0x86>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2182:	e9 85       	ldd	r30, Y+9	; 0x09
    2184:	fa 85       	ldd	r31, Y+10	; 0x0a
    2186:	81 e0       	ldi	r24, 0x01	; 1
    2188:	80 83       	st	Z, r24
    218a:	05 c0       	rjmp	.+10     	; 0x2196 <xQueueGiveFromISR+0x86>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
    218c:	89 81       	ldd	r24, Y+1	; 0x01
    218e:	8f 5f       	subi	r24, 0xFF	; 255
    2190:	eb 81       	ldd	r30, Y+3	; 0x03
    2192:	fc 81       	ldd	r31, Y+4	; 0x04
    2194:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2196:	81 e0       	ldi	r24, 0x01	; 1
    2198:	8e 83       	std	Y+6, r24	; 0x06
    219a:	01 c0       	rjmp	.+2      	; 0x219e <xQueueGiveFromISR+0x8e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    219c:	1e 82       	std	Y+6, r1	; 0x06
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    219e:	8e 81       	ldd	r24, Y+6	; 0x06
}
    21a0:	2a 96       	adiw	r28, 0x0a	; 10
    21a2:	0f b6       	in	r0, 0x3f	; 63
    21a4:	f8 94       	cli
    21a6:	de bf       	out	0x3e, r29	; 62
    21a8:	0f be       	out	0x3f, r0	; 63
    21aa:	cd bf       	out	0x3d, r28	; 61
    21ac:	cf 91       	pop	r28
    21ae:	df 91       	pop	r29
    21b0:	08 95       	ret

000021b2 <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    21b2:	df 93       	push	r29
    21b4:	cf 93       	push	r28
    21b6:	cd b7       	in	r28, 0x3d	; 61
    21b8:	de b7       	in	r29, 0x3e	; 62
    21ba:	2e 97       	sbiw	r28, 0x0e	; 14
    21bc:	0f b6       	in	r0, 0x3f	; 63
    21be:	f8 94       	cli
    21c0:	de bf       	out	0x3e, r29	; 62
    21c2:	0f be       	out	0x3f, r0	; 63
    21c4:	cd bf       	out	0x3d, r28	; 61
    21c6:	99 87       	std	Y+9, r25	; 0x09
    21c8:	88 87       	std	Y+8, r24	; 0x08
    21ca:	7b 87       	std	Y+11, r23	; 0x0b
    21cc:	6a 87       	std	Y+10, r22	; 0x0a
    21ce:	5d 87       	std	Y+13, r21	; 0x0d
    21d0:	4c 87       	std	Y+12, r20	; 0x0c
BaseType_t xEntryTimeSet = pdFALSE;
    21d2:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    21d4:	88 85       	ldd	r24, Y+8	; 0x08
    21d6:	99 85       	ldd	r25, Y+9	; 0x09
    21d8:	9b 83       	std	Y+3, r25	; 0x03
    21da:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    21dc:	0f b6       	in	r0, 0x3f	; 63
    21de:	f8 94       	cli
    21e0:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    21e2:	ea 81       	ldd	r30, Y+2	; 0x02
    21e4:	fb 81       	ldd	r31, Y+3	; 0x03
    21e6:	82 8d       	ldd	r24, Z+26	; 0x1a
    21e8:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    21ea:	89 81       	ldd	r24, Y+1	; 0x01
    21ec:	88 23       	and	r24, r24
    21ee:	f9 f0       	breq	.+62     	; 0x222e <xQueueReceive+0x7c>
			{
				/* Data available, remove one item. */
				prvCopyDataFromQueue( pxQueue, pvBuffer );
    21f0:	8a 81       	ldd	r24, Y+2	; 0x02
    21f2:	9b 81       	ldd	r25, Y+3	; 0x03
    21f4:	2a 85       	ldd	r18, Y+10	; 0x0a
    21f6:	3b 85       	ldd	r19, Y+11	; 0x0b
    21f8:	b9 01       	movw	r22, r18
    21fa:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <prvCopyDataFromQueue>
				traceQUEUE_RECEIVE( pxQueue );
				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    21fe:	89 81       	ldd	r24, Y+1	; 0x01
    2200:	81 50       	subi	r24, 0x01	; 1
    2202:	ea 81       	ldd	r30, Y+2	; 0x02
    2204:	fb 81       	ldd	r31, Y+3	; 0x03
    2206:	82 8f       	std	Z+26, r24	; 0x1a

				/* There is now space in the queue, were any tasks waiting to
				post to the queue?  If so, unblock the highest priority waiting
				task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2208:	ea 81       	ldd	r30, Y+2	; 0x02
    220a:	fb 81       	ldd	r31, Y+3	; 0x03
    220c:	80 85       	ldd	r24, Z+8	; 0x08
    220e:	88 23       	and	r24, r24
    2210:	49 f0       	breq	.+18     	; 0x2224 <xQueueReceive+0x72>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2212:	8a 81       	ldd	r24, Y+2	; 0x02
    2214:	9b 81       	ldd	r25, Y+3	; 0x03
    2216:	08 96       	adiw	r24, 0x08	; 8
    2218:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <xTaskRemoveFromEventList>
    221c:	88 23       	and	r24, r24
    221e:	11 f0       	breq	.+4      	; 0x2224 <xQueueReceive+0x72>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2220:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2224:	0f 90       	pop	r0
    2226:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2228:	81 e0       	ldi	r24, 0x01	; 1
    222a:	8e 87       	std	Y+14, r24	; 0x0e
    222c:	63 c0       	rjmp	.+198    	; 0x22f4 <xQueueReceive+0x142>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    222e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2230:	9d 85       	ldd	r25, Y+13	; 0x0d
    2232:	00 97       	sbiw	r24, 0x00	; 0
    2234:	21 f4       	brne	.+8      	; 0x223e <xQueueReceive+0x8c>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2236:	0f 90       	pop	r0
    2238:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    223a:	1e 86       	std	Y+14, r1	; 0x0e
    223c:	5b c0       	rjmp	.+182    	; 0x22f4 <xQueueReceive+0x142>
				}
				else if( xEntryTimeSet == pdFALSE )
    223e:	8c 81       	ldd	r24, Y+4	; 0x04
    2240:	88 23       	and	r24, r24
    2242:	31 f4       	brne	.+12     	; 0x2250 <xQueueReceive+0x9e>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2244:	ce 01       	movw	r24, r28
    2246:	05 96       	adiw	r24, 0x05	; 5
    2248:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    224c:	81 e0       	ldi	r24, 0x01	; 1
    224e:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2250:	0f 90       	pop	r0
    2252:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2254:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2258:	0f b6       	in	r0, 0x3f	; 63
    225a:	f8 94       	cli
    225c:	0f 92       	push	r0
    225e:	ea 81       	ldd	r30, Y+2	; 0x02
    2260:	fb 81       	ldd	r31, Y+3	; 0x03
    2262:	85 8d       	ldd	r24, Z+29	; 0x1d
    2264:	8f 3f       	cpi	r24, 0xFF	; 255
    2266:	19 f4       	brne	.+6      	; 0x226e <xQueueReceive+0xbc>
    2268:	ea 81       	ldd	r30, Y+2	; 0x02
    226a:	fb 81       	ldd	r31, Y+3	; 0x03
    226c:	15 8e       	std	Z+29, r1	; 0x1d
    226e:	ea 81       	ldd	r30, Y+2	; 0x02
    2270:	fb 81       	ldd	r31, Y+3	; 0x03
    2272:	86 8d       	ldd	r24, Z+30	; 0x1e
    2274:	8f 3f       	cpi	r24, 0xFF	; 255
    2276:	19 f4       	brne	.+6      	; 0x227e <xQueueReceive+0xcc>
    2278:	ea 81       	ldd	r30, Y+2	; 0x02
    227a:	fb 81       	ldd	r31, Y+3	; 0x03
    227c:	16 8e       	std	Z+30, r1	; 0x1e
    227e:	0f 90       	pop	r0
    2280:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2282:	ce 01       	movw	r24, r28
    2284:	05 96       	adiw	r24, 0x05	; 5
    2286:	9e 01       	movw	r18, r28
    2288:	24 5f       	subi	r18, 0xF4	; 244
    228a:	3f 4f       	sbci	r19, 0xFF	; 255
    228c:	b9 01       	movw	r22, r18
    228e:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskCheckForTimeOut>
    2292:	88 23       	and	r24, r24
    2294:	09 f5       	brne	.+66     	; 0x22d8 <xQueueReceive+0x126>
		{
			/* The timeout has not expired.  If the queue is still empty place
			the task on the list of tasks waiting to receive from the queue. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2296:	8a 81       	ldd	r24, Y+2	; 0x02
    2298:	9b 81       	ldd	r25, Y+3	; 0x03
    229a:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <prvIsQueueEmpty>
    229e:	88 23       	and	r24, r24
    22a0:	a1 f0       	breq	.+40     	; 0x22ca <xQueueReceive+0x118>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    22a2:	8a 81       	ldd	r24, Y+2	; 0x02
    22a4:	9b 81       	ldd	r25, Y+3	; 0x03
    22a6:	41 96       	adiw	r24, 0x11	; 17
    22a8:	2c 85       	ldd	r18, Y+12	; 0x0c
    22aa:	3d 85       	ldd	r19, Y+13	; 0x0d
    22ac:	b9 01       	movw	r22, r18
    22ae:	0e 94 8d 1d 	call	0x3b1a	; 0x3b1a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    22b2:	8a 81       	ldd	r24, Y+2	; 0x02
    22b4:	9b 81       	ldd	r25, Y+3	; 0x03
    22b6:	0e 94 c3 14 	call	0x2986	; 0x2986 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    22ba:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
    22be:	88 23       	and	r24, r24
    22c0:	09 f0       	breq	.+2      	; 0x22c4 <xQueueReceive+0x112>
    22c2:	8c cf       	rjmp	.-232    	; 0x21dc <xQueueReceive+0x2a>
				{
					portYIELD_WITHIN_API();
    22c4:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
    22c8:	89 cf       	rjmp	.-238    	; 0x21dc <xQueueReceive+0x2a>
			}
			else
			{
				/* The queue contains data again.  Loop back to try and read the
				data. */
				prvUnlockQueue( pxQueue );
    22ca:	8a 81       	ldd	r24, Y+2	; 0x02
    22cc:	9b 81       	ldd	r25, Y+3	; 0x03
    22ce:	0e 94 c3 14 	call	0x2986	; 0x2986 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    22d2:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
    22d6:	82 cf       	rjmp	.-252    	; 0x21dc <xQueueReceive+0x2a>
		}
		else
		{
			/* Timed out.  If there is no data in the queue exit, otherwise loop
			back and attempt to read the data. */
			prvUnlockQueue( pxQueue );
    22d8:	8a 81       	ldd	r24, Y+2	; 0x02
    22da:	9b 81       	ldd	r25, Y+3	; 0x03
    22dc:	0e 94 c3 14 	call	0x2986	; 0x2986 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    22e0:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    22e4:	8a 81       	ldd	r24, Y+2	; 0x02
    22e6:	9b 81       	ldd	r25, Y+3	; 0x03
    22e8:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <prvIsQueueEmpty>
    22ec:	88 23       	and	r24, r24
    22ee:	09 f4       	brne	.+2      	; 0x22f2 <xQueueReceive+0x140>
    22f0:	75 cf       	rjmp	.-278    	; 0x21dc <xQueueReceive+0x2a>
			{
				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    22f2:	1e 86       	std	Y+14, r1	; 0x0e
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    22f4:	8e 85       	ldd	r24, Y+14	; 0x0e
}
    22f6:	2e 96       	adiw	r28, 0x0e	; 14
    22f8:	0f b6       	in	r0, 0x3f	; 63
    22fa:	f8 94       	cli
    22fc:	de bf       	out	0x3e, r29	; 62
    22fe:	0f be       	out	0x3f, r0	; 63
    2300:	cd bf       	out	0x3d, r28	; 61
    2302:	cf 91       	pop	r28
    2304:	df 91       	pop	r29
    2306:	08 95       	ret

00002308 <xQueueSemaphoreTake>:
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
{
    2308:	df 93       	push	r29
    230a:	cf 93       	push	r28
    230c:	cd b7       	in	r28, 0x3d	; 61
    230e:	de b7       	in	r29, 0x3e	; 62
    2310:	2c 97       	sbiw	r28, 0x0c	; 12
    2312:	0f b6       	in	r0, 0x3f	; 63
    2314:	f8 94       	cli
    2316:	de bf       	out	0x3e, r29	; 62
    2318:	0f be       	out	0x3f, r0	; 63
    231a:	cd bf       	out	0x3d, r28	; 61
    231c:	99 87       	std	Y+9, r25	; 0x09
    231e:	88 87       	std	Y+8, r24	; 0x08
    2320:	7b 87       	std	Y+11, r23	; 0x0b
    2322:	6a 87       	std	Y+10, r22	; 0x0a
BaseType_t xEntryTimeSet = pdFALSE;
    2324:	1c 82       	std	Y+4, r1	; 0x04
TimeOut_t xTimeOut;
Queue_t * const pxQueue = xQueue;
    2326:	88 85       	ldd	r24, Y+8	; 0x08
    2328:	99 85       	ldd	r25, Y+9	; 0x09
    232a:	9b 83       	std	Y+3, r25	; 0x03
    232c:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904 This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    232e:	0f b6       	in	r0, 0x3f	; 63
    2330:	f8 94       	cli
    2332:	0f 92       	push	r0
		{
			/* Semaphores are queues with an item size of 0, and where the
			number of messages in the queue is the semaphore's count value. */
			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    2334:	ea 81       	ldd	r30, Y+2	; 0x02
    2336:	fb 81       	ldd	r31, Y+3	; 0x03
    2338:	82 8d       	ldd	r24, Z+26	; 0x1a
    233a:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    233c:	89 81       	ldd	r24, Y+1	; 0x01
    233e:	88 23       	and	r24, r24
    2340:	c1 f0       	breq	.+48     	; 0x2372 <xQueueSemaphoreTake+0x6a>
			{
				traceQUEUE_RECEIVE( pxQueue );

				/* Semaphores are queues with a data size of zero and where the
				messages waiting is the semaphore's count.  Reduce the count. */
				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    2342:	89 81       	ldd	r24, Y+1	; 0x01
    2344:	81 50       	subi	r24, 0x01	; 1
    2346:	ea 81       	ldd	r30, Y+2	; 0x02
    2348:	fb 81       	ldd	r31, Y+3	; 0x03
    234a:	82 8f       	std	Z+26, r24	; 0x1a
				}
				#endif /* configUSE_MUTEXES */

				/* Check to see if other tasks are blocked waiting to give the
				semaphore, and if so, unblock the highest priority such task. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    234c:	ea 81       	ldd	r30, Y+2	; 0x02
    234e:	fb 81       	ldd	r31, Y+3	; 0x03
    2350:	80 85       	ldd	r24, Z+8	; 0x08
    2352:	88 23       	and	r24, r24
    2354:	49 f0       	breq	.+18     	; 0x2368 <xQueueSemaphoreTake+0x60>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2356:	8a 81       	ldd	r24, Y+2	; 0x02
    2358:	9b 81       	ldd	r25, Y+3	; 0x03
    235a:	08 96       	adiw	r24, 0x08	; 8
    235c:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <xTaskRemoveFromEventList>
    2360:	88 23       	and	r24, r24
    2362:	11 f0       	breq	.+4      	; 0x2368 <xQueueSemaphoreTake+0x60>
					{
						queueYIELD_IF_USING_PREEMPTION();
    2364:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    2368:	0f 90       	pop	r0
    236a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    236c:	81 e0       	ldi	r24, 0x01	; 1
    236e:	8c 87       	std	Y+12, r24	; 0x0c
    2370:	63 c0       	rjmp	.+198    	; 0x2438 <xQueueSemaphoreTake+0x130>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2372:	8a 85       	ldd	r24, Y+10	; 0x0a
    2374:	9b 85       	ldd	r25, Y+11	; 0x0b
    2376:	00 97       	sbiw	r24, 0x00	; 0
    2378:	21 f4       	brne	.+8      	; 0x2382 <xQueueSemaphoreTake+0x7a>
					}
					#endif /* configUSE_MUTEXES */

					/* The semaphore count was 0 and no block time is specified
					(or the block time has expired) so exit now. */
					taskEXIT_CRITICAL();
    237a:	0f 90       	pop	r0
    237c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    237e:	1c 86       	std	Y+12, r1	; 0x0c
    2380:	5b c0       	rjmp	.+182    	; 0x2438 <xQueueSemaphoreTake+0x130>
				}
				else if( xEntryTimeSet == pdFALSE )
    2382:	8c 81       	ldd	r24, Y+4	; 0x04
    2384:	88 23       	and	r24, r24
    2386:	31 f4       	brne	.+12     	; 0x2394 <xQueueSemaphoreTake+0x8c>
				{
					/* The semaphore count was 0 and a block time was specified
					so configure the timeout structure ready to block. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    2388:	ce 01       	movw	r24, r28
    238a:	05 96       	adiw	r24, 0x05	; 5
    238c:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2390:	81 e0       	ldi	r24, 0x01	; 1
    2392:	8c 83       	std	Y+4, r24	; 0x04
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2394:	0f 90       	pop	r0
    2396:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can give to and take from the semaphore
		now the critical section has been exited. */

		vTaskSuspendAll();
    2398:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    239c:	0f b6       	in	r0, 0x3f	; 63
    239e:	f8 94       	cli
    23a0:	0f 92       	push	r0
    23a2:	ea 81       	ldd	r30, Y+2	; 0x02
    23a4:	fb 81       	ldd	r31, Y+3	; 0x03
    23a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    23a8:	8f 3f       	cpi	r24, 0xFF	; 255
    23aa:	19 f4       	brne	.+6      	; 0x23b2 <xQueueSemaphoreTake+0xaa>
    23ac:	ea 81       	ldd	r30, Y+2	; 0x02
    23ae:	fb 81       	ldd	r31, Y+3	; 0x03
    23b0:	15 8e       	std	Z+29, r1	; 0x1d
    23b2:	ea 81       	ldd	r30, Y+2	; 0x02
    23b4:	fb 81       	ldd	r31, Y+3	; 0x03
    23b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    23b8:	8f 3f       	cpi	r24, 0xFF	; 255
    23ba:	19 f4       	brne	.+6      	; 0x23c2 <xQueueSemaphoreTake+0xba>
    23bc:	ea 81       	ldd	r30, Y+2	; 0x02
    23be:	fb 81       	ldd	r31, Y+3	; 0x03
    23c0:	16 8e       	std	Z+30, r1	; 0x1e
    23c2:	0f 90       	pop	r0
    23c4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    23c6:	ce 01       	movw	r24, r28
    23c8:	05 96       	adiw	r24, 0x05	; 5
    23ca:	9e 01       	movw	r18, r28
    23cc:	26 5f       	subi	r18, 0xF6	; 246
    23ce:	3f 4f       	sbci	r19, 0xFF	; 255
    23d0:	b9 01       	movw	r22, r18
    23d2:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskCheckForTimeOut>
    23d6:	88 23       	and	r24, r24
    23d8:	09 f5       	brne	.+66     	; 0x241c <xQueueSemaphoreTake+0x114>
		{
			/* A block time is specified and not expired.  If the semaphore
			count is 0 then enter the Blocked state to wait for a semaphore to
			become available.  As semaphores are implemented with queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    23da:	8a 81       	ldd	r24, Y+2	; 0x02
    23dc:	9b 81       	ldd	r25, Y+3	; 0x03
    23de:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <prvIsQueueEmpty>
    23e2:	88 23       	and	r24, r24
    23e4:	a1 f0       	breq	.+40     	; 0x240e <xQueueSemaphoreTake+0x106>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    23e6:	8a 81       	ldd	r24, Y+2	; 0x02
    23e8:	9b 81       	ldd	r25, Y+3	; 0x03
    23ea:	41 96       	adiw	r24, 0x11	; 17
    23ec:	2a 85       	ldd	r18, Y+10	; 0x0a
    23ee:	3b 85       	ldd	r19, Y+11	; 0x0b
    23f0:	b9 01       	movw	r22, r18
    23f2:	0e 94 8d 1d 	call	0x3b1a	; 0x3b1a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    23f6:	8a 81       	ldd	r24, Y+2	; 0x02
    23f8:	9b 81       	ldd	r25, Y+3	; 0x03
    23fa:	0e 94 c3 14 	call	0x2986	; 0x2986 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    23fe:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
    2402:	88 23       	and	r24, r24
    2404:	09 f0       	breq	.+2      	; 0x2408 <xQueueSemaphoreTake+0x100>
    2406:	93 cf       	rjmp	.-218    	; 0x232e <xQueueSemaphoreTake+0x26>
				{
					portYIELD_WITHIN_API();
    2408:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
    240c:	90 cf       	rjmp	.-224    	; 0x232e <xQueueSemaphoreTake+0x26>
			}
			else
			{
				/* There was no timeout and the semaphore count was not 0, so
				attempt to take the semaphore again. */
				prvUnlockQueue( pxQueue );
    240e:	8a 81       	ldd	r24, Y+2	; 0x02
    2410:	9b 81       	ldd	r25, Y+3	; 0x03
    2412:	0e 94 c3 14 	call	0x2986	; 0x2986 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    2416:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
    241a:	89 cf       	rjmp	.-238    	; 0x232e <xQueueSemaphoreTake+0x26>
			}
		}
		else
		{
			/* Timed out. */
			prvUnlockQueue( pxQueue );
    241c:	8a 81       	ldd	r24, Y+2	; 0x02
    241e:	9b 81       	ldd	r25, Y+3	; 0x03
    2420:	0e 94 c3 14 	call	0x2986	; 0x2986 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2424:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>

			/* If the semaphore count is 0 exit now as the timeout has
			expired.  Otherwise return to attempt to take the semaphore that is
			known to be available.  As semaphores are implemented by queues the
			queue being empty is equivalent to the semaphore count being 0. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2428:	8a 81       	ldd	r24, Y+2	; 0x02
    242a:	9b 81       	ldd	r25, Y+3	; 0x03
    242c:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <prvIsQueueEmpty>
    2430:	88 23       	and	r24, r24
    2432:	09 f4       	brne	.+2      	; 0x2436 <xQueueSemaphoreTake+0x12e>
    2434:	7c cf       	rjmp	.-264    	; 0x232e <xQueueSemaphoreTake+0x26>
					}
				}
				#endif /* configUSE_MUTEXES */

				traceQUEUE_RECEIVE_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    2436:	1c 86       	std	Y+12, r1	; 0x0c
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    2438:	8c 85       	ldd	r24, Y+12	; 0x0c
}
    243a:	2c 96       	adiw	r28, 0x0c	; 12
    243c:	0f b6       	in	r0, 0x3f	; 63
    243e:	f8 94       	cli
    2440:	de bf       	out	0x3e, r29	; 62
    2442:	0f be       	out	0x3f, r0	; 63
    2444:	cd bf       	out	0x3d, r28	; 61
    2446:	cf 91       	pop	r28
    2448:	df 91       	pop	r29
    244a:	08 95       	ret

0000244c <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
{
    244c:	df 93       	push	r29
    244e:	cf 93       	push	r28
    2450:	cd b7       	in	r28, 0x3d	; 61
    2452:	de b7       	in	r29, 0x3e	; 62
    2454:	60 97       	sbiw	r28, 0x10	; 16
    2456:	0f b6       	in	r0, 0x3f	; 63
    2458:	f8 94       	cli
    245a:	de bf       	out	0x3e, r29	; 62
    245c:	0f be       	out	0x3f, r0	; 63
    245e:	cd bf       	out	0x3d, r28	; 61
    2460:	9b 87       	std	Y+11, r25	; 0x0b
    2462:	8a 87       	std	Y+10, r24	; 0x0a
    2464:	7d 87       	std	Y+13, r23	; 0x0d
    2466:	6c 87       	std	Y+12, r22	; 0x0c
    2468:	5f 87       	std	Y+15, r21	; 0x0f
    246a:	4e 87       	std	Y+14, r20	; 0x0e
BaseType_t xEntryTimeSet = pdFALSE;
    246c:	1e 82       	std	Y+6, r1	; 0x06
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    246e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2470:	9b 85       	ldd	r25, Y+11	; 0x0b
    2472:	9b 83       	std	Y+3, r25	; 0x03
    2474:	8a 83       	std	Y+2, r24	; 0x02
	/*lint -save -e904  This function relaxes the coding standard somewhat to
	allow return statements within the function itself.  This is done in the
	interest of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    2476:	0f b6       	in	r0, 0x3f	; 63
    2478:	f8 94       	cli
    247a:	0f 92       	push	r0
		{
			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    247c:	ea 81       	ldd	r30, Y+2	; 0x02
    247e:	fb 81       	ldd	r31, Y+3	; 0x03
    2480:	82 8d       	ldd	r24, Z+26	; 0x1a
    2482:	89 83       	std	Y+1, r24	; 0x01

			/* Is there data in the queue now?  To be running the calling task
			must be the highest priority task wanting to access the queue. */
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    2484:	89 81       	ldd	r24, Y+1	; 0x01
    2486:	88 23       	and	r24, r24
    2488:	31 f1       	breq	.+76     	; 0x24d6 <xQueuePeek+0x8a>
			{
				/* Remember the read position so it can be reset after the data
				is read from the queue as this function is only peeking the
				data, not removing it. */
				pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    248a:	ea 81       	ldd	r30, Y+2	; 0x02
    248c:	fb 81       	ldd	r31, Y+3	; 0x03
    248e:	86 81       	ldd	r24, Z+6	; 0x06
    2490:	97 81       	ldd	r25, Z+7	; 0x07
    2492:	9d 83       	std	Y+5, r25	; 0x05
    2494:	8c 83       	std	Y+4, r24	; 0x04

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2496:	8a 81       	ldd	r24, Y+2	; 0x02
    2498:	9b 81       	ldd	r25, Y+3	; 0x03
    249a:	2c 85       	ldd	r18, Y+12	; 0x0c
    249c:	3d 85       	ldd	r19, Y+13	; 0x0d
    249e:	b9 01       	movw	r22, r18
    24a0:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <prvCopyDataFromQueue>
				traceQUEUE_PEEK( pxQueue );

				/* The data is not being removed, so reset the read pointer. */
				pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    24a4:	ea 81       	ldd	r30, Y+2	; 0x02
    24a6:	fb 81       	ldd	r31, Y+3	; 0x03
    24a8:	8c 81       	ldd	r24, Y+4	; 0x04
    24aa:	9d 81       	ldd	r25, Y+5	; 0x05
    24ac:	97 83       	std	Z+7, r25	; 0x07
    24ae:	86 83       	std	Z+6, r24	; 0x06

				/* The data is being left in the queue, so see if there are
				any other tasks waiting for the data. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    24b0:	ea 81       	ldd	r30, Y+2	; 0x02
    24b2:	fb 81       	ldd	r31, Y+3	; 0x03
    24b4:	81 89       	ldd	r24, Z+17	; 0x11
    24b6:	88 23       	and	r24, r24
    24b8:	49 f0       	breq	.+18     	; 0x24cc <xQueuePeek+0x80>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    24ba:	8a 81       	ldd	r24, Y+2	; 0x02
    24bc:	9b 81       	ldd	r25, Y+3	; 0x03
    24be:	41 96       	adiw	r24, 0x11	; 17
    24c0:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <xTaskRemoveFromEventList>
    24c4:	88 23       	and	r24, r24
    24c6:	11 f0       	breq	.+4      	; 0x24cc <xQueuePeek+0x80>
					{
						/* The task waiting has a higher priority than this task. */
						queueYIELD_IF_USING_PREEMPTION();
    24c8:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				taskEXIT_CRITICAL();
    24cc:	0f 90       	pop	r0
    24ce:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    24d0:	81 e0       	ldi	r24, 0x01	; 1
    24d2:	88 8b       	std	Y+16, r24	; 0x10
    24d4:	63 c0       	rjmp	.+198    	; 0x259c <xQueuePeek+0x150>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    24d6:	8e 85       	ldd	r24, Y+14	; 0x0e
    24d8:	9f 85       	ldd	r25, Y+15	; 0x0f
    24da:	00 97       	sbiw	r24, 0x00	; 0
    24dc:	21 f4       	brne	.+8      	; 0x24e6 <xQueuePeek+0x9a>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    24de:	0f 90       	pop	r0
    24e0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_PEEK_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    24e2:	18 8a       	std	Y+16, r1	; 0x10
    24e4:	5b c0       	rjmp	.+182    	; 0x259c <xQueuePeek+0x150>
				}
				else if( xEntryTimeSet == pdFALSE )
    24e6:	8e 81       	ldd	r24, Y+6	; 0x06
    24e8:	88 23       	and	r24, r24
    24ea:	31 f4       	brne	.+12     	; 0x24f8 <xQueuePeek+0xac>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure ready to enter the blocked
					state. */
					vTaskInternalSetTimeOutState( &xTimeOut );
    24ec:	ce 01       	movw	r24, r28
    24ee:	07 96       	adiw	r24, 0x07	; 7
    24f0:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <vTaskInternalSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    24f4:	81 e0       	ldi	r24, 0x01	; 1
    24f6:	8e 83       	std	Y+6, r24	; 0x06
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    24f8:	0f 90       	pop	r0
    24fa:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    24fc:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2500:	0f b6       	in	r0, 0x3f	; 63
    2502:	f8 94       	cli
    2504:	0f 92       	push	r0
    2506:	ea 81       	ldd	r30, Y+2	; 0x02
    2508:	fb 81       	ldd	r31, Y+3	; 0x03
    250a:	85 8d       	ldd	r24, Z+29	; 0x1d
    250c:	8f 3f       	cpi	r24, 0xFF	; 255
    250e:	19 f4       	brne	.+6      	; 0x2516 <xQueuePeek+0xca>
    2510:	ea 81       	ldd	r30, Y+2	; 0x02
    2512:	fb 81       	ldd	r31, Y+3	; 0x03
    2514:	15 8e       	std	Z+29, r1	; 0x1d
    2516:	ea 81       	ldd	r30, Y+2	; 0x02
    2518:	fb 81       	ldd	r31, Y+3	; 0x03
    251a:	86 8d       	ldd	r24, Z+30	; 0x1e
    251c:	8f 3f       	cpi	r24, 0xFF	; 255
    251e:	19 f4       	brne	.+6      	; 0x2526 <xQueuePeek+0xda>
    2520:	ea 81       	ldd	r30, Y+2	; 0x02
    2522:	fb 81       	ldd	r31, Y+3	; 0x03
    2524:	16 8e       	std	Z+30, r1	; 0x1e
    2526:	0f 90       	pop	r0
    2528:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    252a:	ce 01       	movw	r24, r28
    252c:	07 96       	adiw	r24, 0x07	; 7
    252e:	9e 01       	movw	r18, r28
    2530:	22 5f       	subi	r18, 0xF2	; 242
    2532:	3f 4f       	sbci	r19, 0xFF	; 255
    2534:	b9 01       	movw	r22, r18
    2536:	0e 94 de 1e 	call	0x3dbc	; 0x3dbc <xTaskCheckForTimeOut>
    253a:	88 23       	and	r24, r24
    253c:	09 f5       	brne	.+66     	; 0x2580 <xQueuePeek+0x134>
		{
			/* Timeout has not expired yet, check to see if there is data in the
			queue now, and if not enter the Blocked state to wait for data. */
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    253e:	8a 81       	ldd	r24, Y+2	; 0x02
    2540:	9b 81       	ldd	r25, Y+3	; 0x03
    2542:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <prvIsQueueEmpty>
    2546:	88 23       	and	r24, r24
    2548:	a1 f0       	breq	.+40     	; 0x2572 <xQueuePeek+0x126>
			{
				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    254a:	8a 81       	ldd	r24, Y+2	; 0x02
    254c:	9b 81       	ldd	r25, Y+3	; 0x03
    254e:	41 96       	adiw	r24, 0x11	; 17
    2550:	2e 85       	ldd	r18, Y+14	; 0x0e
    2552:	3f 85       	ldd	r19, Y+15	; 0x0f
    2554:	b9 01       	movw	r22, r18
    2556:	0e 94 8d 1d 	call	0x3b1a	; 0x3b1a <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    255a:	8a 81       	ldd	r24, Y+2	; 0x02
    255c:	9b 81       	ldd	r25, Y+3	; 0x03
    255e:	0e 94 c3 14 	call	0x2986	; 0x2986 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2562:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
    2566:	88 23       	and	r24, r24
    2568:	09 f0       	breq	.+2      	; 0x256c <xQueuePeek+0x120>
    256a:	85 cf       	rjmp	.-246    	; 0x2476 <xQueuePeek+0x2a>
				{
					portYIELD_WITHIN_API();
    256c:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
    2570:	82 cf       	rjmp	.-252    	; 0x2476 <xQueuePeek+0x2a>
			}
			else
			{
				/* There is data in the queue now, so don't enter the blocked
				state, instead return to try and obtain the data. */
				prvUnlockQueue( pxQueue );
    2572:	8a 81       	ldd	r24, Y+2	; 0x02
    2574:	9b 81       	ldd	r25, Y+3	; 0x03
    2576:	0e 94 c3 14 	call	0x2986	; 0x2986 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    257a:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
    257e:	7b cf       	rjmp	.-266    	; 0x2476 <xQueuePeek+0x2a>
		}
		else
		{
			/* The timeout has expired.  If there is still no data in the queue
			exit, otherwise go back and try to read the data again. */
			prvUnlockQueue( pxQueue );
    2580:	8a 81       	ldd	r24, Y+2	; 0x02
    2582:	9b 81       	ldd	r25, Y+3	; 0x03
    2584:	0e 94 c3 14 	call	0x2986	; 0x2986 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    2588:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>

			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    258c:	8a 81       	ldd	r24, Y+2	; 0x02
    258e:	9b 81       	ldd	r25, Y+3	; 0x03
    2590:	0e 94 16 15 	call	0x2a2c	; 0x2a2c <prvIsQueueEmpty>
    2594:	88 23       	and	r24, r24
    2596:	09 f4       	brne	.+2      	; 0x259a <xQueuePeek+0x14e>
    2598:	6e cf       	rjmp	.-292    	; 0x2476 <xQueuePeek+0x2a>
			{
				traceQUEUE_PEEK_FAILED( pxQueue );
				return errQUEUE_EMPTY;
    259a:	18 8a       	std	Y+16, r1	; 0x10
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	} /*lint -restore */
    259c:	88 89       	ldd	r24, Y+16	; 0x10
}
    259e:	60 96       	adiw	r28, 0x10	; 16
    25a0:	0f b6       	in	r0, 0x3f	; 63
    25a2:	f8 94       	cli
    25a4:	de bf       	out	0x3e, r29	; 62
    25a6:	0f be       	out	0x3f, r0	; 63
    25a8:	cd bf       	out	0x3d, r28	; 61
    25aa:	cf 91       	pop	r28
    25ac:	df 91       	pop	r29
    25ae:	08 95       	ret

000025b0 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
    25b0:	df 93       	push	r29
    25b2:	cf 93       	push	r28
    25b4:	cd b7       	in	r28, 0x3d	; 61
    25b6:	de b7       	in	r29, 0x3e	; 62
    25b8:	2c 97       	sbiw	r28, 0x0c	; 12
    25ba:	0f b6       	in	r0, 0x3f	; 63
    25bc:	f8 94       	cli
    25be:	de bf       	out	0x3e, r29	; 62
    25c0:	0f be       	out	0x3f, r0	; 63
    25c2:	cd bf       	out	0x3d, r28	; 61
    25c4:	98 87       	std	Y+8, r25	; 0x08
    25c6:	8f 83       	std	Y+7, r24	; 0x07
    25c8:	7a 87       	std	Y+10, r23	; 0x0a
    25ca:	69 87       	std	Y+9, r22	; 0x09
    25cc:	5c 87       	std	Y+12, r21	; 0x0c
    25ce:	4b 87       	std	Y+11, r20	; 0x0b
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = xQueue;
    25d0:	8f 81       	ldd	r24, Y+7	; 0x07
    25d2:	98 85       	ldd	r25, Y+8	; 0x08
    25d4:	9c 83       	std	Y+4, r25	; 0x04
    25d6:	8b 83       	std	Y+3, r24	; 0x03
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    25d8:	1d 82       	std	Y+5, r1	; 0x05
	{
		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    25da:	eb 81       	ldd	r30, Y+3	; 0x03
    25dc:	fc 81       	ldd	r31, Y+4	; 0x04
    25de:	82 8d       	ldd	r24, Z+26	; 0x1a
    25e0:	8a 83       	std	Y+2, r24	; 0x02

		/* Cannot block in an ISR, so check there is data available. */
		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    25e2:	8a 81       	ldd	r24, Y+2	; 0x02
    25e4:	88 23       	and	r24, r24
    25e6:	81 f1       	breq	.+96     	; 0x2648 <xQueueReceiveFromISR+0x98>
		{
			const int8_t cRxLock = pxQueue->cRxLock;
    25e8:	eb 81       	ldd	r30, Y+3	; 0x03
    25ea:	fc 81       	ldd	r31, Y+4	; 0x04
    25ec:	85 8d       	ldd	r24, Z+29	; 0x1d
    25ee:	89 83       	std	Y+1, r24	; 0x01

			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    25f0:	8b 81       	ldd	r24, Y+3	; 0x03
    25f2:	9c 81       	ldd	r25, Y+4	; 0x04
    25f4:	29 85       	ldd	r18, Y+9	; 0x09
    25f6:	3a 85       	ldd	r19, Y+10	; 0x0a
    25f8:	b9 01       	movw	r22, r18
    25fa:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <prvCopyDataFromQueue>
			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    25fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2600:	81 50       	subi	r24, 0x01	; 1
    2602:	eb 81       	ldd	r30, Y+3	; 0x03
    2604:	fc 81       	ldd	r31, Y+4	; 0x04
    2606:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( cRxLock == queueUNLOCKED )
    2608:	89 81       	ldd	r24, Y+1	; 0x01
    260a:	8f 3f       	cpi	r24, 0xFF	; 255
    260c:	a9 f4       	brne	.+42     	; 0x2638 <xQueueReceiveFromISR+0x88>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    260e:	eb 81       	ldd	r30, Y+3	; 0x03
    2610:	fc 81       	ldd	r31, Y+4	; 0x04
    2612:	80 85       	ldd	r24, Z+8	; 0x08
    2614:	88 23       	and	r24, r24
    2616:	a9 f0       	breq	.+42     	; 0x2642 <xQueueReceiveFromISR+0x92>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2618:	8b 81       	ldd	r24, Y+3	; 0x03
    261a:	9c 81       	ldd	r25, Y+4	; 0x04
    261c:	08 96       	adiw	r24, 0x08	; 8
    261e:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <xTaskRemoveFromEventList>
    2622:	88 23       	and	r24, r24
    2624:	71 f0       	breq	.+28     	; 0x2642 <xQueueReceiveFromISR+0x92>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    2626:	8b 85       	ldd	r24, Y+11	; 0x0b
    2628:	9c 85       	ldd	r25, Y+12	; 0x0c
    262a:	00 97       	sbiw	r24, 0x00	; 0
    262c:	51 f0       	breq	.+20     	; 0x2642 <xQueueReceiveFromISR+0x92>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    262e:	eb 85       	ldd	r30, Y+11	; 0x0b
    2630:	fc 85       	ldd	r31, Y+12	; 0x0c
    2632:	81 e0       	ldi	r24, 0x01	; 1
    2634:	80 83       	st	Z, r24
    2636:	05 c0       	rjmp	.+10     	; 0x2642 <xQueueReceiveFromISR+0x92>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
    2638:	89 81       	ldd	r24, Y+1	; 0x01
    263a:	8f 5f       	subi	r24, 0xFF	; 255
    263c:	eb 81       	ldd	r30, Y+3	; 0x03
    263e:	fc 81       	ldd	r31, Y+4	; 0x04
    2640:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2642:	81 e0       	ldi	r24, 0x01	; 1
    2644:	8e 83       	std	Y+6, r24	; 0x06
    2646:	01 c0       	rjmp	.+2      	; 0x264a <xQueueReceiveFromISR+0x9a>
		}
		else
		{
			xReturn = pdFAIL;
    2648:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    264a:	8e 81       	ldd	r24, Y+6	; 0x06
}
    264c:	2c 96       	adiw	r28, 0x0c	; 12
    264e:	0f b6       	in	r0, 0x3f	; 63
    2650:	f8 94       	cli
    2652:	de bf       	out	0x3e, r29	; 62
    2654:	0f be       	out	0x3f, r0	; 63
    2656:	cd bf       	out	0x3d, r28	; 61
    2658:	cf 91       	pop	r28
    265a:	df 91       	pop	r29
    265c:	08 95       	ret

0000265e <xQueuePeekFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
{
    265e:	df 93       	push	r29
    2660:	cf 93       	push	r28
    2662:	cd b7       	in	r28, 0x3d	; 61
    2664:	de b7       	in	r29, 0x3e	; 62
    2666:	2a 97       	sbiw	r28, 0x0a	; 10
    2668:	0f b6       	in	r0, 0x3f	; 63
    266a:	f8 94       	cli
    266c:	de bf       	out	0x3e, r29	; 62
    266e:	0f be       	out	0x3f, r0	; 63
    2670:	cd bf       	out	0x3d, r28	; 61
    2672:	98 87       	std	Y+8, r25	; 0x08
    2674:	8f 83       	std	Y+7, r24	; 0x07
    2676:	7a 87       	std	Y+10, r23	; 0x0a
    2678:	69 87       	std	Y+9, r22	; 0x09
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = xQueue;
    267a:	8f 81       	ldd	r24, Y+7	; 0x07
    267c:	98 85       	ldd	r25, Y+8	; 0x08
    267e:	9a 83       	std	Y+2, r25	; 0x02
    2680:	89 83       	std	Y+1, r24	; 0x01
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2682:	1d 82       	std	Y+5, r1	; 0x05
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2684:	e9 81       	ldd	r30, Y+1	; 0x01
    2686:	fa 81       	ldd	r31, Y+2	; 0x02
    2688:	82 8d       	ldd	r24, Z+26	; 0x1a
    268a:	88 23       	and	r24, r24
    268c:	b1 f0       	breq	.+44     	; 0x26ba <xQueuePeekFromISR+0x5c>
		{
			traceQUEUE_PEEK_FROM_ISR( pxQueue );

			/* Remember the read position so it can be reset as nothing is
			actually being removed from the queue. */
			pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    268e:	e9 81       	ldd	r30, Y+1	; 0x01
    2690:	fa 81       	ldd	r31, Y+2	; 0x02
    2692:	86 81       	ldd	r24, Z+6	; 0x06
    2694:	97 81       	ldd	r25, Z+7	; 0x07
    2696:	9c 83       	std	Y+4, r25	; 0x04
    2698:	8b 83       	std	Y+3, r24	; 0x03
			prvCopyDataFromQueue( pxQueue, pvBuffer );
    269a:	89 81       	ldd	r24, Y+1	; 0x01
    269c:	9a 81       	ldd	r25, Y+2	; 0x02
    269e:	29 85       	ldd	r18, Y+9	; 0x09
    26a0:	3a 85       	ldd	r19, Y+10	; 0x0a
    26a2:	b9 01       	movw	r22, r18
    26a4:	0e 94 7c 14 	call	0x28f8	; 0x28f8 <prvCopyDataFromQueue>
			pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    26a8:	e9 81       	ldd	r30, Y+1	; 0x01
    26aa:	fa 81       	ldd	r31, Y+2	; 0x02
    26ac:	8b 81       	ldd	r24, Y+3	; 0x03
    26ae:	9c 81       	ldd	r25, Y+4	; 0x04
    26b0:	97 83       	std	Z+7, r25	; 0x07
    26b2:	86 83       	std	Z+6, r24	; 0x06

			xReturn = pdPASS;
    26b4:	81 e0       	ldi	r24, 0x01	; 1
    26b6:	8e 83       	std	Y+6, r24	; 0x06
    26b8:	01 c0       	rjmp	.+2      	; 0x26bc <xQueuePeekFromISR+0x5e>
		}
		else
		{
			xReturn = pdFAIL;
    26ba:	1e 82       	std	Y+6, r1	; 0x06
			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    26bc:	8e 81       	ldd	r24, Y+6	; 0x06
}
    26be:	2a 96       	adiw	r28, 0x0a	; 10
    26c0:	0f b6       	in	r0, 0x3f	; 63
    26c2:	f8 94       	cli
    26c4:	de bf       	out	0x3e, r29	; 62
    26c6:	0f be       	out	0x3f, r0	; 63
    26c8:	cd bf       	out	0x3d, r28	; 61
    26ca:	cf 91       	pop	r28
    26cc:	df 91       	pop	r29
    26ce:	08 95       	ret

000026d0 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    26d0:	df 93       	push	r29
    26d2:	cf 93       	push	r28
    26d4:	00 d0       	rcall	.+0      	; 0x26d6 <uxQueueMessagesWaiting+0x6>
    26d6:	0f 92       	push	r0
    26d8:	cd b7       	in	r28, 0x3d	; 61
    26da:	de b7       	in	r29, 0x3e	; 62
    26dc:	9b 83       	std	Y+3, r25	; 0x03
    26de:	8a 83       	std	Y+2, r24	; 0x02
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    26e0:	0f b6       	in	r0, 0x3f	; 63
    26e2:	f8 94       	cli
    26e4:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    26e6:	ea 81       	ldd	r30, Y+2	; 0x02
    26e8:	fb 81       	ldd	r31, Y+3	; 0x03
    26ea:	82 8d       	ldd	r24, Z+26	; 0x1a
    26ec:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    26ee:	0f 90       	pop	r0
    26f0:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    26f2:	89 81       	ldd	r24, Y+1	; 0x01
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    26f4:	0f 90       	pop	r0
    26f6:	0f 90       	pop	r0
    26f8:	0f 90       	pop	r0
    26fa:	cf 91       	pop	r28
    26fc:	df 91       	pop	r29
    26fe:	08 95       	ret

00002700 <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    2700:	df 93       	push	r29
    2702:	cf 93       	push	r28
    2704:	00 d0       	rcall	.+0      	; 0x2706 <uxQueueSpacesAvailable+0x6>
    2706:	00 d0       	rcall	.+0      	; 0x2708 <uxQueueSpacesAvailable+0x8>
    2708:	0f 92       	push	r0
    270a:	cd b7       	in	r28, 0x3d	; 61
    270c:	de b7       	in	r29, 0x3e	; 62
    270e:	9d 83       	std	Y+5, r25	; 0x05
    2710:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    2712:	8c 81       	ldd	r24, Y+4	; 0x04
    2714:	9d 81       	ldd	r25, Y+5	; 0x05
    2716:	9a 83       	std	Y+2, r25	; 0x02
    2718:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    271a:	0f b6       	in	r0, 0x3f	; 63
    271c:	f8 94       	cli
    271e:	0f 92       	push	r0
	{
		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    2720:	e9 81       	ldd	r30, Y+1	; 0x01
    2722:	fa 81       	ldd	r31, Y+2	; 0x02
    2724:	93 8d       	ldd	r25, Z+27	; 0x1b
    2726:	e9 81       	ldd	r30, Y+1	; 0x01
    2728:	fa 81       	ldd	r31, Y+2	; 0x02
    272a:	82 8d       	ldd	r24, Z+26	; 0x1a
    272c:	29 2f       	mov	r18, r25
    272e:	28 1b       	sub	r18, r24
    2730:	82 2f       	mov	r24, r18
    2732:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    2734:	0f 90       	pop	r0
    2736:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2738:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    273a:	0f 90       	pop	r0
    273c:	0f 90       	pop	r0
    273e:	0f 90       	pop	r0
    2740:	0f 90       	pop	r0
    2742:	0f 90       	pop	r0
    2744:	cf 91       	pop	r28
    2746:	df 91       	pop	r29
    2748:	08 95       	ret

0000274a <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    274a:	df 93       	push	r29
    274c:	cf 93       	push	r28
    274e:	00 d0       	rcall	.+0      	; 0x2750 <uxQueueMessagesWaitingFromISR+0x6>
    2750:	00 d0       	rcall	.+0      	; 0x2752 <uxQueueMessagesWaitingFromISR+0x8>
    2752:	0f 92       	push	r0
    2754:	cd b7       	in	r28, 0x3d	; 61
    2756:	de b7       	in	r29, 0x3e	; 62
    2758:	9d 83       	std	Y+5, r25	; 0x05
    275a:	8c 83       	std	Y+4, r24	; 0x04
UBaseType_t uxReturn;
Queue_t * const pxQueue = xQueue;
    275c:	8c 81       	ldd	r24, Y+4	; 0x04
    275e:	9d 81       	ldd	r25, Y+5	; 0x05
    2760:	9a 83       	std	Y+2, r25	; 0x02
    2762:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	uxReturn = pxQueue->uxMessagesWaiting;
    2764:	e9 81       	ldd	r30, Y+1	; 0x01
    2766:	fa 81       	ldd	r31, Y+2	; 0x02
    2768:	82 8d       	ldd	r24, Z+26	; 0x1a
    276a:	8b 83       	std	Y+3, r24	; 0x03

	return uxReturn;
    276c:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    276e:	0f 90       	pop	r0
    2770:	0f 90       	pop	r0
    2772:	0f 90       	pop	r0
    2774:	0f 90       	pop	r0
    2776:	0f 90       	pop	r0
    2778:	cf 91       	pop	r28
    277a:	df 91       	pop	r29
    277c:	08 95       	ret

0000277e <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( QueueHandle_t xQueue )
{
    277e:	df 93       	push	r29
    2780:	cf 93       	push	r28
    2782:	00 d0       	rcall	.+0      	; 0x2784 <vQueueDelete+0x6>
    2784:	00 d0       	rcall	.+0      	; 0x2786 <vQueueDelete+0x8>
    2786:	cd b7       	in	r28, 0x3d	; 61
    2788:	de b7       	in	r29, 0x3e	; 62
    278a:	9c 83       	std	Y+4, r25	; 0x04
    278c:	8b 83       	std	Y+3, r24	; 0x03
Queue_t * const pxQueue = xQueue;
    278e:	8b 81       	ldd	r24, Y+3	; 0x03
    2790:	9c 81       	ldd	r25, Y+4	; 0x04
    2792:	9a 83       	std	Y+2, r25	; 0x02
    2794:	89 83       	std	Y+1, r24	; 0x01

	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
	{
		/* The queue can only have been allocated dynamically - free it
		again. */
		vPortFree( pxQueue );
    2796:	89 81       	ldd	r24, Y+1	; 0x01
    2798:	9a 81       	ldd	r25, Y+2	; 0x02
    279a:	0e 94 44 0a 	call	0x1488	; 0x1488 <vPortFree>
		/* The queue must have been statically allocated, so is not going to be
		deleted.  Avoid compiler warnings about the unused parameter. */
		( void ) pxQueue;
	}
	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    279e:	0f 90       	pop	r0
    27a0:	0f 90       	pop	r0
    27a2:	0f 90       	pop	r0
    27a4:	0f 90       	pop	r0
    27a6:	cf 91       	pop	r28
    27a8:	df 91       	pop	r29
    27aa:	08 95       	ret

000027ac <prvCopyDataToQueue>:

#endif /* configUSE_MUTEXES */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
    27ac:	df 93       	push	r29
    27ae:	cf 93       	push	r28
    27b0:	cd b7       	in	r28, 0x3d	; 61
    27b2:	de b7       	in	r29, 0x3e	; 62
    27b4:	27 97       	sbiw	r28, 0x07	; 7
    27b6:	0f b6       	in	r0, 0x3f	; 63
    27b8:	f8 94       	cli
    27ba:	de bf       	out	0x3e, r29	; 62
    27bc:	0f be       	out	0x3f, r0	; 63
    27be:	cd bf       	out	0x3d, r28	; 61
    27c0:	9c 83       	std	Y+4, r25	; 0x04
    27c2:	8b 83       	std	Y+3, r24	; 0x03
    27c4:	7e 83       	std	Y+6, r23	; 0x06
    27c6:	6d 83       	std	Y+5, r22	; 0x05
    27c8:	4f 83       	std	Y+7, r20	; 0x07
BaseType_t xReturn = pdFALSE;
    27ca:	1a 82       	std	Y+2, r1	; 0x02
UBaseType_t uxMessagesWaiting;

	/* This function is called from a critical section. */

	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    27cc:	eb 81       	ldd	r30, Y+3	; 0x03
    27ce:	fc 81       	ldd	r31, Y+4	; 0x04
    27d0:	82 8d       	ldd	r24, Z+26	; 0x1a
    27d2:	89 83       	std	Y+1, r24	; 0x01

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    27d4:	eb 81       	ldd	r30, Y+3	; 0x03
    27d6:	fc 81       	ldd	r31, Y+4	; 0x04
    27d8:	84 8d       	ldd	r24, Z+28	; 0x1c
    27da:	88 23       	and	r24, r24
    27dc:	09 f4       	brne	.+2      	; 0x27e0 <prvCopyDataToQueue+0x34>
    27de:	7d c0       	rjmp	.+250    	; 0x28da <prvCopyDataToQueue+0x12e>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
    27e0:	8f 81       	ldd	r24, Y+7	; 0x07
    27e2:	88 23       	and	r24, r24
    27e4:	99 f5       	brne	.+102    	; 0x284c <prvCopyDataToQueue+0xa0>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    27e6:	eb 81       	ldd	r30, Y+3	; 0x03
    27e8:	fc 81       	ldd	r31, Y+4	; 0x04
    27ea:	62 81       	ldd	r22, Z+2	; 0x02
    27ec:	73 81       	ldd	r23, Z+3	; 0x03
    27ee:	eb 81       	ldd	r30, Y+3	; 0x03
    27f0:	fc 81       	ldd	r31, Y+4	; 0x04
    27f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    27f4:	48 2f       	mov	r20, r24
    27f6:	50 e0       	ldi	r21, 0x00	; 0
    27f8:	2d 81       	ldd	r18, Y+5	; 0x05
    27fa:	3e 81       	ldd	r19, Y+6	; 0x06
    27fc:	cb 01       	movw	r24, r22
    27fe:	b9 01       	movw	r22, r18
    2800:	0e 94 fe 2d 	call	0x5bfc	; 0x5bfc <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2804:	eb 81       	ldd	r30, Y+3	; 0x03
    2806:	fc 81       	ldd	r31, Y+4	; 0x04
    2808:	22 81       	ldd	r18, Z+2	; 0x02
    280a:	33 81       	ldd	r19, Z+3	; 0x03
    280c:	eb 81       	ldd	r30, Y+3	; 0x03
    280e:	fc 81       	ldd	r31, Y+4	; 0x04
    2810:	84 8d       	ldd	r24, Z+28	; 0x1c
    2812:	88 2f       	mov	r24, r24
    2814:	90 e0       	ldi	r25, 0x00	; 0
    2816:	82 0f       	add	r24, r18
    2818:	93 1f       	adc	r25, r19
    281a:	eb 81       	ldd	r30, Y+3	; 0x03
    281c:	fc 81       	ldd	r31, Y+4	; 0x04
    281e:	93 83       	std	Z+3, r25	; 0x03
    2820:	82 83       	std	Z+2, r24	; 0x02
		if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    2822:	eb 81       	ldd	r30, Y+3	; 0x03
    2824:	fc 81       	ldd	r31, Y+4	; 0x04
    2826:	22 81       	ldd	r18, Z+2	; 0x02
    2828:	33 81       	ldd	r19, Z+3	; 0x03
    282a:	eb 81       	ldd	r30, Y+3	; 0x03
    282c:	fc 81       	ldd	r31, Y+4	; 0x04
    282e:	84 81       	ldd	r24, Z+4	; 0x04
    2830:	95 81       	ldd	r25, Z+5	; 0x05
    2832:	28 17       	cp	r18, r24
    2834:	39 07       	cpc	r19, r25
    2836:	08 f4       	brcc	.+2      	; 0x283a <prvCopyDataToQueue+0x8e>
    2838:	50 c0       	rjmp	.+160    	; 0x28da <prvCopyDataToQueue+0x12e>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    283a:	eb 81       	ldd	r30, Y+3	; 0x03
    283c:	fc 81       	ldd	r31, Y+4	; 0x04
    283e:	80 81       	ld	r24, Z
    2840:	91 81       	ldd	r25, Z+1	; 0x01
    2842:	eb 81       	ldd	r30, Y+3	; 0x03
    2844:	fc 81       	ldd	r31, Y+4	; 0x04
    2846:	93 83       	std	Z+3, r25	; 0x03
    2848:	82 83       	std	Z+2, r24	; 0x02
    284a:	47 c0       	rjmp	.+142    	; 0x28da <prvCopyDataToQueue+0x12e>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    284c:	eb 81       	ldd	r30, Y+3	; 0x03
    284e:	fc 81       	ldd	r31, Y+4	; 0x04
    2850:	66 81       	ldd	r22, Z+6	; 0x06
    2852:	77 81       	ldd	r23, Z+7	; 0x07
    2854:	eb 81       	ldd	r30, Y+3	; 0x03
    2856:	fc 81       	ldd	r31, Y+4	; 0x04
    2858:	84 8d       	ldd	r24, Z+28	; 0x1c
    285a:	48 2f       	mov	r20, r24
    285c:	50 e0       	ldi	r21, 0x00	; 0
    285e:	2d 81       	ldd	r18, Y+5	; 0x05
    2860:	3e 81       	ldd	r19, Y+6	; 0x06
    2862:	cb 01       	movw	r24, r22
    2864:	b9 01       	movw	r22, r18
    2866:	0e 94 fe 2d 	call	0x5bfc	; 0x5bfc <memcpy>
		pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    286a:	eb 81       	ldd	r30, Y+3	; 0x03
    286c:	fc 81       	ldd	r31, Y+4	; 0x04
    286e:	26 81       	ldd	r18, Z+6	; 0x06
    2870:	37 81       	ldd	r19, Z+7	; 0x07
    2872:	eb 81       	ldd	r30, Y+3	; 0x03
    2874:	fc 81       	ldd	r31, Y+4	; 0x04
    2876:	84 8d       	ldd	r24, Z+28	; 0x1c
    2878:	88 2f       	mov	r24, r24
    287a:	90 e0       	ldi	r25, 0x00	; 0
    287c:	90 95       	com	r25
    287e:	81 95       	neg	r24
    2880:	9f 4f       	sbci	r25, 0xFF	; 255
    2882:	82 0f       	add	r24, r18
    2884:	93 1f       	adc	r25, r19
    2886:	eb 81       	ldd	r30, Y+3	; 0x03
    2888:	fc 81       	ldd	r31, Y+4	; 0x04
    288a:	97 83       	std	Z+7, r25	; 0x07
    288c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    288e:	eb 81       	ldd	r30, Y+3	; 0x03
    2890:	fc 81       	ldd	r31, Y+4	; 0x04
    2892:	26 81       	ldd	r18, Z+6	; 0x06
    2894:	37 81       	ldd	r19, Z+7	; 0x07
    2896:	eb 81       	ldd	r30, Y+3	; 0x03
    2898:	fc 81       	ldd	r31, Y+4	; 0x04
    289a:	80 81       	ld	r24, Z
    289c:	91 81       	ldd	r25, Z+1	; 0x01
    289e:	28 17       	cp	r18, r24
    28a0:	39 07       	cpc	r19, r25
    28a2:	90 f4       	brcc	.+36     	; 0x28c8 <prvCopyDataToQueue+0x11c>
		{
			pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    28a4:	eb 81       	ldd	r30, Y+3	; 0x03
    28a6:	fc 81       	ldd	r31, Y+4	; 0x04
    28a8:	24 81       	ldd	r18, Z+4	; 0x04
    28aa:	35 81       	ldd	r19, Z+5	; 0x05
    28ac:	eb 81       	ldd	r30, Y+3	; 0x03
    28ae:	fc 81       	ldd	r31, Y+4	; 0x04
    28b0:	84 8d       	ldd	r24, Z+28	; 0x1c
    28b2:	88 2f       	mov	r24, r24
    28b4:	90 e0       	ldi	r25, 0x00	; 0
    28b6:	90 95       	com	r25
    28b8:	81 95       	neg	r24
    28ba:	9f 4f       	sbci	r25, 0xFF	; 255
    28bc:	82 0f       	add	r24, r18
    28be:	93 1f       	adc	r25, r19
    28c0:	eb 81       	ldd	r30, Y+3	; 0x03
    28c2:	fc 81       	ldd	r31, Y+4	; 0x04
    28c4:	97 83       	std	Z+7, r25	; 0x07
    28c6:	86 83       	std	Z+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
    28c8:	8f 81       	ldd	r24, Y+7	; 0x07
    28ca:	82 30       	cpi	r24, 0x02	; 2
    28cc:	31 f4       	brne	.+12     	; 0x28da <prvCopyDataToQueue+0x12e>
		{
			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    28ce:	89 81       	ldd	r24, Y+1	; 0x01
    28d0:	88 23       	and	r24, r24
    28d2:	19 f0       	breq	.+6      	; 0x28da <prvCopyDataToQueue+0x12e>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--uxMessagesWaiting;
    28d4:	89 81       	ldd	r24, Y+1	; 0x01
    28d6:	81 50       	subi	r24, 0x01	; 1
    28d8:	89 83       	std	Y+1, r24	; 0x01
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    28da:	89 81       	ldd	r24, Y+1	; 0x01
    28dc:	8f 5f       	subi	r24, 0xFF	; 255
    28de:	eb 81       	ldd	r30, Y+3	; 0x03
    28e0:	fc 81       	ldd	r31, Y+4	; 0x04
    28e2:	82 8f       	std	Z+26, r24	; 0x1a

	return xReturn;
    28e4:	8a 81       	ldd	r24, Y+2	; 0x02
}
    28e6:	27 96       	adiw	r28, 0x07	; 7
    28e8:	0f b6       	in	r0, 0x3f	; 63
    28ea:	f8 94       	cli
    28ec:	de bf       	out	0x3e, r29	; 62
    28ee:	0f be       	out	0x3f, r0	; 63
    28f0:	cd bf       	out	0x3d, r28	; 61
    28f2:	cf 91       	pop	r28
    28f4:	df 91       	pop	r29
    28f6:	08 95       	ret

000028f8 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
    28f8:	df 93       	push	r29
    28fa:	cf 93       	push	r28
    28fc:	00 d0       	rcall	.+0      	; 0x28fe <prvCopyDataFromQueue+0x6>
    28fe:	00 d0       	rcall	.+0      	; 0x2900 <prvCopyDataFromQueue+0x8>
    2900:	cd b7       	in	r28, 0x3d	; 61
    2902:	de b7       	in	r29, 0x3e	; 62
    2904:	9a 83       	std	Y+2, r25	; 0x02
    2906:	89 83       	std	Y+1, r24	; 0x01
    2908:	7c 83       	std	Y+4, r23	; 0x04
    290a:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    290c:	e9 81       	ldd	r30, Y+1	; 0x01
    290e:	fa 81       	ldd	r31, Y+2	; 0x02
    2910:	84 8d       	ldd	r24, Z+28	; 0x1c
    2912:	88 23       	and	r24, r24
    2914:	89 f1       	breq	.+98     	; 0x2978 <prvCopyDataFromQueue+0x80>
	{
		pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize; /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    2916:	e9 81       	ldd	r30, Y+1	; 0x01
    2918:	fa 81       	ldd	r31, Y+2	; 0x02
    291a:	26 81       	ldd	r18, Z+6	; 0x06
    291c:	37 81       	ldd	r19, Z+7	; 0x07
    291e:	e9 81       	ldd	r30, Y+1	; 0x01
    2920:	fa 81       	ldd	r31, Y+2	; 0x02
    2922:	84 8d       	ldd	r24, Z+28	; 0x1c
    2924:	88 2f       	mov	r24, r24
    2926:	90 e0       	ldi	r25, 0x00	; 0
    2928:	82 0f       	add	r24, r18
    292a:	93 1f       	adc	r25, r19
    292c:	e9 81       	ldd	r30, Y+1	; 0x01
    292e:	fa 81       	ldd	r31, Y+2	; 0x02
    2930:	97 83       	std	Z+7, r25	; 0x07
    2932:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2934:	e9 81       	ldd	r30, Y+1	; 0x01
    2936:	fa 81       	ldd	r31, Y+2	; 0x02
    2938:	26 81       	ldd	r18, Z+6	; 0x06
    293a:	37 81       	ldd	r19, Z+7	; 0x07
    293c:	e9 81       	ldd	r30, Y+1	; 0x01
    293e:	fa 81       	ldd	r31, Y+2	; 0x02
    2940:	84 81       	ldd	r24, Z+4	; 0x04
    2942:	95 81       	ldd	r25, Z+5	; 0x05
    2944:	28 17       	cp	r18, r24
    2946:	39 07       	cpc	r19, r25
    2948:	40 f0       	brcs	.+16     	; 0x295a <prvCopyDataFromQueue+0x62>
		{
			pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    294a:	e9 81       	ldd	r30, Y+1	; 0x01
    294c:	fa 81       	ldd	r31, Y+2	; 0x02
    294e:	80 81       	ld	r24, Z
    2950:	91 81       	ldd	r25, Z+1	; 0x01
    2952:	e9 81       	ldd	r30, Y+1	; 0x01
    2954:	fa 81       	ldd	r31, Y+2	; 0x02
    2956:	97 83       	std	Z+7, r25	; 0x07
    2958:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    295a:	e9 81       	ldd	r30, Y+1	; 0x01
    295c:	fa 81       	ldd	r31, Y+2	; 0x02
    295e:	46 81       	ldd	r20, Z+6	; 0x06
    2960:	57 81       	ldd	r21, Z+7	; 0x07
    2962:	e9 81       	ldd	r30, Y+1	; 0x01
    2964:	fa 81       	ldd	r31, Y+2	; 0x02
    2966:	84 8d       	ldd	r24, Z+28	; 0x1c
    2968:	28 2f       	mov	r18, r24
    296a:	30 e0       	ldi	r19, 0x00	; 0
    296c:	8b 81       	ldd	r24, Y+3	; 0x03
    296e:	9c 81       	ldd	r25, Y+4	; 0x04
    2970:	ba 01       	movw	r22, r20
    2972:	a9 01       	movw	r20, r18
    2974:	0e 94 fe 2d 	call	0x5bfc	; 0x5bfc <memcpy>
	}
}
    2978:	0f 90       	pop	r0
    297a:	0f 90       	pop	r0
    297c:	0f 90       	pop	r0
    297e:	0f 90       	pop	r0
    2980:	cf 91       	pop	r28
    2982:	df 91       	pop	r29
    2984:	08 95       	ret

00002986 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    2986:	df 93       	push	r29
    2988:	cf 93       	push	r28
    298a:	00 d0       	rcall	.+0      	; 0x298c <prvUnlockQueue+0x6>
    298c:	00 d0       	rcall	.+0      	; 0x298e <prvUnlockQueue+0x8>
    298e:	cd b7       	in	r28, 0x3d	; 61
    2990:	de b7       	in	r29, 0x3e	; 62
    2992:	9c 83       	std	Y+4, r25	; 0x04
    2994:	8b 83       	std	Y+3, r24	; 0x03

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2996:	0f b6       	in	r0, 0x3f	; 63
    2998:	f8 94       	cli
    299a:	0f 92       	push	r0
	{
		int8_t cTxLock = pxQueue->cTxLock;
    299c:	eb 81       	ldd	r30, Y+3	; 0x03
    299e:	fc 81       	ldd	r31, Y+4	; 0x04
    29a0:	86 8d       	ldd	r24, Z+30	; 0x1e
    29a2:	8a 83       	std	Y+2, r24	; 0x02
    29a4:	11 c0       	rjmp	.+34     	; 0x29c8 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    29a6:	eb 81       	ldd	r30, Y+3	; 0x03
    29a8:	fc 81       	ldd	r31, Y+4	; 0x04
    29aa:	81 89       	ldd	r24, Z+17	; 0x11
    29ac:	88 23       	and	r24, r24
    29ae:	79 f0       	breq	.+30     	; 0x29ce <prvUnlockQueue+0x48>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    29b0:	8b 81       	ldd	r24, Y+3	; 0x03
    29b2:	9c 81       	ldd	r25, Y+4	; 0x04
    29b4:	41 96       	adiw	r24, 0x11	; 17
    29b6:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <xTaskRemoveFromEventList>
    29ba:	88 23       	and	r24, r24
    29bc:	11 f0       	breq	.+4      	; 0x29c2 <prvUnlockQueue+0x3c>
					{
						/* The task waiting has a higher priority so record that
						a context switch is required. */
						vTaskMissedYield();
    29be:	0e 94 4b 1f 	call	0x3e96	; 0x3e96 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
    29c2:	8a 81       	ldd	r24, Y+2	; 0x02
    29c4:	81 50       	subi	r24, 0x01	; 1
    29c6:	8a 83       	std	Y+2, r24	; 0x02
	taskENTER_CRITICAL();
	{
		int8_t cTxLock = pxQueue->cTxLock;

		/* See if data was added to the queue while it was locked. */
		while( cTxLock > queueLOCKED_UNMODIFIED )
    29c8:	8a 81       	ldd	r24, Y+2	; 0x02
    29ca:	18 16       	cp	r1, r24
    29cc:	64 f3       	brlt	.-40     	; 0x29a6 <prvUnlockQueue+0x20>
			#endif /* configUSE_QUEUE_SETS */

			--cTxLock;
		}

		pxQueue->cTxLock = queueUNLOCKED;
    29ce:	eb 81       	ldd	r30, Y+3	; 0x03
    29d0:	fc 81       	ldd	r31, Y+4	; 0x04
    29d2:	8f ef       	ldi	r24, 0xFF	; 255
    29d4:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    29d6:	0f 90       	pop	r0
    29d8:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    29da:	0f b6       	in	r0, 0x3f	; 63
    29dc:	f8 94       	cli
    29de:	0f 92       	push	r0
	{
		int8_t cRxLock = pxQueue->cRxLock;
    29e0:	eb 81       	ldd	r30, Y+3	; 0x03
    29e2:	fc 81       	ldd	r31, Y+4	; 0x04
    29e4:	85 8d       	ldd	r24, Z+29	; 0x1d
    29e6:	89 83       	std	Y+1, r24	; 0x01
    29e8:	11 c0       	rjmp	.+34     	; 0x2a0c <prvUnlockQueue+0x86>

		while( cRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    29ea:	eb 81       	ldd	r30, Y+3	; 0x03
    29ec:	fc 81       	ldd	r31, Y+4	; 0x04
    29ee:	80 85       	ldd	r24, Z+8	; 0x08
    29f0:	88 23       	and	r24, r24
    29f2:	79 f0       	breq	.+30     	; 0x2a12 <prvUnlockQueue+0x8c>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    29f4:	8b 81       	ldd	r24, Y+3	; 0x03
    29f6:	9c 81       	ldd	r25, Y+4	; 0x04
    29f8:	08 96       	adiw	r24, 0x08	; 8
    29fa:	0e 94 df 1d 	call	0x3bbe	; 0x3bbe <xTaskRemoveFromEventList>
    29fe:	88 23       	and	r24, r24
    2a00:	11 f0       	breq	.+4      	; 0x2a06 <prvUnlockQueue+0x80>
				{
					vTaskMissedYield();
    2a02:	0e 94 4b 1f 	call	0x3e96	; 0x3e96 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--cRxLock;
    2a06:	89 81       	ldd	r24, Y+1	; 0x01
    2a08:	81 50       	subi	r24, 0x01	; 1
    2a0a:	89 83       	std	Y+1, r24	; 0x01
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		int8_t cRxLock = pxQueue->cRxLock;

		while( cRxLock > queueLOCKED_UNMODIFIED )
    2a0c:	89 81       	ldd	r24, Y+1	; 0x01
    2a0e:	18 16       	cp	r1, r24
    2a10:	64 f3       	brlt	.-40     	; 0x29ea <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->cRxLock = queueUNLOCKED;
    2a12:	eb 81       	ldd	r30, Y+3	; 0x03
    2a14:	fc 81       	ldd	r31, Y+4	; 0x04
    2a16:	8f ef       	ldi	r24, 0xFF	; 255
    2a18:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    2a1a:	0f 90       	pop	r0
    2a1c:	0f be       	out	0x3f, r0	; 63
}
    2a1e:	0f 90       	pop	r0
    2a20:	0f 90       	pop	r0
    2a22:	0f 90       	pop	r0
    2a24:	0f 90       	pop	r0
    2a26:	cf 91       	pop	r28
    2a28:	df 91       	pop	r29
    2a2a:	08 95       	ret

00002a2c <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
    2a2c:	df 93       	push	r29
    2a2e:	cf 93       	push	r28
    2a30:	00 d0       	rcall	.+0      	; 0x2a32 <prvIsQueueEmpty+0x6>
    2a32:	0f 92       	push	r0
    2a34:	cd b7       	in	r28, 0x3d	; 61
    2a36:	de b7       	in	r29, 0x3e	; 62
    2a38:	9b 83       	std	Y+3, r25	; 0x03
    2a3a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2a3c:	0f b6       	in	r0, 0x3f	; 63
    2a3e:	f8 94       	cli
    2a40:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2a42:	ea 81       	ldd	r30, Y+2	; 0x02
    2a44:	fb 81       	ldd	r31, Y+3	; 0x03
    2a46:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a48:	88 23       	and	r24, r24
    2a4a:	19 f4       	brne	.+6      	; 0x2a52 <prvIsQueueEmpty+0x26>
		{
			xReturn = pdTRUE;
    2a4c:	81 e0       	ldi	r24, 0x01	; 1
    2a4e:	89 83       	std	Y+1, r24	; 0x01
    2a50:	01 c0       	rjmp	.+2      	; 0x2a54 <prvIsQueueEmpty+0x28>
		}
		else
		{
			xReturn = pdFALSE;
    2a52:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2a54:	0f 90       	pop	r0
    2a56:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2a58:	89 81       	ldd	r24, Y+1	; 0x01
}
    2a5a:	0f 90       	pop	r0
    2a5c:	0f 90       	pop	r0
    2a5e:	0f 90       	pop	r0
    2a60:	cf 91       	pop	r28
    2a62:	df 91       	pop	r29
    2a64:	08 95       	ret

00002a66 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    2a66:	df 93       	push	r29
    2a68:	cf 93       	push	r28
    2a6a:	00 d0       	rcall	.+0      	; 0x2a6c <xQueueIsQueueEmptyFromISR+0x6>
    2a6c:	00 d0       	rcall	.+0      	; 0x2a6e <xQueueIsQueueEmptyFromISR+0x8>
    2a6e:	0f 92       	push	r0
    2a70:	cd b7       	in	r28, 0x3d	; 61
    2a72:	de b7       	in	r29, 0x3e	; 62
    2a74:	9d 83       	std	Y+5, r25	; 0x05
    2a76:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2a78:	8c 81       	ldd	r24, Y+4	; 0x04
    2a7a:	9d 81       	ldd	r25, Y+5	; 0x05
    2a7c:	9a 83       	std	Y+2, r25	; 0x02
    2a7e:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    2a80:	e9 81       	ldd	r30, Y+1	; 0x01
    2a82:	fa 81       	ldd	r31, Y+2	; 0x02
    2a84:	82 8d       	ldd	r24, Z+26	; 0x1a
    2a86:	88 23       	and	r24, r24
    2a88:	19 f4       	brne	.+6      	; 0x2a90 <xQueueIsQueueEmptyFromISR+0x2a>
	{
		xReturn = pdTRUE;
    2a8a:	81 e0       	ldi	r24, 0x01	; 1
    2a8c:	8b 83       	std	Y+3, r24	; 0x03
    2a8e:	01 c0       	rjmp	.+2      	; 0x2a92 <xQueueIsQueueEmptyFromISR+0x2c>
	}
	else
	{
		xReturn = pdFALSE;
    2a90:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2a92:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2a94:	0f 90       	pop	r0
    2a96:	0f 90       	pop	r0
    2a98:	0f 90       	pop	r0
    2a9a:	0f 90       	pop	r0
    2a9c:	0f 90       	pop	r0
    2a9e:	cf 91       	pop	r28
    2aa0:	df 91       	pop	r29
    2aa2:	08 95       	ret

00002aa4 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
    2aa4:	df 93       	push	r29
    2aa6:	cf 93       	push	r28
    2aa8:	00 d0       	rcall	.+0      	; 0x2aaa <prvIsQueueFull+0x6>
    2aaa:	0f 92       	push	r0
    2aac:	cd b7       	in	r28, 0x3d	; 61
    2aae:	de b7       	in	r29, 0x3e	; 62
    2ab0:	9b 83       	std	Y+3, r25	; 0x03
    2ab2:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2ab4:	0f b6       	in	r0, 0x3f	; 63
    2ab6:	f8 94       	cli
    2ab8:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2aba:	ea 81       	ldd	r30, Y+2	; 0x02
    2abc:	fb 81       	ldd	r31, Y+3	; 0x03
    2abe:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ac0:	ea 81       	ldd	r30, Y+2	; 0x02
    2ac2:	fb 81       	ldd	r31, Y+3	; 0x03
    2ac4:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ac6:	98 17       	cp	r25, r24
    2ac8:	19 f4       	brne	.+6      	; 0x2ad0 <prvIsQueueFull+0x2c>
		{
			xReturn = pdTRUE;
    2aca:	81 e0       	ldi	r24, 0x01	; 1
    2acc:	89 83       	std	Y+1, r24	; 0x01
    2ace:	01 c0       	rjmp	.+2      	; 0x2ad2 <prvIsQueueFull+0x2e>
		}
		else
		{
			xReturn = pdFALSE;
    2ad0:	19 82       	std	Y+1, r1	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    2ad2:	0f 90       	pop	r0
    2ad4:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2ad6:	89 81       	ldd	r24, Y+1	; 0x01
}
    2ad8:	0f 90       	pop	r0
    2ada:	0f 90       	pop	r0
    2adc:	0f 90       	pop	r0
    2ade:	cf 91       	pop	r28
    2ae0:	df 91       	pop	r29
    2ae2:	08 95       	ret

00002ae4 <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    2ae4:	df 93       	push	r29
    2ae6:	cf 93       	push	r28
    2ae8:	00 d0       	rcall	.+0      	; 0x2aea <xQueueIsQueueFullFromISR+0x6>
    2aea:	00 d0       	rcall	.+0      	; 0x2aec <xQueueIsQueueFullFromISR+0x8>
    2aec:	0f 92       	push	r0
    2aee:	cd b7       	in	r28, 0x3d	; 61
    2af0:	de b7       	in	r29, 0x3e	; 62
    2af2:	9d 83       	std	Y+5, r25	; 0x05
    2af4:	8c 83       	std	Y+4, r24	; 0x04
BaseType_t xReturn;
Queue_t * const pxQueue = xQueue;
    2af6:	8c 81       	ldd	r24, Y+4	; 0x04
    2af8:	9d 81       	ldd	r25, Y+5	; 0x05
    2afa:	9a 83       	std	Y+2, r25	; 0x02
    2afc:	89 83       	std	Y+1, r24	; 0x01

	configASSERT( pxQueue );
	if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    2afe:	e9 81       	ldd	r30, Y+1	; 0x01
    2b00:	fa 81       	ldd	r31, Y+2	; 0x02
    2b02:	92 8d       	ldd	r25, Z+26	; 0x1a
    2b04:	e9 81       	ldd	r30, Y+1	; 0x01
    2b06:	fa 81       	ldd	r31, Y+2	; 0x02
    2b08:	83 8d       	ldd	r24, Z+27	; 0x1b
    2b0a:	98 17       	cp	r25, r24
    2b0c:	19 f4       	brne	.+6      	; 0x2b14 <xQueueIsQueueFullFromISR+0x30>
	{
		xReturn = pdTRUE;
    2b0e:	81 e0       	ldi	r24, 0x01	; 1
    2b10:	8b 83       	std	Y+3, r24	; 0x03
    2b12:	01 c0       	rjmp	.+2      	; 0x2b16 <xQueueIsQueueFullFromISR+0x32>
	}
	else
	{
		xReturn = pdFALSE;
    2b14:	1b 82       	std	Y+3, r1	; 0x03
	}

	return xReturn;
    2b16:	8b 81       	ldd	r24, Y+3	; 0x03
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    2b18:	0f 90       	pop	r0
    2b1a:	0f 90       	pop	r0
    2b1c:	0f 90       	pop	r0
    2b1e:	0f 90       	pop	r0
    2b20:	0f 90       	pop	r0
    2b22:	cf 91       	pop	r28
    2b24:	df 91       	pop	r29
    2b26:	08 95       	ret

00002b28 <xTaskCreate>:
							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
							const configSTACK_DEPTH_TYPE usStackDepth,
							void * const pvParameters,
							UBaseType_t uxPriority,
							TaskHandle_t * const pxCreatedTask )
	{
    2b28:	8f 92       	push	r8
    2b2a:	9f 92       	push	r9
    2b2c:	af 92       	push	r10
    2b2e:	bf 92       	push	r11
    2b30:	cf 92       	push	r12
    2b32:	df 92       	push	r13
    2b34:	ef 92       	push	r14
    2b36:	ff 92       	push	r15
    2b38:	0f 93       	push	r16
    2b3a:	1f 93       	push	r17
    2b3c:	df 93       	push	r29
    2b3e:	cf 93       	push	r28
    2b40:	cd b7       	in	r28, 0x3d	; 61
    2b42:	de b7       	in	r29, 0x3e	; 62
    2b44:	60 97       	sbiw	r28, 0x10	; 16
    2b46:	0f b6       	in	r0, 0x3f	; 63
    2b48:	f8 94       	cli
    2b4a:	de bf       	out	0x3e, r29	; 62
    2b4c:	0f be       	out	0x3f, r0	; 63
    2b4e:	cd bf       	out	0x3d, r28	; 61
    2b50:	9f 83       	std	Y+7, r25	; 0x07
    2b52:	8e 83       	std	Y+6, r24	; 0x06
    2b54:	79 87       	std	Y+9, r23	; 0x09
    2b56:	68 87       	std	Y+8, r22	; 0x08
    2b58:	5b 87       	std	Y+11, r21	; 0x0b
    2b5a:	4a 87       	std	Y+10, r20	; 0x0a
    2b5c:	3d 87       	std	Y+13, r19	; 0x0d
    2b5e:	2c 87       	std	Y+12, r18	; 0x0c
    2b60:	0e 87       	std	Y+14, r16	; 0x0e
    2b62:	f8 8a       	std	Y+16, r15	; 0x10
    2b64:	ef 86       	std	Y+15, r14	; 0x0f
		#else /* portSTACK_GROWTH */
		{
		StackType_t *pxStack;

			/* Allocate space for the stack used by the task being created. */
			pxStack = pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    2b66:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b68:	9b 85       	ldd	r25, Y+11	; 0x0b
    2b6a:	0e 94 ee 09 	call	0x13dc	; 0x13dc <pvPortMalloc>
    2b6e:	9a 83       	std	Y+2, r25	; 0x02
    2b70:	89 83       	std	Y+1, r24	; 0x01

			if( pxStack != NULL )
    2b72:	89 81       	ldd	r24, Y+1	; 0x01
    2b74:	9a 81       	ldd	r25, Y+2	; 0x02
    2b76:	00 97       	sbiw	r24, 0x00	; 0
    2b78:	b1 f0       	breq	.+44     	; 0x2ba6 <xTaskCreate+0x7e>
			{
				/* Allocate space for the TCB. */
				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    2b7a:	86 e2       	ldi	r24, 0x26	; 38
    2b7c:	90 e0       	ldi	r25, 0x00	; 0
    2b7e:	0e 94 ee 09 	call	0x13dc	; 0x13dc <pvPortMalloc>
    2b82:	9d 83       	std	Y+5, r25	; 0x05
    2b84:	8c 83       	std	Y+4, r24	; 0x04

				if( pxNewTCB != NULL )
    2b86:	8c 81       	ldd	r24, Y+4	; 0x04
    2b88:	9d 81       	ldd	r25, Y+5	; 0x05
    2b8a:	00 97       	sbiw	r24, 0x00	; 0
    2b8c:	39 f0       	breq	.+14     	; 0x2b9c <xTaskCreate+0x74>
				{
					/* Store the stack location in the TCB. */
					pxNewTCB->pxStack = pxStack;
    2b8e:	ec 81       	ldd	r30, Y+4	; 0x04
    2b90:	fd 81       	ldd	r31, Y+5	; 0x05
    2b92:	89 81       	ldd	r24, Y+1	; 0x01
    2b94:	9a 81       	ldd	r25, Y+2	; 0x02
    2b96:	90 8f       	std	Z+24, r25	; 0x18
    2b98:	87 8b       	std	Z+23, r24	; 0x17
    2b9a:	07 c0       	rjmp	.+14     	; 0x2baa <xTaskCreate+0x82>
				}
				else
				{
					/* The stack cannot be used as the TCB was not created.  Free
					it again. */
					vPortFree( pxStack );
    2b9c:	89 81       	ldd	r24, Y+1	; 0x01
    2b9e:	9a 81       	ldd	r25, Y+2	; 0x02
    2ba0:	0e 94 44 0a 	call	0x1488	; 0x1488 <vPortFree>
    2ba4:	02 c0       	rjmp	.+4      	; 0x2baa <xTaskCreate+0x82>
				}
			}
			else
			{
				pxNewTCB = NULL;
    2ba6:	1d 82       	std	Y+5, r1	; 0x05
    2ba8:	1c 82       	std	Y+4, r1	; 0x04
			}
		}
		#endif /* portSTACK_GROWTH */

		if( pxNewTCB != NULL )
    2baa:	8c 81       	ldd	r24, Y+4	; 0x04
    2bac:	9d 81       	ldd	r25, Y+5	; 0x05
    2bae:	00 97       	sbiw	r24, 0x00	; 0
    2bb0:	e9 f0       	breq	.+58     	; 0x2bec <xTaskCreate+0xc4>
				task was created dynamically in case it is later deleted. */
				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
			}
			#endif /* tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE */

			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
    2bb2:	8a 85       	ldd	r24, Y+10	; 0x0a
    2bb4:	9b 85       	ldd	r25, Y+11	; 0x0b
    2bb6:	9c 01       	movw	r18, r24
    2bb8:	40 e0       	ldi	r20, 0x00	; 0
    2bba:	50 e0       	ldi	r21, 0x00	; 0
    2bbc:	8e 81       	ldd	r24, Y+6	; 0x06
    2bbe:	9f 81       	ldd	r25, Y+7	; 0x07
    2bc0:	68 85       	ldd	r22, Y+8	; 0x08
    2bc2:	79 85       	ldd	r23, Y+9	; 0x09
    2bc4:	ec 85       	ldd	r30, Y+12	; 0x0c
    2bc6:	fd 85       	ldd	r31, Y+13	; 0x0d
    2bc8:	af 85       	ldd	r26, Y+15	; 0x0f
    2bca:	b8 89       	ldd	r27, Y+16	; 0x10
    2bcc:	ac 80       	ldd	r10, Y+4	; 0x04
    2bce:	bd 80       	ldd	r11, Y+5	; 0x05
    2bd0:	8f 01       	movw	r16, r30
    2bd2:	ee 84       	ldd	r14, Y+14	; 0x0e
    2bd4:	6d 01       	movw	r12, r26
    2bd6:	88 24       	eor	r8, r8
    2bd8:	99 24       	eor	r9, r9
    2bda:	0e 94 0c 16 	call	0x2c18	; 0x2c18 <prvInitialiseNewTask>
			prvAddNewTaskToReadyList( pxNewTCB );
    2bde:	8c 81       	ldd	r24, Y+4	; 0x04
    2be0:	9d 81       	ldd	r25, Y+5	; 0x05
    2be2:	0e 94 c8 16 	call	0x2d90	; 0x2d90 <prvAddNewTaskToReadyList>
			xReturn = pdPASS;
    2be6:	81 e0       	ldi	r24, 0x01	; 1
    2be8:	8b 83       	std	Y+3, r24	; 0x03
    2bea:	02 c0       	rjmp	.+4      	; 0x2bf0 <xTaskCreate+0xc8>
		}
		else
		{
			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2bec:	8f ef       	ldi	r24, 0xFF	; 255
    2bee:	8b 83       	std	Y+3, r24	; 0x03
		}

		return xReturn;
    2bf0:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2bf2:	60 96       	adiw	r28, 0x10	; 16
    2bf4:	0f b6       	in	r0, 0x3f	; 63
    2bf6:	f8 94       	cli
    2bf8:	de bf       	out	0x3e, r29	; 62
    2bfa:	0f be       	out	0x3f, r0	; 63
    2bfc:	cd bf       	out	0x3d, r28	; 61
    2bfe:	cf 91       	pop	r28
    2c00:	df 91       	pop	r29
    2c02:	1f 91       	pop	r17
    2c04:	0f 91       	pop	r16
    2c06:	ff 90       	pop	r15
    2c08:	ef 90       	pop	r14
    2c0a:	df 90       	pop	r13
    2c0c:	cf 90       	pop	r12
    2c0e:	bf 90       	pop	r11
    2c10:	af 90       	pop	r10
    2c12:	9f 90       	pop	r9
    2c14:	8f 90       	pop	r8
    2c16:	08 95       	ret

00002c18 <prvInitialiseNewTask>:
									void * const pvParameters,
									UBaseType_t uxPriority,
									TaskHandle_t * const pxCreatedTask,
									TCB_t *pxNewTCB,
									const MemoryRegion_t * const xRegions )
{
    2c18:	8f 92       	push	r8
    2c1a:	9f 92       	push	r9
    2c1c:	af 92       	push	r10
    2c1e:	bf 92       	push	r11
    2c20:	cf 92       	push	r12
    2c22:	df 92       	push	r13
    2c24:	ef 92       	push	r14
    2c26:	0f 93       	push	r16
    2c28:	1f 93       	push	r17
    2c2a:	df 93       	push	r29
    2c2c:	cf 93       	push	r28
    2c2e:	cd b7       	in	r28, 0x3d	; 61
    2c30:	de b7       	in	r29, 0x3e	; 62
    2c32:	64 97       	sbiw	r28, 0x14	; 20
    2c34:	0f b6       	in	r0, 0x3f	; 63
    2c36:	f8 94       	cli
    2c38:	de bf       	out	0x3e, r29	; 62
    2c3a:	0f be       	out	0x3f, r0	; 63
    2c3c:	cd bf       	out	0x3d, r28	; 61
    2c3e:	9d 83       	std	Y+5, r25	; 0x05
    2c40:	8c 83       	std	Y+4, r24	; 0x04
    2c42:	7f 83       	std	Y+7, r23	; 0x07
    2c44:	6e 83       	std	Y+6, r22	; 0x06
    2c46:	28 87       	std	Y+8, r18	; 0x08
    2c48:	39 87       	std	Y+9, r19	; 0x09
    2c4a:	4a 87       	std	Y+10, r20	; 0x0a
    2c4c:	5b 87       	std	Y+11, r21	; 0x0b
    2c4e:	1d 87       	std	Y+13, r17	; 0x0d
    2c50:	0c 87       	std	Y+12, r16	; 0x0c
    2c52:	ee 86       	std	Y+14, r14	; 0x0e
    2c54:	d8 8a       	std	Y+16, r13	; 0x10
    2c56:	cf 86       	std	Y+15, r12	; 0x0f
    2c58:	ba 8a       	std	Y+18, r11	; 0x12
    2c5a:	a9 8a       	std	Y+17, r10	; 0x11
    2c5c:	9c 8a       	std	Y+20, r9	; 0x14
    2c5e:	8b 8a       	std	Y+19, r8	; 0x13
	grows from high memory to low (as per the 80x86) or vice versa.
	portSTACK_GROWTH is used to make the result positive or negative as required
	by the port. */
	#if( portSTACK_GROWTH < 0 )
	{
		pxTopOfStack = &( pxNewTCB->pxStack[ ulStackDepth - ( uint32_t ) 1 ] );
    2c60:	e9 89       	ldd	r30, Y+17	; 0x11
    2c62:	fa 89       	ldd	r31, Y+18	; 0x12
    2c64:	27 89       	ldd	r18, Z+23	; 0x17
    2c66:	30 8d       	ldd	r19, Z+24	; 0x18
    2c68:	88 85       	ldd	r24, Y+8	; 0x08
    2c6a:	99 85       	ldd	r25, Y+9	; 0x09
    2c6c:	01 97       	sbiw	r24, 0x01	; 1
    2c6e:	82 0f       	add	r24, r18
    2c70:	93 1f       	adc	r25, r19
    2c72:	9b 83       	std	Y+3, r25	; 0x03
    2c74:	8a 83       	std	Y+2, r24	; 0x02
		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
	}
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
    2c76:	8e 81       	ldd	r24, Y+6	; 0x06
    2c78:	9f 81       	ldd	r25, Y+7	; 0x07
    2c7a:	00 97       	sbiw	r24, 0x00	; 0
    2c7c:	51 f1       	breq	.+84     	; 0x2cd2 <prvInitialiseNewTask+0xba>
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2c7e:	19 82       	std	Y+1, r1	; 0x01
    2c80:	21 c0       	rjmp	.+66     	; 0x2cc4 <prvInitialiseNewTask+0xac>
		{
			pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    2c82:	89 81       	ldd	r24, Y+1	; 0x01
    2c84:	48 2f       	mov	r20, r24
    2c86:	50 e0       	ldi	r21, 0x00	; 0
    2c88:	89 81       	ldd	r24, Y+1	; 0x01
    2c8a:	28 2f       	mov	r18, r24
    2c8c:	30 e0       	ldi	r19, 0x00	; 0
    2c8e:	8e 81       	ldd	r24, Y+6	; 0x06
    2c90:	9f 81       	ldd	r25, Y+7	; 0x07
    2c92:	fc 01       	movw	r30, r24
    2c94:	e2 0f       	add	r30, r18
    2c96:	f3 1f       	adc	r31, r19
    2c98:	20 81       	ld	r18, Z
    2c9a:	89 89       	ldd	r24, Y+17	; 0x11
    2c9c:	9a 89       	ldd	r25, Y+18	; 0x12
    2c9e:	84 0f       	add	r24, r20
    2ca0:	95 1f       	adc	r25, r21
    2ca2:	fc 01       	movw	r30, r24
    2ca4:	79 96       	adiw	r30, 0x19	; 25
    2ca6:	20 83       	st	Z, r18

			/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
			configMAX_TASK_NAME_LEN characters just in case the memory after the
			string is not accessible (extremely unlikely). */
			if( pcName[ x ] == ( char ) 0x00 )
    2ca8:	89 81       	ldd	r24, Y+1	; 0x01
    2caa:	28 2f       	mov	r18, r24
    2cac:	30 e0       	ldi	r19, 0x00	; 0
    2cae:	8e 81       	ldd	r24, Y+6	; 0x06
    2cb0:	9f 81       	ldd	r25, Y+7	; 0x07
    2cb2:	fc 01       	movw	r30, r24
    2cb4:	e2 0f       	add	r30, r18
    2cb6:	f3 1f       	adc	r31, r19
    2cb8:	80 81       	ld	r24, Z
    2cba:	88 23       	and	r24, r24
    2cbc:	31 f0       	breq	.+12     	; 0x2cca <prvInitialiseNewTask+0xb2>
	#endif /* portSTACK_GROWTH */

	/* Store the task name in the TCB. */
	if( pcName != NULL )
	{
		for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    2cbe:	89 81       	ldd	r24, Y+1	; 0x01
    2cc0:	8f 5f       	subi	r24, 0xFF	; 255
    2cc2:	89 83       	std	Y+1, r24	; 0x01
    2cc4:	89 81       	ldd	r24, Y+1	; 0x01
    2cc6:	88 30       	cpi	r24, 0x08	; 8
    2cc8:	e0 f2       	brcs	.-72     	; 0x2c82 <prvInitialiseNewTask+0x6a>
			}
		}

		/* Ensure the name string is terminated in the case that the string length
		was greater or equal to configMAX_TASK_NAME_LEN. */
		pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    2cca:	e9 89       	ldd	r30, Y+17	; 0x11
    2ccc:	fa 89       	ldd	r31, Y+18	; 0x12
    2cce:	10 a2       	std	Z+32, r1	; 0x20
    2cd0:	03 c0       	rjmp	.+6      	; 0x2cd8 <prvInitialiseNewTask+0xc0>
	}
	else
	{
		/* The task has not been given a name, so just ensure there is a NULL
		terminator when it is read out. */
		pxNewTCB->pcTaskName[ 0 ] = 0x00;
    2cd2:	e9 89       	ldd	r30, Y+17	; 0x11
    2cd4:	fa 89       	ldd	r31, Y+18	; 0x12
    2cd6:	11 8e       	std	Z+25, r1	; 0x19
	}

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    2cd8:	8e 85       	ldd	r24, Y+14	; 0x0e
    2cda:	85 30       	cpi	r24, 0x05	; 5
    2cdc:	10 f0       	brcs	.+4      	; 0x2ce2 <prvInitialiseNewTask+0xca>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    2cde:	84 e0       	ldi	r24, 0x04	; 4
    2ce0:	8e 87       	std	Y+14, r24	; 0x0e
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxNewTCB->uxPriority = uxPriority;
    2ce2:	e9 89       	ldd	r30, Y+17	; 0x11
    2ce4:	fa 89       	ldd	r31, Y+18	; 0x12
    2ce6:	8e 85       	ldd	r24, Y+14	; 0x0e
    2ce8:	86 8b       	std	Z+22, r24	; 0x16
		pxNewTCB->uxBasePriority = uxPriority;
		pxNewTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    2cea:	89 89       	ldd	r24, Y+17	; 0x11
    2cec:	9a 89       	ldd	r25, Y+18	; 0x12
    2cee:	02 96       	adiw	r24, 0x02	; 2
    2cf0:	0e 94 94 0a 	call	0x1528	; 0x1528 <vListInitialiseItem>
	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    2cf4:	89 89       	ldd	r24, Y+17	; 0x11
    2cf6:	9a 89       	ldd	r25, Y+18	; 0x12
    2cf8:	0c 96       	adiw	r24, 0x0c	; 12
    2cfa:	0e 94 94 0a 	call	0x1528	; 0x1528 <vListInitialiseItem>

	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    2cfe:	e9 89       	ldd	r30, Y+17	; 0x11
    2d00:	fa 89       	ldd	r31, Y+18	; 0x12
    2d02:	89 89       	ldd	r24, Y+17	; 0x11
    2d04:	9a 89       	ldd	r25, Y+18	; 0x12
    2d06:	91 87       	std	Z+9, r25	; 0x09
    2d08:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2d0a:	8e 85       	ldd	r24, Y+14	; 0x0e
    2d0c:	28 2f       	mov	r18, r24
    2d0e:	30 e0       	ldi	r19, 0x00	; 0
    2d10:	85 e0       	ldi	r24, 0x05	; 5
    2d12:	90 e0       	ldi	r25, 0x00	; 0
    2d14:	82 1b       	sub	r24, r18
    2d16:	93 0b       	sbc	r25, r19
    2d18:	e9 89       	ldd	r30, Y+17	; 0x11
    2d1a:	fa 89       	ldd	r31, Y+18	; 0x12
    2d1c:	95 87       	std	Z+13, r25	; 0x0d
    2d1e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    2d20:	e9 89       	ldd	r30, Y+17	; 0x11
    2d22:	fa 89       	ldd	r31, Y+18	; 0x12
    2d24:	89 89       	ldd	r24, Y+17	; 0x11
    2d26:	9a 89       	ldd	r25, Y+18	; 0x12
    2d28:	93 8b       	std	Z+19, r25	; 0x13
    2d2a:	82 8b       	std	Z+18, r24	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxNewTCB->ulNotifiedValue = 0;
    2d2c:	e9 89       	ldd	r30, Y+17	; 0x11
    2d2e:	fa 89       	ldd	r31, Y+18	; 0x12
    2d30:	11 a2       	std	Z+33, r1	; 0x21
    2d32:	12 a2       	std	Z+34, r1	; 0x22
    2d34:	13 a2       	std	Z+35, r1	; 0x23
    2d36:	14 a2       	std	Z+36, r1	; 0x24
		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    2d38:	e9 89       	ldd	r30, Y+17	; 0x11
    2d3a:	fa 89       	ldd	r31, Y+18	; 0x12
    2d3c:	15 a2       	std	Z+37, r1	; 0x25
			}
			#endif /* portSTACK_GROWTH */
		}
		#else /* portHAS_STACK_OVERFLOW_CHECKING */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    2d3e:	8a 81       	ldd	r24, Y+2	; 0x02
    2d40:	9b 81       	ldd	r25, Y+3	; 0x03
    2d42:	2c 81       	ldd	r18, Y+4	; 0x04
    2d44:	3d 81       	ldd	r19, Y+5	; 0x05
    2d46:	4c 85       	ldd	r20, Y+12	; 0x0c
    2d48:	5d 85       	ldd	r21, Y+13	; 0x0d
    2d4a:	b9 01       	movw	r22, r18
    2d4c:	0e 94 a0 0b 	call	0x1740	; 0x1740 <pxPortInitialiseStack>
    2d50:	e9 89       	ldd	r30, Y+17	; 0x11
    2d52:	fa 89       	ldd	r31, Y+18	; 0x12
    2d54:	91 83       	std	Z+1, r25	; 0x01
    2d56:	80 83       	st	Z, r24
		}
		#endif /* portHAS_STACK_OVERFLOW_CHECKING */
	}
	#endif /* portUSING_MPU_WRAPPERS */

	if( pxCreatedTask != NULL )
    2d58:	8f 85       	ldd	r24, Y+15	; 0x0f
    2d5a:	98 89       	ldd	r25, Y+16	; 0x10
    2d5c:	00 97       	sbiw	r24, 0x00	; 0
    2d5e:	31 f0       	breq	.+12     	; 0x2d6c <prvInitialiseNewTask+0x154>
	{
		/* Pass the handle out in an anonymous way.  The handle can be used to
		change the created task's priority, delete the created task, etc.*/
		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    2d60:	ef 85       	ldd	r30, Y+15	; 0x0f
    2d62:	f8 89       	ldd	r31, Y+16	; 0x10
    2d64:	89 89       	ldd	r24, Y+17	; 0x11
    2d66:	9a 89       	ldd	r25, Y+18	; 0x12
    2d68:	91 83       	std	Z+1, r25	; 0x01
    2d6a:	80 83       	st	Z, r24
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2d6c:	64 96       	adiw	r28, 0x14	; 20
    2d6e:	0f b6       	in	r0, 0x3f	; 63
    2d70:	f8 94       	cli
    2d72:	de bf       	out	0x3e, r29	; 62
    2d74:	0f be       	out	0x3f, r0	; 63
    2d76:	cd bf       	out	0x3d, r28	; 61
    2d78:	cf 91       	pop	r28
    2d7a:	df 91       	pop	r29
    2d7c:	1f 91       	pop	r17
    2d7e:	0f 91       	pop	r16
    2d80:	ef 90       	pop	r14
    2d82:	df 90       	pop	r13
    2d84:	cf 90       	pop	r12
    2d86:	bf 90       	pop	r11
    2d88:	af 90       	pop	r10
    2d8a:	9f 90       	pop	r9
    2d8c:	8f 90       	pop	r8
    2d8e:	08 95       	ret

00002d90 <prvAddNewTaskToReadyList>:
/*-----------------------------------------------------------*/

static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
{
    2d90:	df 93       	push	r29
    2d92:	cf 93       	push	r28
    2d94:	00 d0       	rcall	.+0      	; 0x2d96 <prvAddNewTaskToReadyList+0x6>
    2d96:	cd b7       	in	r28, 0x3d	; 61
    2d98:	de b7       	in	r29, 0x3e	; 62
    2d9a:	9a 83       	std	Y+2, r25	; 0x02
    2d9c:	89 83       	std	Y+1, r24	; 0x01
	/* Ensure interrupts don't access the task lists while the lists are being
	updated. */
	taskENTER_CRITICAL();
    2d9e:	0f b6       	in	r0, 0x3f	; 63
    2da0:	f8 94       	cli
    2da2:	0f 92       	push	r0
	{
		uxCurrentNumberOfTasks++;
    2da4:	80 91 7a 04 	lds	r24, 0x047A
    2da8:	8f 5f       	subi	r24, 0xFF	; 255
    2daa:	80 93 7a 04 	sts	0x047A, r24
		if( pxCurrentTCB == NULL )
    2dae:	80 91 77 04 	lds	r24, 0x0477
    2db2:	90 91 78 04 	lds	r25, 0x0478
    2db6:	00 97       	sbiw	r24, 0x00	; 0
    2db8:	69 f4       	brne	.+26     	; 0x2dd4 <prvAddNewTaskToReadyList+0x44>
		{
			/* There are no other tasks, or all the other tasks are in
			the suspended state - make this the current task. */
			pxCurrentTCB = pxNewTCB;
    2dba:	89 81       	ldd	r24, Y+1	; 0x01
    2dbc:	9a 81       	ldd	r25, Y+2	; 0x02
    2dbe:	90 93 78 04 	sts	0x0478, r25
    2dc2:	80 93 77 04 	sts	0x0477, r24

			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    2dc6:	80 91 7a 04 	lds	r24, 0x047A
    2dca:	81 30       	cpi	r24, 0x01	; 1
    2dcc:	b9 f4       	brne	.+46     	; 0x2dfc <prvAddNewTaskToReadyList+0x6c>
			{
				/* This is the first task to be created so do the preliminary
				initialisation required.  We will not recover if this call
				fails, but we will report the failure. */
				prvInitialiseTaskLists();
    2dce:	0e 94 5f 1f 	call	0x3ebe	; 0x3ebe <prvInitialiseTaskLists>
    2dd2:	14 c0       	rjmp	.+40     	; 0x2dfc <prvAddNewTaskToReadyList+0x6c>
		else
		{
			/* If the scheduler is not already running, make this task the
			current task if it is the highest priority task to be created
			so far. */
			if( xSchedulerRunning == pdFALSE )
    2dd4:	80 91 7e 04 	lds	r24, 0x047E
    2dd8:	88 23       	and	r24, r24
    2dda:	81 f4       	brne	.+32     	; 0x2dfc <prvAddNewTaskToReadyList+0x6c>
			{
				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    2ddc:	e0 91 77 04 	lds	r30, 0x0477
    2de0:	f0 91 78 04 	lds	r31, 0x0478
    2de4:	96 89       	ldd	r25, Z+22	; 0x16
    2de6:	e9 81       	ldd	r30, Y+1	; 0x01
    2de8:	fa 81       	ldd	r31, Y+2	; 0x02
    2dea:	86 89       	ldd	r24, Z+22	; 0x16
    2dec:	89 17       	cp	r24, r25
    2dee:	30 f0       	brcs	.+12     	; 0x2dfc <prvAddNewTaskToReadyList+0x6c>
				{
					pxCurrentTCB = pxNewTCB;
    2df0:	89 81       	ldd	r24, Y+1	; 0x01
    2df2:	9a 81       	ldd	r25, Y+2	; 0x02
    2df4:	90 93 78 04 	sts	0x0478, r25
    2df8:	80 93 77 04 	sts	0x0477, r24
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}

		uxTaskNumber++;
    2dfc:	80 91 83 04 	lds	r24, 0x0483
    2e00:	8f 5f       	subi	r24, 0xFF	; 255
    2e02:	80 93 83 04 	sts	0x0483, r24
			pxNewTCB->uxTCBNumber = uxTaskNumber;
		}
		#endif /* configUSE_TRACE_FACILITY */
		traceTASK_CREATE( pxNewTCB );

		prvAddTaskToReadyList( pxNewTCB );
    2e06:	e9 81       	ldd	r30, Y+1	; 0x01
    2e08:	fa 81       	ldd	r31, Y+2	; 0x02
    2e0a:	96 89       	ldd	r25, Z+22	; 0x16
    2e0c:	80 91 7d 04 	lds	r24, 0x047D
    2e10:	89 17       	cp	r24, r25
    2e12:	28 f4       	brcc	.+10     	; 0x2e1e <prvAddNewTaskToReadyList+0x8e>
    2e14:	e9 81       	ldd	r30, Y+1	; 0x01
    2e16:	fa 81       	ldd	r31, Y+2	; 0x02
    2e18:	86 89       	ldd	r24, Z+22	; 0x16
    2e1a:	80 93 7d 04 	sts	0x047D, r24
    2e1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2e20:	fa 81       	ldd	r31, Y+2	; 0x02
    2e22:	86 89       	ldd	r24, Z+22	; 0x16
    2e24:	28 2f       	mov	r18, r24
    2e26:	30 e0       	ldi	r19, 0x00	; 0
    2e28:	c9 01       	movw	r24, r18
    2e2a:	88 0f       	add	r24, r24
    2e2c:	99 1f       	adc	r25, r25
    2e2e:	88 0f       	add	r24, r24
    2e30:	99 1f       	adc	r25, r25
    2e32:	88 0f       	add	r24, r24
    2e34:	99 1f       	adc	r25, r25
    2e36:	82 0f       	add	r24, r18
    2e38:	93 1f       	adc	r25, r19
    2e3a:	ac 01       	movw	r20, r24
    2e3c:	47 57       	subi	r20, 0x77	; 119
    2e3e:	5b 4f       	sbci	r21, 0xFB	; 251
    2e40:	89 81       	ldd	r24, Y+1	; 0x01
    2e42:	9a 81       	ldd	r25, Y+2	; 0x02
    2e44:	9c 01       	movw	r18, r24
    2e46:	2e 5f       	subi	r18, 0xFE	; 254
    2e48:	3f 4f       	sbci	r19, 0xFF	; 255
    2e4a:	ca 01       	movw	r24, r20
    2e4c:	b9 01       	movw	r22, r18
    2e4e:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>

		portSETUP_TCB( pxNewTCB );
	}
	taskEXIT_CRITICAL();
    2e52:	0f 90       	pop	r0
    2e54:	0f be       	out	0x3f, r0	; 63

	if( xSchedulerRunning != pdFALSE )
    2e56:	80 91 7e 04 	lds	r24, 0x047E
    2e5a:	88 23       	and	r24, r24
    2e5c:	61 f0       	breq	.+24     	; 0x2e76 <prvAddNewTaskToReadyList+0xe6>
	{
		/* If the created task is of a higher priority than the current task
		then it should run now. */
		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    2e5e:	e0 91 77 04 	lds	r30, 0x0477
    2e62:	f0 91 78 04 	lds	r31, 0x0478
    2e66:	96 89       	ldd	r25, Z+22	; 0x16
    2e68:	e9 81       	ldd	r30, Y+1	; 0x01
    2e6a:	fa 81       	ldd	r31, Y+2	; 0x02
    2e6c:	86 89       	ldd	r24, Z+22	; 0x16
    2e6e:	98 17       	cp	r25, r24
    2e70:	10 f4       	brcc	.+4      	; 0x2e76 <prvAddNewTaskToReadyList+0xe6>
		{
			taskYIELD_IF_USING_PREEMPTION();
    2e72:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    2e76:	0f 90       	pop	r0
    2e78:	0f 90       	pop	r0
    2e7a:	cf 91       	pop	r28
    2e7c:	df 91       	pop	r29
    2e7e:	08 95       	ret

00002e80 <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( TaskHandle_t xTaskToDelete )
	{
    2e80:	df 93       	push	r29
    2e82:	cf 93       	push	r28
    2e84:	00 d0       	rcall	.+0      	; 0x2e86 <vTaskDelete+0x6>
    2e86:	00 d0       	rcall	.+0      	; 0x2e88 <vTaskDelete+0x8>
    2e88:	00 d0       	rcall	.+0      	; 0x2e8a <vTaskDelete+0xa>
    2e8a:	cd b7       	in	r28, 0x3d	; 61
    2e8c:	de b7       	in	r29, 0x3e	; 62
    2e8e:	9c 83       	std	Y+4, r25	; 0x04
    2e90:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    2e92:	0f b6       	in	r0, 0x3f	; 63
    2e94:	f8 94       	cli
    2e96:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the calling task that is
			being deleted. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    2e98:	8b 81       	ldd	r24, Y+3	; 0x03
    2e9a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e9c:	00 97       	sbiw	r24, 0x00	; 0
    2e9e:	39 f4       	brne	.+14     	; 0x2eae <vTaskDelete+0x2e>
    2ea0:	80 91 77 04 	lds	r24, 0x0477
    2ea4:	90 91 78 04 	lds	r25, 0x0478
    2ea8:	9e 83       	std	Y+6, r25	; 0x06
    2eaa:	8d 83       	std	Y+5, r24	; 0x05
    2eac:	04 c0       	rjmp	.+8      	; 0x2eb6 <vTaskDelete+0x36>
    2eae:	8b 81       	ldd	r24, Y+3	; 0x03
    2eb0:	9c 81       	ldd	r25, Y+4	; 0x04
    2eb2:	9e 83       	std	Y+6, r25	; 0x06
    2eb4:	8d 83       	std	Y+5, r24	; 0x05
    2eb6:	8d 81       	ldd	r24, Y+5	; 0x05
    2eb8:	9e 81       	ldd	r25, Y+6	; 0x06
    2eba:	9a 83       	std	Y+2, r25	; 0x02
    2ebc:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready/delayed list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    2ebe:	89 81       	ldd	r24, Y+1	; 0x01
    2ec0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ec2:	02 96       	adiw	r24, 0x02	; 2
    2ec4:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    2ec8:	e9 81       	ldd	r30, Y+1	; 0x01
    2eca:	fa 81       	ldd	r31, Y+2	; 0x02
    2ecc:	84 89       	ldd	r24, Z+20	; 0x14
    2ece:	95 89       	ldd	r25, Z+21	; 0x15
    2ed0:	00 97       	sbiw	r24, 0x00	; 0
    2ed2:	29 f0       	breq	.+10     	; 0x2ede <vTaskDelete+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    2ed4:	89 81       	ldd	r24, Y+1	; 0x01
    2ed6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ed8:	0c 96       	adiw	r24, 0x0c	; 12
    2eda:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>

			/* Increment the uxTaskNumber also so kernel aware debuggers can
			detect that the task lists need re-generating.  This is done before
			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
			not return. */
			uxTaskNumber++;
    2ede:	80 91 83 04 	lds	r24, 0x0483
    2ee2:	8f 5f       	subi	r24, 0xFF	; 255
    2ee4:	80 93 83 04 	sts	0x0483, r24

			if( pxTCB == pxCurrentTCB )
    2ee8:	20 91 77 04 	lds	r18, 0x0477
    2eec:	30 91 78 04 	lds	r19, 0x0478
    2ef0:	89 81       	ldd	r24, Y+1	; 0x01
    2ef2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ef4:	82 17       	cp	r24, r18
    2ef6:	93 07       	cpc	r25, r19
    2ef8:	81 f4       	brne	.+32     	; 0x2f1a <vTaskDelete+0x9a>
				/* A task is deleting itself.  This cannot complete within the
				task itself, as a context switch to another task is required.
				Place the task in the termination list.  The idle task will
				check the termination list and free up any memory allocated by
				the scheduler for the TCB and stack of the deleted task. */
				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    2efa:	89 81       	ldd	r24, Y+1	; 0x01
    2efc:	9a 81       	ldd	r25, Y+2	; 0x02
    2efe:	9c 01       	movw	r18, r24
    2f00:	2e 5f       	subi	r18, 0xFE	; 254
    2f02:	3f 4f       	sbci	r19, 0xFF	; 255
    2f04:	85 ed       	ldi	r24, 0xD5	; 213
    2f06:	94 e0       	ldi	r25, 0x04	; 4
    2f08:	b9 01       	movw	r22, r18
    2f0a:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>

				/* Increment the ucTasksDeleted variable so the idle task knows
				there is a task that has been deleted and that it should therefore
				check the xTasksWaitingTermination list. */
				++uxDeletedTasksWaitingCleanUp;
    2f0e:	80 91 79 04 	lds	r24, 0x0479
    2f12:	8f 5f       	subi	r24, 0xFF	; 255
    2f14:	80 93 79 04 	sts	0x0479, r24
    2f18:	0b c0       	rjmp	.+22     	; 0x2f30 <vTaskDelete+0xb0>
				required. */
				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
			}
			else
			{
				--uxCurrentNumberOfTasks;
    2f1a:	80 91 7a 04 	lds	r24, 0x047A
    2f1e:	81 50       	subi	r24, 0x01	; 1
    2f20:	80 93 7a 04 	sts	0x047A, r24
				traceTASK_DELETE( pxTCB );
				prvDeleteTCB( pxTCB );
    2f24:	89 81       	ldd	r24, Y+1	; 0x01
    2f26:	9a 81       	ldd	r25, Y+2	; 0x02
    2f28:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <prvDeleteTCB>

				/* Reset the next expected unblock time in case it referred to
				the task that has just been deleted. */
				prvResetNextTaskUnblockTime();
    2f2c:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <prvResetNextTaskUnblockTime>
			}
		}
		taskEXIT_CRITICAL();
    2f30:	0f 90       	pop	r0
    2f32:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if it is the currently running task that has just
		been deleted. */
		if( xSchedulerRunning != pdFALSE )
    2f34:	80 91 7e 04 	lds	r24, 0x047E
    2f38:	88 23       	and	r24, r24
    2f3a:	59 f0       	breq	.+22     	; 0x2f52 <vTaskDelete+0xd2>
		{
			if( pxTCB == pxCurrentTCB )
    2f3c:	20 91 77 04 	lds	r18, 0x0477
    2f40:	30 91 78 04 	lds	r19, 0x0478
    2f44:	89 81       	ldd	r24, Y+1	; 0x01
    2f46:	9a 81       	ldd	r25, Y+2	; 0x02
    2f48:	82 17       	cp	r24, r18
    2f4a:	93 07       	cpc	r25, r19
    2f4c:	11 f4       	brne	.+4      	; 0x2f52 <vTaskDelete+0xd2>
			{
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    2f4e:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
    2f52:	26 96       	adiw	r28, 0x06	; 6
    2f54:	0f b6       	in	r0, 0x3f	; 63
    2f56:	f8 94       	cli
    2f58:	de bf       	out	0x3e, r29	; 62
    2f5a:	0f be       	out	0x3f, r0	; 63
    2f5c:	cd bf       	out	0x3d, r28	; 61
    2f5e:	cf 91       	pop	r28
    2f60:	df 91       	pop	r29
    2f62:	08 95       	ret

00002f64 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    2f64:	df 93       	push	r29
    2f66:	cf 93       	push	r28
    2f68:	cd b7       	in	r28, 0x3d	; 61
    2f6a:	de b7       	in	r29, 0x3e	; 62
    2f6c:	2a 97       	sbiw	r28, 0x0a	; 10
    2f6e:	0f b6       	in	r0, 0x3f	; 63
    2f70:	f8 94       	cli
    2f72:	de bf       	out	0x3e, r29	; 62
    2f74:	0f be       	out	0x3f, r0	; 63
    2f76:	cd bf       	out	0x3d, r28	; 61
    2f78:	98 87       	std	Y+8, r25	; 0x08
    2f7a:	8f 83       	std	Y+7, r24	; 0x07
    2f7c:	7a 87       	std	Y+10, r23	; 0x0a
    2f7e:	69 87       	std	Y+9, r22	; 0x09
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
    2f80:	1b 82       	std	Y+3, r1	; 0x03

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    2f82:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    2f86:	80 91 7b 04 	lds	r24, 0x047B
    2f8a:	90 91 7c 04 	lds	r25, 0x047C
    2f8e:	9a 83       	std	Y+2, r25	; 0x02
    2f90:	89 83       	std	Y+1, r24	; 0x01

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    2f92:	ef 81       	ldd	r30, Y+7	; 0x07
    2f94:	f8 85       	ldd	r31, Y+8	; 0x08
    2f96:	20 81       	ld	r18, Z
    2f98:	31 81       	ldd	r19, Z+1	; 0x01
    2f9a:	89 85       	ldd	r24, Y+9	; 0x09
    2f9c:	9a 85       	ldd	r25, Y+10	; 0x0a
    2f9e:	82 0f       	add	r24, r18
    2fa0:	93 1f       	adc	r25, r19
    2fa2:	9e 83       	std	Y+6, r25	; 0x06
    2fa4:	8d 83       	std	Y+5, r24	; 0x05

			if( xConstTickCount < *pxPreviousWakeTime )
    2fa6:	ef 81       	ldd	r30, Y+7	; 0x07
    2fa8:	f8 85       	ldd	r31, Y+8	; 0x08
    2faa:	20 81       	ld	r18, Z
    2fac:	31 81       	ldd	r19, Z+1	; 0x01
    2fae:	89 81       	ldd	r24, Y+1	; 0x01
    2fb0:	9a 81       	ldd	r25, Y+2	; 0x02
    2fb2:	82 17       	cp	r24, r18
    2fb4:	93 07       	cpc	r25, r19
    2fb6:	98 f4       	brcc	.+38     	; 0x2fde <vTaskDelayUntil+0x7a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    2fb8:	ef 81       	ldd	r30, Y+7	; 0x07
    2fba:	f8 85       	ldd	r31, Y+8	; 0x08
    2fbc:	20 81       	ld	r18, Z
    2fbe:	31 81       	ldd	r19, Z+1	; 0x01
    2fc0:	8d 81       	ldd	r24, Y+5	; 0x05
    2fc2:	9e 81       	ldd	r25, Y+6	; 0x06
    2fc4:	82 17       	cp	r24, r18
    2fc6:	93 07       	cpc	r25, r19
    2fc8:	e0 f4       	brcc	.+56     	; 0x3002 <vTaskDelayUntil+0x9e>
    2fca:	2d 81       	ldd	r18, Y+5	; 0x05
    2fcc:	3e 81       	ldd	r19, Y+6	; 0x06
    2fce:	89 81       	ldd	r24, Y+1	; 0x01
    2fd0:	9a 81       	ldd	r25, Y+2	; 0x02
    2fd2:	82 17       	cp	r24, r18
    2fd4:	93 07       	cpc	r25, r19
    2fd6:	a8 f4       	brcc	.+42     	; 0x3002 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2fd8:	81 e0       	ldi	r24, 0x01	; 1
    2fda:	8b 83       	std	Y+3, r24	; 0x03
    2fdc:	12 c0       	rjmp	.+36     	; 0x3002 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    2fde:	ef 81       	ldd	r30, Y+7	; 0x07
    2fe0:	f8 85       	ldd	r31, Y+8	; 0x08
    2fe2:	20 81       	ld	r18, Z
    2fe4:	31 81       	ldd	r19, Z+1	; 0x01
    2fe6:	8d 81       	ldd	r24, Y+5	; 0x05
    2fe8:	9e 81       	ldd	r25, Y+6	; 0x06
    2fea:	82 17       	cp	r24, r18
    2fec:	93 07       	cpc	r25, r19
    2fee:	38 f0       	brcs	.+14     	; 0x2ffe <vTaskDelayUntil+0x9a>
    2ff0:	2d 81       	ldd	r18, Y+5	; 0x05
    2ff2:	3e 81       	ldd	r19, Y+6	; 0x06
    2ff4:	89 81       	ldd	r24, Y+1	; 0x01
    2ff6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ff8:	82 17       	cp	r24, r18
    2ffa:	93 07       	cpc	r25, r19
    2ffc:	10 f4       	brcc	.+4      	; 0x3002 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2ffe:	81 e0       	ldi	r24, 0x01	; 1
    3000:	8b 83       	std	Y+3, r24	; 0x03
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    3002:	ef 81       	ldd	r30, Y+7	; 0x07
    3004:	f8 85       	ldd	r31, Y+8	; 0x08
    3006:	8d 81       	ldd	r24, Y+5	; 0x05
    3008:	9e 81       	ldd	r25, Y+6	; 0x06
    300a:	91 83       	std	Z+1, r25	; 0x01
    300c:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    300e:	8b 81       	ldd	r24, Y+3	; 0x03
    3010:	88 23       	and	r24, r24
    3012:	49 f0       	breq	.+18     	; 0x3026 <vTaskDelayUntil+0xc2>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    3014:	8d 81       	ldd	r24, Y+5	; 0x05
    3016:	9e 81       	ldd	r25, Y+6	; 0x06
    3018:	29 81       	ldd	r18, Y+1	; 0x01
    301a:	3a 81       	ldd	r19, Y+2	; 0x02
    301c:	82 1b       	sub	r24, r18
    301e:	93 0b       	sbc	r25, r19
    3020:	60 e0       	ldi	r22, 0x00	; 0
    3022:	0e 94 3a 24 	call	0x4874	; 0x4874 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    3026:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
    302a:	8c 83       	std	Y+4, r24	; 0x04

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    302c:	8c 81       	ldd	r24, Y+4	; 0x04
    302e:	88 23       	and	r24, r24
    3030:	11 f4       	brne	.+4      	; 0x3036 <vTaskDelayUntil+0xd2>
		{
			portYIELD_WITHIN_API();
    3032:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3036:	2a 96       	adiw	r28, 0x0a	; 10
    3038:	0f b6       	in	r0, 0x3f	; 63
    303a:	f8 94       	cli
    303c:	de bf       	out	0x3e, r29	; 62
    303e:	0f be       	out	0x3f, r0	; 63
    3040:	cd bf       	out	0x3d, r28	; 61
    3042:	cf 91       	pop	r28
    3044:	df 91       	pop	r29
    3046:	08 95       	ret

00003048 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    3048:	df 93       	push	r29
    304a:	cf 93       	push	r28
    304c:	00 d0       	rcall	.+0      	; 0x304e <vTaskDelay+0x6>
    304e:	0f 92       	push	r0
    3050:	cd b7       	in	r28, 0x3d	; 61
    3052:	de b7       	in	r29, 0x3e	; 62
    3054:	9b 83       	std	Y+3, r25	; 0x03
    3056:	8a 83       	std	Y+2, r24	; 0x02
	BaseType_t xAlreadyYielded = pdFALSE;
    3058:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    305a:	8a 81       	ldd	r24, Y+2	; 0x02
    305c:	9b 81       	ldd	r25, Y+3	; 0x03
    305e:	00 97       	sbiw	r24, 0x00	; 0
    3060:	51 f0       	breq	.+20     	; 0x3076 <vTaskDelay+0x2e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    3062:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    3066:	8a 81       	ldd	r24, Y+2	; 0x02
    3068:	9b 81       	ldd	r25, Y+3	; 0x03
    306a:	60 e0       	ldi	r22, 0x00	; 0
    306c:	0e 94 3a 24 	call	0x4874	; 0x4874 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    3070:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
    3074:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    3076:	89 81       	ldd	r24, Y+1	; 0x01
    3078:	88 23       	and	r24, r24
    307a:	11 f4       	brne	.+4      	; 0x3080 <vTaskDelay+0x38>
		{
			portYIELD_WITHIN_API();
    307c:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    3080:	0f 90       	pop	r0
    3082:	0f 90       	pop	r0
    3084:	0f 90       	pop	r0
    3086:	cf 91       	pop	r28
    3088:	df 91       	pop	r29
    308a:	08 95       	ret

0000308c <uxTaskPriorityGet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGet( const TaskHandle_t xTask )
	{
    308c:	df 93       	push	r29
    308e:	cf 93       	push	r28
    3090:	cd b7       	in	r28, 0x3d	; 61
    3092:	de b7       	in	r29, 0x3e	; 62
    3094:	27 97       	sbiw	r28, 0x07	; 7
    3096:	0f b6       	in	r0, 0x3f	; 63
    3098:	f8 94       	cli
    309a:	de bf       	out	0x3e, r29	; 62
    309c:	0f be       	out	0x3f, r0	; 63
    309e:	cd bf       	out	0x3d, r28	; 61
    30a0:	9d 83       	std	Y+5, r25	; 0x05
    30a2:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t const *pxTCB;
	UBaseType_t uxReturn;

		taskENTER_CRITICAL();
    30a4:	0f b6       	in	r0, 0x3f	; 63
    30a6:	f8 94       	cli
    30a8:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the task
			that called uxTaskPriorityGet() that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    30aa:	8c 81       	ldd	r24, Y+4	; 0x04
    30ac:	9d 81       	ldd	r25, Y+5	; 0x05
    30ae:	00 97       	sbiw	r24, 0x00	; 0
    30b0:	39 f4       	brne	.+14     	; 0x30c0 <uxTaskPriorityGet+0x34>
    30b2:	80 91 77 04 	lds	r24, 0x0477
    30b6:	90 91 78 04 	lds	r25, 0x0478
    30ba:	9f 83       	std	Y+7, r25	; 0x07
    30bc:	8e 83       	std	Y+6, r24	; 0x06
    30be:	04 c0       	rjmp	.+8      	; 0x30c8 <uxTaskPriorityGet+0x3c>
    30c0:	8c 81       	ldd	r24, Y+4	; 0x04
    30c2:	9d 81       	ldd	r25, Y+5	; 0x05
    30c4:	9f 83       	std	Y+7, r25	; 0x07
    30c6:	8e 83       	std	Y+6, r24	; 0x06
    30c8:	8e 81       	ldd	r24, Y+6	; 0x06
    30ca:	9f 81       	ldd	r25, Y+7	; 0x07
    30cc:	9b 83       	std	Y+3, r25	; 0x03
    30ce:	8a 83       	std	Y+2, r24	; 0x02
			uxReturn = pxTCB->uxPriority;
    30d0:	ea 81       	ldd	r30, Y+2	; 0x02
    30d2:	fb 81       	ldd	r31, Y+3	; 0x03
    30d4:	86 89       	ldd	r24, Z+22	; 0x16
    30d6:	89 83       	std	Y+1, r24	; 0x01
		}
		taskEXIT_CRITICAL();
    30d8:	0f 90       	pop	r0
    30da:	0f be       	out	0x3f, r0	; 63

		return uxReturn;
    30dc:	89 81       	ldd	r24, Y+1	; 0x01
	}
    30de:	27 96       	adiw	r28, 0x07	; 7
    30e0:	0f b6       	in	r0, 0x3f	; 63
    30e2:	f8 94       	cli
    30e4:	de bf       	out	0x3e, r29	; 62
    30e6:	0f be       	out	0x3f, r0	; 63
    30e8:	cd bf       	out	0x3d, r28	; 61
    30ea:	cf 91       	pop	r28
    30ec:	df 91       	pop	r29
    30ee:	08 95       	ret

000030f0 <uxTaskPriorityGetFromISR>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_uxTaskPriorityGet == 1 )

	UBaseType_t uxTaskPriorityGetFromISR( const TaskHandle_t xTask )
	{
    30f0:	df 93       	push	r29
    30f2:	cf 93       	push	r28
    30f4:	cd b7       	in	r28, 0x3d	; 61
    30f6:	de b7       	in	r29, 0x3e	; 62
    30f8:	28 97       	sbiw	r28, 0x08	; 8
    30fa:	0f b6       	in	r0, 0x3f	; 63
    30fc:	f8 94       	cli
    30fe:	de bf       	out	0x3e, r29	; 62
    3100:	0f be       	out	0x3f, r0	; 63
    3102:	cd bf       	out	0x3d, r28	; 61
    3104:	9e 83       	std	Y+6, r25	; 0x06
    3106:	8d 83       	std	Y+5, r24	; 0x05
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
    3108:	19 82       	std	Y+1, r1	; 0x01
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being queried. */
			pxTCB = prvGetTCBFromHandle( xTask );
    310a:	8d 81       	ldd	r24, Y+5	; 0x05
    310c:	9e 81       	ldd	r25, Y+6	; 0x06
    310e:	00 97       	sbiw	r24, 0x00	; 0
    3110:	39 f4       	brne	.+14     	; 0x3120 <uxTaskPriorityGetFromISR+0x30>
    3112:	80 91 77 04 	lds	r24, 0x0477
    3116:	90 91 78 04 	lds	r25, 0x0478
    311a:	98 87       	std	Y+8, r25	; 0x08
    311c:	8f 83       	std	Y+7, r24	; 0x07
    311e:	04 c0       	rjmp	.+8      	; 0x3128 <uxTaskPriorityGetFromISR+0x38>
    3120:	8d 81       	ldd	r24, Y+5	; 0x05
    3122:	9e 81       	ldd	r25, Y+6	; 0x06
    3124:	98 87       	std	Y+8, r25	; 0x08
    3126:	8f 83       	std	Y+7, r24	; 0x07
    3128:	8f 81       	ldd	r24, Y+7	; 0x07
    312a:	98 85       	ldd	r25, Y+8	; 0x08
    312c:	9c 83       	std	Y+4, r25	; 0x04
    312e:	8b 83       	std	Y+3, r24	; 0x03
			uxReturn = pxTCB->uxPriority;
    3130:	eb 81       	ldd	r30, Y+3	; 0x03
    3132:	fc 81       	ldd	r31, Y+4	; 0x04
    3134:	86 89       	ldd	r24, Z+22	; 0x16
    3136:	8a 83       	std	Y+2, r24	; 0x02
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );

		return uxReturn;
    3138:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    313a:	28 96       	adiw	r28, 0x08	; 8
    313c:	0f b6       	in	r0, 0x3f	; 63
    313e:	f8 94       	cli
    3140:	de bf       	out	0x3e, r29	; 62
    3142:	0f be       	out	0x3f, r0	; 63
    3144:	cd bf       	out	0x3d, r28	; 61
    3146:	cf 91       	pop	r28
    3148:	df 91       	pop	r29
    314a:	08 95       	ret

0000314c <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
	{
    314c:	df 93       	push	r29
    314e:	cf 93       	push	r28
    3150:	cd b7       	in	r28, 0x3d	; 61
    3152:	de b7       	in	r29, 0x3e	; 62
    3154:	2a 97       	sbiw	r28, 0x0a	; 10
    3156:	0f b6       	in	r0, 0x3f	; 63
    3158:	f8 94       	cli
    315a:	de bf       	out	0x3e, r29	; 62
    315c:	0f be       	out	0x3f, r0	; 63
    315e:	cd bf       	out	0x3d, r28	; 61
    3160:	9f 83       	std	Y+7, r25	; 0x07
    3162:	8e 83       	std	Y+6, r24	; 0x06
    3164:	68 87       	std	Y+8, r22	; 0x08
	TCB_t *pxTCB;
	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
	BaseType_t xYieldRequired = pdFALSE;
    3166:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
    3168:	88 85       	ldd	r24, Y+8	; 0x08
    316a:	85 30       	cpi	r24, 0x05	; 5
    316c:	10 f0       	brcs	.+4      	; 0x3172 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
    316e:	84 e0       	ldi	r24, 0x04	; 4
    3170:	88 87       	std	Y+8, r24	; 0x08
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		taskENTER_CRITICAL();
    3172:	0f b6       	in	r0, 0x3f	; 63
    3174:	f8 94       	cli
    3176:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the priority of the calling
			task that is being changed. */
			pxTCB = prvGetTCBFromHandle( xTask );
    3178:	8e 81       	ldd	r24, Y+6	; 0x06
    317a:	9f 81       	ldd	r25, Y+7	; 0x07
    317c:	00 97       	sbiw	r24, 0x00	; 0
    317e:	39 f4       	brne	.+14     	; 0x318e <vTaskPrioritySet+0x42>
    3180:	80 91 77 04 	lds	r24, 0x0477
    3184:	90 91 78 04 	lds	r25, 0x0478
    3188:	9a 87       	std	Y+10, r25	; 0x0a
    318a:	89 87       	std	Y+9, r24	; 0x09
    318c:	04 c0       	rjmp	.+8      	; 0x3196 <vTaskPrioritySet+0x4a>
    318e:	8e 81       	ldd	r24, Y+6	; 0x06
    3190:	9f 81       	ldd	r25, Y+7	; 0x07
    3192:	9a 87       	std	Y+10, r25	; 0x0a
    3194:	89 87       	std	Y+9, r24	; 0x09
    3196:	89 85       	ldd	r24, Y+9	; 0x09
    3198:	9a 85       	ldd	r25, Y+10	; 0x0a
    319a:	9d 83       	std	Y+5, r25	; 0x05
    319c:	8c 83       	std	Y+4, r24	; 0x04
			{
				uxCurrentBasePriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentBasePriority = pxTCB->uxPriority;
    319e:	ec 81       	ldd	r30, Y+4	; 0x04
    31a0:	fd 81       	ldd	r31, Y+5	; 0x05
    31a2:	86 89       	ldd	r24, Z+22	; 0x16
    31a4:	8b 83       	std	Y+3, r24	; 0x03
			}
			#endif

			if( uxCurrentBasePriority != uxNewPriority )
    31a6:	9b 81       	ldd	r25, Y+3	; 0x03
    31a8:	88 85       	ldd	r24, Y+8	; 0x08
    31aa:	98 17       	cp	r25, r24
    31ac:	09 f4       	brne	.+2      	; 0x31b0 <vTaskPrioritySet+0x64>
    31ae:	81 c0       	rjmp	.+258    	; 0x32b2 <vTaskPrioritySet+0x166>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentBasePriority )
    31b0:	98 85       	ldd	r25, Y+8	; 0x08
    31b2:	8b 81       	ldd	r24, Y+3	; 0x03
    31b4:	89 17       	cp	r24, r25
    31b6:	a0 f4       	brcc	.+40     	; 0x31e0 <vTaskPrioritySet+0x94>
				{
					if( pxTCB != pxCurrentTCB )
    31b8:	20 91 77 04 	lds	r18, 0x0477
    31bc:	30 91 78 04 	lds	r19, 0x0478
    31c0:	8c 81       	ldd	r24, Y+4	; 0x04
    31c2:	9d 81       	ldd	r25, Y+5	; 0x05
    31c4:	82 17       	cp	r24, r18
    31c6:	93 07       	cpc	r25, r19
    31c8:	b1 f0       	breq	.+44     	; 0x31f6 <vTaskPrioritySet+0xaa>
					{
						/* The priority of a task other than the currently
						running task is being raised.  Is the priority being
						raised above that of the running task? */
						if( uxNewPriority >= pxCurrentTCB->uxPriority )
    31ca:	e0 91 77 04 	lds	r30, 0x0477
    31ce:	f0 91 78 04 	lds	r31, 0x0478
    31d2:	96 89       	ldd	r25, Z+22	; 0x16
    31d4:	88 85       	ldd	r24, Y+8	; 0x08
    31d6:	89 17       	cp	r24, r25
    31d8:	70 f0       	brcs	.+28     	; 0x31f6 <vTaskPrioritySet+0xaa>
						{
							xYieldRequired = pdTRUE;
    31da:	81 e0       	ldi	r24, 0x01	; 1
    31dc:	89 83       	std	Y+1, r24	; 0x01
    31de:	0b c0       	rjmp	.+22     	; 0x31f6 <vTaskPrioritySet+0xaa>
						/* The priority of the running task is being raised,
						but the running task must already be the highest
						priority task able to run so no yield is required. */
					}
				}
				else if( pxTCB == pxCurrentTCB )
    31e0:	20 91 77 04 	lds	r18, 0x0477
    31e4:	30 91 78 04 	lds	r19, 0x0478
    31e8:	8c 81       	ldd	r24, Y+4	; 0x04
    31ea:	9d 81       	ldd	r25, Y+5	; 0x05
    31ec:	82 17       	cp	r24, r18
    31ee:	93 07       	cpc	r25, r19
    31f0:	11 f4       	brne	.+4      	; 0x31f6 <vTaskPrioritySet+0xaa>
				{
					/* Setting the priority of the running task down means
					there may now be another task of higher priority that
					is ready to execute. */
					xYieldRequired = pdTRUE;
    31f2:	81 e0       	ldi	r24, 0x01	; 1
    31f4:	89 83       	std	Y+1, r24	; 0x01
				}

				/* Remember the ready list the task might be referenced from
				before its uxPriority member is changed so the
				taskRESET_READY_PRIORITY() macro can function correctly. */
				uxPriorityUsedOnEntry = pxTCB->uxPriority;
    31f6:	ec 81       	ldd	r30, Y+4	; 0x04
    31f8:	fd 81       	ldd	r31, Y+5	; 0x05
    31fa:	86 89       	ldd	r24, Z+22	; 0x16
    31fc:	8a 83       	std	Y+2, r24	; 0x02
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    31fe:	ec 81       	ldd	r30, Y+4	; 0x04
    3200:	fd 81       	ldd	r31, Y+5	; 0x05
    3202:	88 85       	ldd	r24, Y+8	; 0x08
    3204:	86 8b       	std	Z+22, r24	; 0x16
				}
				#endif

				/* Only reset the event list item value if the value is not
				being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    3206:	ec 81       	ldd	r30, Y+4	; 0x04
    3208:	fd 81       	ldd	r31, Y+5	; 0x05
    320a:	84 85       	ldd	r24, Z+12	; 0x0c
    320c:	95 85       	ldd	r25, Z+13	; 0x0d
    320e:	99 23       	and	r25, r25
    3210:	5c f0       	brlt	.+22     	; 0x3228 <vTaskPrioritySet+0xdc>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3212:	88 85       	ldd	r24, Y+8	; 0x08
    3214:	28 2f       	mov	r18, r24
    3216:	30 e0       	ldi	r19, 0x00	; 0
    3218:	85 e0       	ldi	r24, 0x05	; 5
    321a:	90 e0       	ldi	r25, 0x00	; 0
    321c:	82 1b       	sub	r24, r18
    321e:	93 0b       	sbc	r25, r19
    3220:	ec 81       	ldd	r30, Y+4	; 0x04
    3222:	fd 81       	ldd	r31, Y+5	; 0x05
    3224:	95 87       	std	Z+13, r25	; 0x0d
    3226:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change its priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the list appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
    3228:	ec 81       	ldd	r30, Y+4	; 0x04
    322a:	fd 81       	ldd	r31, Y+5	; 0x05
    322c:	42 85       	ldd	r20, Z+10	; 0x0a
    322e:	53 85       	ldd	r21, Z+11	; 0x0b
    3230:	8a 81       	ldd	r24, Y+2	; 0x02
    3232:	28 2f       	mov	r18, r24
    3234:	30 e0       	ldi	r19, 0x00	; 0
    3236:	c9 01       	movw	r24, r18
    3238:	88 0f       	add	r24, r24
    323a:	99 1f       	adc	r25, r25
    323c:	88 0f       	add	r24, r24
    323e:	99 1f       	adc	r25, r25
    3240:	88 0f       	add	r24, r24
    3242:	99 1f       	adc	r25, r25
    3244:	82 0f       	add	r24, r18
    3246:	93 1f       	adc	r25, r19
    3248:	87 57       	subi	r24, 0x77	; 119
    324a:	9b 4f       	sbci	r25, 0xFB	; 251
    324c:	48 17       	cp	r20, r24
    324e:	59 07       	cpc	r21, r25
    3250:	59 f5       	brne	.+86     	; 0x32a8 <vTaskPrioritySet+0x15c>
				{
					/* The task is currently in its ready list - remove before
					adding it to it's new ready list.  As we are in a critical
					section we can do this even if the scheduler is suspended. */
					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3252:	8c 81       	ldd	r24, Y+4	; 0x04
    3254:	9d 81       	ldd	r25, Y+5	; 0x05
    3256:	02 96       	adiw	r24, 0x02	; 2
    3258:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					prvAddTaskToReadyList( pxTCB );
    325c:	ec 81       	ldd	r30, Y+4	; 0x04
    325e:	fd 81       	ldd	r31, Y+5	; 0x05
    3260:	96 89       	ldd	r25, Z+22	; 0x16
    3262:	80 91 7d 04 	lds	r24, 0x047D
    3266:	89 17       	cp	r24, r25
    3268:	28 f4       	brcc	.+10     	; 0x3274 <vTaskPrioritySet+0x128>
    326a:	ec 81       	ldd	r30, Y+4	; 0x04
    326c:	fd 81       	ldd	r31, Y+5	; 0x05
    326e:	86 89       	ldd	r24, Z+22	; 0x16
    3270:	80 93 7d 04 	sts	0x047D, r24
    3274:	ec 81       	ldd	r30, Y+4	; 0x04
    3276:	fd 81       	ldd	r31, Y+5	; 0x05
    3278:	86 89       	ldd	r24, Z+22	; 0x16
    327a:	28 2f       	mov	r18, r24
    327c:	30 e0       	ldi	r19, 0x00	; 0
    327e:	c9 01       	movw	r24, r18
    3280:	88 0f       	add	r24, r24
    3282:	99 1f       	adc	r25, r25
    3284:	88 0f       	add	r24, r24
    3286:	99 1f       	adc	r25, r25
    3288:	88 0f       	add	r24, r24
    328a:	99 1f       	adc	r25, r25
    328c:	82 0f       	add	r24, r18
    328e:	93 1f       	adc	r25, r19
    3290:	ac 01       	movw	r20, r24
    3292:	47 57       	subi	r20, 0x77	; 119
    3294:	5b 4f       	sbci	r21, 0xFB	; 251
    3296:	8c 81       	ldd	r24, Y+4	; 0x04
    3298:	9d 81       	ldd	r25, Y+5	; 0x05
    329a:	9c 01       	movw	r18, r24
    329c:	2e 5f       	subi	r18, 0xFE	; 254
    329e:	3f 4f       	sbci	r19, 0xFF	; 255
    32a0:	ca 01       	movw	r24, r20
    32a2:	b9 01       	movw	r22, r18
    32a4:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldRequired != pdFALSE )
    32a8:	89 81       	ldd	r24, Y+1	; 0x01
    32aa:	88 23       	and	r24, r24
    32ac:	11 f0       	breq	.+4      	; 0x32b2 <vTaskPrioritySet+0x166>
				{
					taskYIELD_IF_USING_PREEMPTION();
    32ae:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
				/* Remove compiler warning about unused variables when the port
				optimised task selection is not being used. */
				( void ) uxPriorityUsedOnEntry;
			}
		}
		taskEXIT_CRITICAL();
    32b2:	0f 90       	pop	r0
    32b4:	0f be       	out	0x3f, r0	; 63
	}
    32b6:	2a 96       	adiw	r28, 0x0a	; 10
    32b8:	0f b6       	in	r0, 0x3f	; 63
    32ba:	f8 94       	cli
    32bc:	de bf       	out	0x3e, r29	; 62
    32be:	0f be       	out	0x3f, r0	; 63
    32c0:	cd bf       	out	0x3d, r28	; 61
    32c2:	cf 91       	pop	r28
    32c4:	df 91       	pop	r29
    32c6:	08 95       	ret

000032c8 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
	{
    32c8:	df 93       	push	r29
    32ca:	cf 93       	push	r28
    32cc:	00 d0       	rcall	.+0      	; 0x32ce <vTaskSuspend+0x6>
    32ce:	00 d0       	rcall	.+0      	; 0x32d0 <vTaskSuspend+0x8>
    32d0:	00 d0       	rcall	.+0      	; 0x32d2 <vTaskSuspend+0xa>
    32d2:	cd b7       	in	r28, 0x3d	; 61
    32d4:	de b7       	in	r29, 0x3e	; 62
    32d6:	9c 83       	std	Y+4, r25	; 0x04
    32d8:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t *pxTCB;

		taskENTER_CRITICAL();
    32da:	0f b6       	in	r0, 0x3f	; 63
    32dc:	f8 94       	cli
    32de:	0f 92       	push	r0
		{
			/* If null is passed in here then it is the running task that is
			being suspended. */
			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
    32e0:	8b 81       	ldd	r24, Y+3	; 0x03
    32e2:	9c 81       	ldd	r25, Y+4	; 0x04
    32e4:	00 97       	sbiw	r24, 0x00	; 0
    32e6:	39 f4       	brne	.+14     	; 0x32f6 <vTaskSuspend+0x2e>
    32e8:	80 91 77 04 	lds	r24, 0x0477
    32ec:	90 91 78 04 	lds	r25, 0x0478
    32f0:	9e 83       	std	Y+6, r25	; 0x06
    32f2:	8d 83       	std	Y+5, r24	; 0x05
    32f4:	04 c0       	rjmp	.+8      	; 0x32fe <vTaskSuspend+0x36>
    32f6:	8b 81       	ldd	r24, Y+3	; 0x03
    32f8:	9c 81       	ldd	r25, Y+4	; 0x04
    32fa:	9e 83       	std	Y+6, r25	; 0x06
    32fc:	8d 83       	std	Y+5, r24	; 0x05
    32fe:	8d 81       	ldd	r24, Y+5	; 0x05
    3300:	9e 81       	ldd	r25, Y+6	; 0x06
    3302:	9a 83       	std	Y+2, r25	; 0x02
    3304:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the
			suspended list. */
			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    3306:	89 81       	ldd	r24, Y+1	; 0x01
    3308:	9a 81       	ldd	r25, Y+2	; 0x02
    330a:	02 96       	adiw	r24, 0x02	; 2
    330c:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
			{
				mtCOVERAGE_TEST_MARKER();
			}

			/* Is the task waiting on an event also? */
			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    3310:	e9 81       	ldd	r30, Y+1	; 0x01
    3312:	fa 81       	ldd	r31, Y+2	; 0x02
    3314:	84 89       	ldd	r24, Z+20	; 0x14
    3316:	95 89       	ldd	r25, Z+21	; 0x15
    3318:	00 97       	sbiw	r24, 0x00	; 0
    331a:	29 f0       	breq	.+10     	; 0x3326 <vTaskSuspend+0x5e>
			{
				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    331c:	89 81       	ldd	r24, Y+1	; 0x01
    331e:	9a 81       	ldd	r25, Y+2	; 0x02
    3320:	0c 96       	adiw	r24, 0x0c	; 12
    3322:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
    3326:	89 81       	ldd	r24, Y+1	; 0x01
    3328:	9a 81       	ldd	r25, Y+2	; 0x02
    332a:	9c 01       	movw	r18, r24
    332c:	2e 5f       	subi	r18, 0xFE	; 254
    332e:	3f 4f       	sbci	r19, 0xFF	; 255
    3330:	8e ed       	ldi	r24, 0xDE	; 222
    3332:	94 e0       	ldi	r25, 0x04	; 4
    3334:	b9 01       	movw	r22, r18
    3336:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>

			#if( configUSE_TASK_NOTIFICATIONS == 1 )
			{
				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
    333a:	e9 81       	ldd	r30, Y+1	; 0x01
    333c:	fa 81       	ldd	r31, Y+2	; 0x02
    333e:	85 a1       	ldd	r24, Z+37	; 0x25
    3340:	81 30       	cpi	r24, 0x01	; 1
    3342:	19 f4       	brne	.+6      	; 0x334a <vTaskSuspend+0x82>
				{
					/* The task was blocked to wait for a notification, but is
					now suspended, so no notification was received. */
					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    3344:	e9 81       	ldd	r30, Y+1	; 0x01
    3346:	fa 81       	ldd	r31, Y+2	; 0x02
    3348:	15 a2       	std	Z+37, r1	; 0x25
				}
			}
			#endif
		}
		taskEXIT_CRITICAL();
    334a:	0f 90       	pop	r0
    334c:	0f be       	out	0x3f, r0	; 63

		if( xSchedulerRunning != pdFALSE )
    334e:	80 91 7e 04 	lds	r24, 0x047E
    3352:	88 23       	and	r24, r24
    3354:	39 f0       	breq	.+14     	; 0x3364 <vTaskSuspend+0x9c>
		{
			/* Reset the next expected unblock time in case it referred to the
			task that is now in the Suspended state. */
			taskENTER_CRITICAL();
    3356:	0f b6       	in	r0, 0x3f	; 63
    3358:	f8 94       	cli
    335a:	0f 92       	push	r0
			{
				prvResetNextTaskUnblockTime();
    335c:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <prvResetNextTaskUnblockTime>
			}
			taskEXIT_CRITICAL();
    3360:	0f 90       	pop	r0
    3362:	0f be       	out	0x3f, r0	; 63
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( pxTCB == pxCurrentTCB )
    3364:	20 91 77 04 	lds	r18, 0x0477
    3368:	30 91 78 04 	lds	r19, 0x0478
    336c:	89 81       	ldd	r24, Y+1	; 0x01
    336e:	9a 81       	ldd	r25, Y+2	; 0x02
    3370:	82 17       	cp	r24, r18
    3372:	93 07       	cpc	r25, r19
    3374:	a1 f4       	brne	.+40     	; 0x339e <vTaskSuspend+0xd6>
		{
			if( xSchedulerRunning != pdFALSE )
    3376:	80 91 7e 04 	lds	r24, 0x047E
    337a:	88 23       	and	r24, r24
    337c:	19 f0       	breq	.+6      	; 0x3384 <vTaskSuspend+0xbc>
			{
				/* The current task has just been suspended. */
				configASSERT( uxSchedulerSuspended == 0 );
				portYIELD_WITHIN_API();
    337e:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
    3382:	0d c0       	rjmp	.+26     	; 0x339e <vTaskSuspend+0xd6>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks ) /*lint !e931 Right has no side effect, just volatile. */
    3384:	90 91 de 04 	lds	r25, 0x04DE
    3388:	80 91 7a 04 	lds	r24, 0x047A
    338c:	98 17       	cp	r25, r24
    338e:	29 f4       	brne	.+10     	; 0x339a <vTaskSuspend+0xd2>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    3390:	10 92 78 04 	sts	0x0478, r1
    3394:	10 92 77 04 	sts	0x0477, r1
    3398:	02 c0       	rjmp	.+4      	; 0x339e <vTaskSuspend+0xd6>
				}
				else
				{
					vTaskSwitchContext();
    339a:	0e 94 20 1d 	call	0x3a40	; 0x3a40 <vTaskSwitchContext>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    339e:	26 96       	adiw	r28, 0x06	; 6
    33a0:	0f b6       	in	r0, 0x3f	; 63
    33a2:	f8 94       	cli
    33a4:	de bf       	out	0x3e, r29	; 62
    33a6:	0f be       	out	0x3f, r0	; 63
    33a8:	cd bf       	out	0x3d, r28	; 61
    33aa:	cf 91       	pop	r28
    33ac:	df 91       	pop	r29
    33ae:	08 95       	ret

000033b0 <prvTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
	{
    33b0:	df 93       	push	r29
    33b2:	cf 93       	push	r28
    33b4:	00 d0       	rcall	.+0      	; 0x33b6 <prvTaskIsTaskSuspended+0x6>
    33b6:	00 d0       	rcall	.+0      	; 0x33b8 <prvTaskIsTaskSuspended+0x8>
    33b8:	0f 92       	push	r0
    33ba:	cd b7       	in	r28, 0x3d	; 61
    33bc:	de b7       	in	r29, 0x3e	; 62
    33be:	9d 83       	std	Y+5, r25	; 0x05
    33c0:	8c 83       	std	Y+4, r24	; 0x04
	BaseType_t xReturn = pdFALSE;
    33c2:	1b 82       	std	Y+3, r1	; 0x03
	const TCB_t * const pxTCB = xTask;
    33c4:	8c 81       	ldd	r24, Y+4	; 0x04
    33c6:	9d 81       	ldd	r25, Y+5	; 0x05
    33c8:	9a 83       	std	Y+2, r25	; 0x02
    33ca:	89 83       	std	Y+1, r24	; 0x01

		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task being resumed actually in the suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
    33cc:	e9 81       	ldd	r30, Y+1	; 0x01
    33ce:	fa 81       	ldd	r31, Y+2	; 0x02
    33d0:	82 85       	ldd	r24, Z+10	; 0x0a
    33d2:	93 85       	ldd	r25, Z+11	; 0x0b
    33d4:	24 e0       	ldi	r18, 0x04	; 4
    33d6:	8e 3d       	cpi	r24, 0xDE	; 222
    33d8:	92 07       	cpc	r25, r18
    33da:	81 f4       	brne	.+32     	; 0x33fc <prvTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
    33dc:	e9 81       	ldd	r30, Y+1	; 0x01
    33de:	fa 81       	ldd	r31, Y+2	; 0x02
    33e0:	84 89       	ldd	r24, Z+20	; 0x14
    33e2:	95 89       	ldd	r25, Z+21	; 0x15
    33e4:	24 e0       	ldi	r18, 0x04	; 4
    33e6:	8c 3c       	cpi	r24, 0xCC	; 204
    33e8:	92 07       	cpc	r25, r18
    33ea:	41 f0       	breq	.+16     	; 0x33fc <prvTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the	Suspended
				state, or because is is blocked with no timeout? */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
    33ec:	e9 81       	ldd	r30, Y+1	; 0x01
    33ee:	fa 81       	ldd	r31, Y+2	; 0x02
    33f0:	84 89       	ldd	r24, Z+20	; 0x14
    33f2:	95 89       	ldd	r25, Z+21	; 0x15
    33f4:	00 97       	sbiw	r24, 0x00	; 0
    33f6:	11 f4       	brne	.+4      	; 0x33fc <prvTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    33f8:	81 e0       	ldi	r24, 0x01	; 1
    33fa:	8b 83       	std	Y+3, r24	; 0x03
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
    33fc:	8b 81       	ldd	r24, Y+3	; 0x03
	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
    33fe:	0f 90       	pop	r0
    3400:	0f 90       	pop	r0
    3402:	0f 90       	pop	r0
    3404:	0f 90       	pop	r0
    3406:	0f 90       	pop	r0
    3408:	cf 91       	pop	r28
    340a:	df 91       	pop	r29
    340c:	08 95       	ret

0000340e <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( TaskHandle_t xTaskToResume )
	{
    340e:	df 93       	push	r29
    3410:	cf 93       	push	r28
    3412:	00 d0       	rcall	.+0      	; 0x3414 <vTaskResume+0x6>
    3414:	00 d0       	rcall	.+0      	; 0x3416 <vTaskResume+0x8>
    3416:	cd b7       	in	r28, 0x3d	; 61
    3418:	de b7       	in	r29, 0x3e	; 62
    341a:	9c 83       	std	Y+4, r25	; 0x04
    341c:	8b 83       	std	Y+3, r24	; 0x03
	TCB_t * const pxTCB = xTaskToResume;
    341e:	8b 81       	ldd	r24, Y+3	; 0x03
    3420:	9c 81       	ldd	r25, Y+4	; 0x04
    3422:	9a 83       	std	Y+2, r25	; 0x02
    3424:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to resume the calling task. */
		configASSERT( xTaskToResume );

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != pxCurrentTCB ) && ( pxTCB != NULL ) )
    3426:	20 91 77 04 	lds	r18, 0x0477
    342a:	30 91 78 04 	lds	r19, 0x0478
    342e:	89 81       	ldd	r24, Y+1	; 0x01
    3430:	9a 81       	ldd	r25, Y+2	; 0x02
    3432:	82 17       	cp	r24, r18
    3434:	93 07       	cpc	r25, r19
    3436:	09 f4       	brne	.+2      	; 0x343a <vTaskResume+0x2c>
    3438:	47 c0       	rjmp	.+142    	; 0x34c8 <vTaskResume+0xba>
    343a:	89 81       	ldd	r24, Y+1	; 0x01
    343c:	9a 81       	ldd	r25, Y+2	; 0x02
    343e:	00 97       	sbiw	r24, 0x00	; 0
    3440:	09 f4       	brne	.+2      	; 0x3444 <vTaskResume+0x36>
    3442:	42 c0       	rjmp	.+132    	; 0x34c8 <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    3444:	0f b6       	in	r0, 0x3f	; 63
    3446:	f8 94       	cli
    3448:	0f 92       	push	r0
			{
				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    344a:	89 81       	ldd	r24, Y+1	; 0x01
    344c:	9a 81       	ldd	r25, Y+2	; 0x02
    344e:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <prvTaskIsTaskSuspended>
    3452:	88 23       	and	r24, r24
    3454:	b9 f1       	breq	.+110    	; 0x34c4 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* The ready list can be accessed even if the scheduler is
					suspended because this is inside a critical section. */
					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
    3456:	89 81       	ldd	r24, Y+1	; 0x01
    3458:	9a 81       	ldd	r25, Y+2	; 0x02
    345a:	02 96       	adiw	r24, 0x02	; 2
    345c:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3460:	e9 81       	ldd	r30, Y+1	; 0x01
    3462:	fa 81       	ldd	r31, Y+2	; 0x02
    3464:	96 89       	ldd	r25, Z+22	; 0x16
    3466:	80 91 7d 04 	lds	r24, 0x047D
    346a:	89 17       	cp	r24, r25
    346c:	28 f4       	brcc	.+10     	; 0x3478 <vTaskResume+0x6a>
    346e:	e9 81       	ldd	r30, Y+1	; 0x01
    3470:	fa 81       	ldd	r31, Y+2	; 0x02
    3472:	86 89       	ldd	r24, Z+22	; 0x16
    3474:	80 93 7d 04 	sts	0x047D, r24
    3478:	e9 81       	ldd	r30, Y+1	; 0x01
    347a:	fa 81       	ldd	r31, Y+2	; 0x02
    347c:	86 89       	ldd	r24, Z+22	; 0x16
    347e:	28 2f       	mov	r18, r24
    3480:	30 e0       	ldi	r19, 0x00	; 0
    3482:	c9 01       	movw	r24, r18
    3484:	88 0f       	add	r24, r24
    3486:	99 1f       	adc	r25, r25
    3488:	88 0f       	add	r24, r24
    348a:	99 1f       	adc	r25, r25
    348c:	88 0f       	add	r24, r24
    348e:	99 1f       	adc	r25, r25
    3490:	82 0f       	add	r24, r18
    3492:	93 1f       	adc	r25, r19
    3494:	ac 01       	movw	r20, r24
    3496:	47 57       	subi	r20, 0x77	; 119
    3498:	5b 4f       	sbci	r21, 0xFB	; 251
    349a:	89 81       	ldd	r24, Y+1	; 0x01
    349c:	9a 81       	ldd	r25, Y+2	; 0x02
    349e:	9c 01       	movw	r18, r24
    34a0:	2e 5f       	subi	r18, 0xFE	; 254
    34a2:	3f 4f       	sbci	r19, 0xFF	; 255
    34a4:	ca 01       	movw	r24, r20
    34a6:	b9 01       	movw	r22, r18
    34a8:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>

					/* A higher priority task may have just been resumed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    34ac:	e9 81       	ldd	r30, Y+1	; 0x01
    34ae:	fa 81       	ldd	r31, Y+2	; 0x02
    34b0:	96 89       	ldd	r25, Z+22	; 0x16
    34b2:	e0 91 77 04 	lds	r30, 0x0477
    34b6:	f0 91 78 04 	lds	r31, 0x0478
    34ba:	86 89       	ldd	r24, Z+22	; 0x16
    34bc:	98 17       	cp	r25, r24
    34be:	10 f0       	brcs	.+4      	; 0x34c4 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run,
						but will leave the lists in the correct state for the
						next yield. */
						taskYIELD_IF_USING_PREEMPTION();
    34c0:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}
			taskEXIT_CRITICAL();
    34c4:	0f 90       	pop	r0
    34c6:	0f be       	out	0x3f, r0	; 63
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    34c8:	0f 90       	pop	r0
    34ca:	0f 90       	pop	r0
    34cc:	0f 90       	pop	r0
    34ce:	0f 90       	pop	r0
    34d0:	cf 91       	pop	r28
    34d2:	df 91       	pop	r29
    34d4:	08 95       	ret

000034d6 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
	{
    34d6:	df 93       	push	r29
    34d8:	cf 93       	push	r28
    34da:	00 d0       	rcall	.+0      	; 0x34dc <xTaskResumeFromISR+0x6>
    34dc:	00 d0       	rcall	.+0      	; 0x34de <xTaskResumeFromISR+0x8>
    34de:	00 d0       	rcall	.+0      	; 0x34e0 <xTaskResumeFromISR+0xa>
    34e0:	cd b7       	in	r28, 0x3d	; 61
    34e2:	de b7       	in	r29, 0x3e	; 62
    34e4:	9e 83       	std	Y+6, r25	; 0x06
    34e6:	8d 83       	std	Y+5, r24	; 0x05
	BaseType_t xYieldRequired = pdFALSE;
    34e8:	1c 82       	std	Y+4, r1	; 0x04
	TCB_t * const pxTCB = xTaskToResume;
    34ea:	8d 81       	ldd	r24, Y+5	; 0x05
    34ec:	9e 81       	ldd	r25, Y+6	; 0x06
    34ee:	9b 83       	std	Y+3, r25	; 0x03
    34f0:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		https://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    34f2:	19 82       	std	Y+1, r1	; 0x01
		{
			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
    34f4:	8a 81       	ldd	r24, Y+2	; 0x02
    34f6:	9b 81       	ldd	r25, Y+3	; 0x03
    34f8:	0e 94 d8 19 	call	0x33b0	; 0x33b0 <prvTaskIsTaskSuspended>
    34fc:	88 23       	and	r24, r24
    34fe:	09 f4       	brne	.+2      	; 0x3502 <xTaskResumeFromISR+0x2c>
    3500:	46 c0       	rjmp	.+140    	; 0x358e <xTaskResumeFromISR+0xb8>
			{
				traceTASK_RESUME_FROM_ISR( pxTCB );

				/* Check the ready lists can be accessed. */
				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3502:	80 91 88 04 	lds	r24, 0x0488
    3506:	88 23       	and	r24, r24
    3508:	c1 f5       	brne	.+112    	; 0x357a <xTaskResumeFromISR+0xa4>
				{
					/* Ready lists can be accessed so move the task from the
					suspended list to the ready list directly. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    350a:	ea 81       	ldd	r30, Y+2	; 0x02
    350c:	fb 81       	ldd	r31, Y+3	; 0x03
    350e:	96 89       	ldd	r25, Z+22	; 0x16
    3510:	e0 91 77 04 	lds	r30, 0x0477
    3514:	f0 91 78 04 	lds	r31, 0x0478
    3518:	86 89       	ldd	r24, Z+22	; 0x16
    351a:	98 17       	cp	r25, r24
    351c:	10 f0       	brcs	.+4      	; 0x3522 <xTaskResumeFromISR+0x4c>
					{
						xYieldRequired = pdTRUE;
    351e:	81 e0       	ldi	r24, 0x01	; 1
    3520:	8c 83       	std	Y+4, r24	; 0x04
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3522:	8a 81       	ldd	r24, Y+2	; 0x02
    3524:	9b 81       	ldd	r25, Y+3	; 0x03
    3526:	02 96       	adiw	r24, 0x02	; 2
    3528:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    352c:	ea 81       	ldd	r30, Y+2	; 0x02
    352e:	fb 81       	ldd	r31, Y+3	; 0x03
    3530:	96 89       	ldd	r25, Z+22	; 0x16
    3532:	80 91 7d 04 	lds	r24, 0x047D
    3536:	89 17       	cp	r24, r25
    3538:	28 f4       	brcc	.+10     	; 0x3544 <xTaskResumeFromISR+0x6e>
    353a:	ea 81       	ldd	r30, Y+2	; 0x02
    353c:	fb 81       	ldd	r31, Y+3	; 0x03
    353e:	86 89       	ldd	r24, Z+22	; 0x16
    3540:	80 93 7d 04 	sts	0x047D, r24
    3544:	ea 81       	ldd	r30, Y+2	; 0x02
    3546:	fb 81       	ldd	r31, Y+3	; 0x03
    3548:	86 89       	ldd	r24, Z+22	; 0x16
    354a:	28 2f       	mov	r18, r24
    354c:	30 e0       	ldi	r19, 0x00	; 0
    354e:	c9 01       	movw	r24, r18
    3550:	88 0f       	add	r24, r24
    3552:	99 1f       	adc	r25, r25
    3554:	88 0f       	add	r24, r24
    3556:	99 1f       	adc	r25, r25
    3558:	88 0f       	add	r24, r24
    355a:	99 1f       	adc	r25, r25
    355c:	82 0f       	add	r24, r18
    355e:	93 1f       	adc	r25, r19
    3560:	ac 01       	movw	r20, r24
    3562:	47 57       	subi	r20, 0x77	; 119
    3564:	5b 4f       	sbci	r21, 0xFB	; 251
    3566:	8a 81       	ldd	r24, Y+2	; 0x02
    3568:	9b 81       	ldd	r25, Y+3	; 0x03
    356a:	9c 01       	movw	r18, r24
    356c:	2e 5f       	subi	r18, 0xFE	; 254
    356e:	3f 4f       	sbci	r19, 0xFF	; 255
    3570:	ca 01       	movw	r24, r20
    3572:	b9 01       	movw	r22, r18
    3574:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>
    3578:	0a c0       	rjmp	.+20     	; 0x358e <xTaskResumeFromISR+0xb8>
				else
				{
					/* The delayed or ready lists cannot be accessed so the task
					is held in the pending ready list until the scheduler is
					unsuspended. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    357a:	8a 81       	ldd	r24, Y+2	; 0x02
    357c:	9b 81       	ldd	r25, Y+3	; 0x03
    357e:	9c 01       	movw	r18, r24
    3580:	24 5f       	subi	r18, 0xF4	; 244
    3582:	3f 4f       	sbci	r19, 0xFF	; 255
    3584:	8c ec       	ldi	r24, 0xCC	; 204
    3586:	94 e0       	ldi	r25, 0x04	; 4
    3588:	b9 01       	movw	r22, r18
    358a:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xYieldRequired;
    358e:	8c 81       	ldd	r24, Y+4	; 0x04
	}
    3590:	26 96       	adiw	r28, 0x06	; 6
    3592:	0f b6       	in	r0, 0x3f	; 63
    3594:	f8 94       	cli
    3596:	de bf       	out	0x3e, r29	; 62
    3598:	0f be       	out	0x3f, r0	; 63
    359a:	cd bf       	out	0x3d, r28	; 61
    359c:	cf 91       	pop	r28
    359e:	df 91       	pop	r29
    35a0:	08 95       	ret

000035a2 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    35a2:	ef 92       	push	r14
    35a4:	ff 92       	push	r15
    35a6:	0f 93       	push	r16
    35a8:	df 93       	push	r29
    35aa:	cf 93       	push	r28
    35ac:	0f 92       	push	r0
    35ae:	cd b7       	in	r28, 0x3d	; 61
    35b0:	de b7       	in	r29, 0x3e	; 62
		}
	}
	#else
	{
		/* The Idle task is being created using dynamically allocated RAM. */
		xReturn = xTaskCreate(	prvIdleTask,
    35b2:	85 e5       	ldi	r24, 0x55	; 85
    35b4:	9f e1       	ldi	r25, 0x1F	; 31
    35b6:	2c e7       	ldi	r18, 0x7C	; 124
    35b8:	30 e0       	ldi	r19, 0x00	; 0
    35ba:	e6 e8       	ldi	r30, 0x86	; 134
    35bc:	f4 e0       	ldi	r31, 0x04	; 4
    35be:	b9 01       	movw	r22, r18
    35c0:	4a ef       	ldi	r20, 0xFA	; 250
    35c2:	50 e0       	ldi	r21, 0x00	; 0
    35c4:	20 e0       	ldi	r18, 0x00	; 0
    35c6:	30 e0       	ldi	r19, 0x00	; 0
    35c8:	00 e0       	ldi	r16, 0x00	; 0
    35ca:	7f 01       	movw	r14, r30
    35cc:	0e 94 94 15 	call	0x2b28	; 0x2b28 <xTaskCreate>
    35d0:	89 83       	std	Y+1, r24	; 0x01
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    35d2:	89 81       	ldd	r24, Y+1	; 0x01
    35d4:	81 30       	cpi	r24, 0x01	; 1
    35d6:	81 f4       	brne	.+32     	; 0x35f8 <vTaskStartScheduler+0x56>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    35d8:	f8 94       	cli
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
    35da:	8f ef       	ldi	r24, 0xFF	; 255
    35dc:	9f ef       	ldi	r25, 0xFF	; 255
    35de:	90 93 85 04 	sts	0x0485, r25
    35e2:	80 93 84 04 	sts	0x0484, r24
		xSchedulerRunning = pdTRUE;
    35e6:	81 e0       	ldi	r24, 0x01	; 1
    35e8:	80 93 7e 04 	sts	0x047E, r24
		xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    35ec:	10 92 7c 04 	sts	0x047C, r1
    35f0:	10 92 7b 04 	sts	0x047B, r1

		traceTASK_SWITCHED_IN();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    35f4:	0e 94 23 0d 	call	0x1a46	; 0x1a46 <xPortStartScheduler>
	}

	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
	meaning xIdleTaskHandle is not used anywhere else. */
	( void ) xIdleTaskHandle;
}
    35f8:	0f 90       	pop	r0
    35fa:	cf 91       	pop	r28
    35fc:	df 91       	pop	r29
    35fe:	0f 91       	pop	r16
    3600:	ff 90       	pop	r15
    3602:	ef 90       	pop	r14
    3604:	08 95       	ret

00003606 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    3606:	df 93       	push	r29
    3608:	cf 93       	push	r28
    360a:	cd b7       	in	r28, 0x3d	; 61
    360c:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    360e:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    3610:	10 92 7e 04 	sts	0x047E, r1
	vPortEndScheduler();
    3614:	0e 94 58 0d 	call	0x1ab0	; 0x1ab0 <vPortEndScheduler>
}
    3618:	cf 91       	pop	r28
    361a:	df 91       	pop	r29
    361c:	08 95       	ret

0000361e <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    361e:	df 93       	push	r29
    3620:	cf 93       	push	r28
    3622:	cd b7       	in	r28, 0x3d	; 61
    3624:	de b7       	in	r29, 0x3e	; 62
	do not otherwise exhibit real time behaviour. */
	portSOFTWARE_BARRIER();

	/* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
	is used to allow calls to vTaskSuspendAll() to nest. */
	++uxSchedulerSuspended;
    3626:	80 91 88 04 	lds	r24, 0x0488
    362a:	8f 5f       	subi	r24, 0xFF	; 255
    362c:	80 93 88 04 	sts	0x0488, r24

	/* Enforces ordering for ports and optimised compilers that may otherwise place
	the above increment elsewhere. */
	portMEMORY_BARRIER();
}
    3630:	cf 91       	pop	r28
    3632:	df 91       	pop	r29
    3634:	08 95       	ret

00003636 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    3636:	df 93       	push	r29
    3638:	cf 93       	push	r28
    363a:	00 d0       	rcall	.+0      	; 0x363c <xTaskResumeAll+0x6>
    363c:	00 d0       	rcall	.+0      	; 0x363e <xTaskResumeAll+0x8>
    363e:	0f 92       	push	r0
    3640:	cd b7       	in	r28, 0x3d	; 61
    3642:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB = NULL;
    3644:	1d 82       	std	Y+5, r1	; 0x05
    3646:	1c 82       	std	Y+4, r1	; 0x04
BaseType_t xAlreadyYielded = pdFALSE;
    3648:	1b 82       	std	Y+3, r1	; 0x03
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    364a:	0f b6       	in	r0, 0x3f	; 63
    364c:	f8 94       	cli
    364e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    3650:	80 91 88 04 	lds	r24, 0x0488
    3654:	81 50       	subi	r24, 0x01	; 1
    3656:	80 93 88 04 	sts	0x0488, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    365a:	80 91 88 04 	lds	r24, 0x0488
    365e:	88 23       	and	r24, r24
    3660:	09 f0       	breq	.+2      	; 0x3664 <xTaskResumeAll+0x2e>
    3662:	7c c0       	rjmp	.+248    	; 0x375c <xTaskResumeAll+0x126>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    3664:	80 91 7a 04 	lds	r24, 0x047A
    3668:	88 23       	and	r24, r24
    366a:	09 f4       	brne	.+2      	; 0x366e <xTaskResumeAll+0x38>
    366c:	77 c0       	rjmp	.+238    	; 0x375c <xTaskResumeAll+0x126>
    366e:	45 c0       	rjmp	.+138    	; 0x36fa <xTaskResumeAll+0xc4>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3670:	e0 91 d1 04 	lds	r30, 0x04D1
    3674:	f0 91 d2 04 	lds	r31, 0x04D2
    3678:	86 81       	ldd	r24, Z+6	; 0x06
    367a:	97 81       	ldd	r25, Z+7	; 0x07
    367c:	9d 83       	std	Y+5, r25	; 0x05
    367e:	8c 83       	std	Y+4, r24	; 0x04
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    3680:	8c 81       	ldd	r24, Y+4	; 0x04
    3682:	9d 81       	ldd	r25, Y+5	; 0x05
    3684:	0c 96       	adiw	r24, 0x0c	; 12
    3686:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    368a:	8c 81       	ldd	r24, Y+4	; 0x04
    368c:	9d 81       	ldd	r25, Y+5	; 0x05
    368e:	02 96       	adiw	r24, 0x02	; 2
    3690:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    3694:	ec 81       	ldd	r30, Y+4	; 0x04
    3696:	fd 81       	ldd	r31, Y+5	; 0x05
    3698:	96 89       	ldd	r25, Z+22	; 0x16
    369a:	80 91 7d 04 	lds	r24, 0x047D
    369e:	89 17       	cp	r24, r25
    36a0:	28 f4       	brcc	.+10     	; 0x36ac <xTaskResumeAll+0x76>
    36a2:	ec 81       	ldd	r30, Y+4	; 0x04
    36a4:	fd 81       	ldd	r31, Y+5	; 0x05
    36a6:	86 89       	ldd	r24, Z+22	; 0x16
    36a8:	80 93 7d 04 	sts	0x047D, r24
    36ac:	ec 81       	ldd	r30, Y+4	; 0x04
    36ae:	fd 81       	ldd	r31, Y+5	; 0x05
    36b0:	86 89       	ldd	r24, Z+22	; 0x16
    36b2:	28 2f       	mov	r18, r24
    36b4:	30 e0       	ldi	r19, 0x00	; 0
    36b6:	c9 01       	movw	r24, r18
    36b8:	88 0f       	add	r24, r24
    36ba:	99 1f       	adc	r25, r25
    36bc:	88 0f       	add	r24, r24
    36be:	99 1f       	adc	r25, r25
    36c0:	88 0f       	add	r24, r24
    36c2:	99 1f       	adc	r25, r25
    36c4:	82 0f       	add	r24, r18
    36c6:	93 1f       	adc	r25, r19
    36c8:	ac 01       	movw	r20, r24
    36ca:	47 57       	subi	r20, 0x77	; 119
    36cc:	5b 4f       	sbci	r21, 0xFB	; 251
    36ce:	8c 81       	ldd	r24, Y+4	; 0x04
    36d0:	9d 81       	ldd	r25, Y+5	; 0x05
    36d2:	9c 01       	movw	r18, r24
    36d4:	2e 5f       	subi	r18, 0xFE	; 254
    36d6:	3f 4f       	sbci	r19, 0xFF	; 255
    36d8:	ca 01       	movw	r24, r20
    36da:	b9 01       	movw	r22, r18
    36dc:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    36e0:	ec 81       	ldd	r30, Y+4	; 0x04
    36e2:	fd 81       	ldd	r31, Y+5	; 0x05
    36e4:	96 89       	ldd	r25, Z+22	; 0x16
    36e6:	e0 91 77 04 	lds	r30, 0x0477
    36ea:	f0 91 78 04 	lds	r31, 0x0478
    36ee:	86 89       	ldd	r24, Z+22	; 0x16
    36f0:	98 17       	cp	r25, r24
    36f2:	18 f0       	brcs	.+6      	; 0x36fa <xTaskResumeAll+0xc4>
					{
						xYieldPending = pdTRUE;
    36f4:	81 e0       	ldi	r24, 0x01	; 1
    36f6:	80 93 81 04 	sts	0x0481, r24
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    36fa:	80 91 cc 04 	lds	r24, 0x04CC
    36fe:	88 23       	and	r24, r24
    3700:	09 f0       	breq	.+2      	; 0x3704 <xTaskResumeAll+0xce>
    3702:	b6 cf       	rjmp	.-148    	; 0x3670 <xTaskResumeAll+0x3a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
    3704:	8c 81       	ldd	r24, Y+4	; 0x04
    3706:	9d 81       	ldd	r25, Y+5	; 0x05
    3708:	00 97       	sbiw	r24, 0x00	; 0
    370a:	11 f0       	breq	.+4      	; 0x3710 <xTaskResumeAll+0xda>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
    370c:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    3710:	80 91 7f 04 	lds	r24, 0x047F
    3714:	90 91 80 04 	lds	r25, 0x0480
    3718:	9a 83       	std	Y+2, r25	; 0x02
    371a:	89 83       	std	Y+1, r24	; 0x01

					if( xPendedCounts > ( TickType_t ) 0U )
    371c:	89 81       	ldd	r24, Y+1	; 0x01
    371e:	9a 81       	ldd	r25, Y+2	; 0x02
    3720:	00 97       	sbiw	r24, 0x00	; 0
    3722:	a1 f0       	breq	.+40     	; 0x374c <xTaskResumeAll+0x116>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
    3724:	0e 94 37 1c 	call	0x386e	; 0x386e <xTaskIncrementTick>
    3728:	88 23       	and	r24, r24
    372a:	19 f0       	breq	.+6      	; 0x3732 <xTaskResumeAll+0xfc>
							{
								xYieldPending = pdTRUE;
    372c:	81 e0       	ldi	r24, 0x01	; 1
    372e:	80 93 81 04 	sts	0x0481, r24
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--xPendedCounts;
    3732:	89 81       	ldd	r24, Y+1	; 0x01
    3734:	9a 81       	ldd	r25, Y+2	; 0x02
    3736:	01 97       	sbiw	r24, 0x01	; 1
    3738:	9a 83       	std	Y+2, r25	; 0x02
    373a:	89 83       	std	Y+1, r24	; 0x01
						} while( xPendedCounts > ( TickType_t ) 0U );
    373c:	89 81       	ldd	r24, Y+1	; 0x01
    373e:	9a 81       	ldd	r25, Y+2	; 0x02
    3740:	00 97       	sbiw	r24, 0x00	; 0
    3742:	81 f7       	brne	.-32     	; 0x3724 <xTaskResumeAll+0xee>

						xPendedTicks = 0;
    3744:	10 92 80 04 	sts	0x0480, r1
    3748:	10 92 7f 04 	sts	0x047F, r1
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
    374c:	80 91 81 04 	lds	r24, 0x0481
    3750:	88 23       	and	r24, r24
    3752:	21 f0       	breq	.+8      	; 0x375c <xTaskResumeAll+0x126>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    3754:	81 e0       	ldi	r24, 0x01	; 1
    3756:	8b 83       	std	Y+3, r24	; 0x03
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    3758:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    375c:	0f 90       	pop	r0
    375e:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    3760:	8b 81       	ldd	r24, Y+3	; 0x03
}
    3762:	0f 90       	pop	r0
    3764:	0f 90       	pop	r0
    3766:	0f 90       	pop	r0
    3768:	0f 90       	pop	r0
    376a:	0f 90       	pop	r0
    376c:	cf 91       	pop	r28
    376e:	df 91       	pop	r29
    3770:	08 95       	ret

00003772 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
    3772:	df 93       	push	r29
    3774:	cf 93       	push	r28
    3776:	00 d0       	rcall	.+0      	; 0x3778 <xTaskGetTickCount+0x6>
    3778:	cd b7       	in	r28, 0x3d	; 61
    377a:	de b7       	in	r29, 0x3e	; 62
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    377c:	0f b6       	in	r0, 0x3f	; 63
    377e:	f8 94       	cli
    3780:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    3782:	80 91 7b 04 	lds	r24, 0x047B
    3786:	90 91 7c 04 	lds	r25, 0x047C
    378a:	9a 83       	std	Y+2, r25	; 0x02
    378c:	89 83       	std	Y+1, r24	; 0x01
	}
	portTICK_TYPE_EXIT_CRITICAL();
    378e:	0f 90       	pop	r0
    3790:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    3792:	89 81       	ldd	r24, Y+1	; 0x01
    3794:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3796:	0f 90       	pop	r0
    3798:	0f 90       	pop	r0
    379a:	cf 91       	pop	r28
    379c:	df 91       	pop	r29
    379e:	08 95       	ret

000037a0 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCountFromISR( void )
{
    37a0:	df 93       	push	r29
    37a2:	cf 93       	push	r28
    37a4:	00 d0       	rcall	.+0      	; 0x37a6 <xTaskGetTickCountFromISR+0x6>
    37a6:	0f 92       	push	r0
    37a8:	cd b7       	in	r28, 0x3d	; 61
    37aa:	de b7       	in	r29, 0x3e	; 62
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: https://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    37ac:	19 82       	std	Y+1, r1	; 0x01
	{
		xReturn = xTickCount;
    37ae:	80 91 7b 04 	lds	r24, 0x047B
    37b2:	90 91 7c 04 	lds	r25, 0x047C
    37b6:	9b 83       	std	Y+3, r25	; 0x03
    37b8:	8a 83       	std	Y+2, r24	; 0x02
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    37ba:	8a 81       	ldd	r24, Y+2	; 0x02
    37bc:	9b 81       	ldd	r25, Y+3	; 0x03
}
    37be:	0f 90       	pop	r0
    37c0:	0f 90       	pop	r0
    37c2:	0f 90       	pop	r0
    37c4:	cf 91       	pop	r28
    37c6:	df 91       	pop	r29
    37c8:	08 95       	ret

000037ca <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    37ca:	df 93       	push	r29
    37cc:	cf 93       	push	r28
    37ce:	cd b7       	in	r28, 0x3d	; 61
    37d0:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	BaseType_t. */
	return uxCurrentNumberOfTasks;
    37d2:	80 91 7a 04 	lds	r24, 0x047A
}
    37d6:	cf 91       	pop	r28
    37d8:	df 91       	pop	r29
    37da:	08 95       	ret

000037dc <pcTaskGetName>:
/*-----------------------------------------------------------*/

char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    37dc:	df 93       	push	r29
    37de:	cf 93       	push	r28
    37e0:	00 d0       	rcall	.+0      	; 0x37e2 <pcTaskGetName+0x6>
    37e2:	00 d0       	rcall	.+0      	; 0x37e4 <pcTaskGetName+0x8>
    37e4:	00 d0       	rcall	.+0      	; 0x37e6 <pcTaskGetName+0xa>
    37e6:	cd b7       	in	r28, 0x3d	; 61
    37e8:	de b7       	in	r29, 0x3e	; 62
    37ea:	9c 83       	std	Y+4, r25	; 0x04
    37ec:	8b 83       	std	Y+3, r24	; 0x03
TCB_t *pxTCB;

	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    37ee:	8b 81       	ldd	r24, Y+3	; 0x03
    37f0:	9c 81       	ldd	r25, Y+4	; 0x04
    37f2:	00 97       	sbiw	r24, 0x00	; 0
    37f4:	39 f4       	brne	.+14     	; 0x3804 <pcTaskGetName+0x28>
    37f6:	80 91 77 04 	lds	r24, 0x0477
    37fa:	90 91 78 04 	lds	r25, 0x0478
    37fe:	9e 83       	std	Y+6, r25	; 0x06
    3800:	8d 83       	std	Y+5, r24	; 0x05
    3802:	04 c0       	rjmp	.+8      	; 0x380c <pcTaskGetName+0x30>
    3804:	8b 81       	ldd	r24, Y+3	; 0x03
    3806:	9c 81       	ldd	r25, Y+4	; 0x04
    3808:	9e 83       	std	Y+6, r25	; 0x06
    380a:	8d 83       	std	Y+5, r24	; 0x05
    380c:	8d 81       	ldd	r24, Y+5	; 0x05
    380e:	9e 81       	ldd	r25, Y+6	; 0x06
    3810:	9a 83       	std	Y+2, r25	; 0x02
    3812:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
    3814:	89 81       	ldd	r24, Y+1	; 0x01
    3816:	9a 81       	ldd	r25, Y+2	; 0x02
    3818:	49 96       	adiw	r24, 0x19	; 25
}
    381a:	26 96       	adiw	r28, 0x06	; 6
    381c:	0f b6       	in	r0, 0x3f	; 63
    381e:	f8 94       	cli
    3820:	de bf       	out	0x3e, r29	; 62
    3822:	0f be       	out	0x3f, r0	; 63
    3824:	cd bf       	out	0x3d, r28	; 61
    3826:	cf 91       	pop	r28
    3828:	df 91       	pop	r29
    382a:	08 95       	ret

0000382c <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    382c:	df 93       	push	r29
    382e:	cf 93       	push	r28
    3830:	00 d0       	rcall	.+0      	; 0x3832 <xTaskCatchUpTicks+0x6>
    3832:	0f 92       	push	r0
    3834:	cd b7       	in	r28, 0x3d	; 61
    3836:	de b7       	in	r29, 0x3e	; 62
    3838:	9b 83       	std	Y+3, r25	; 0x03
    383a:	8a 83       	std	Y+2, r24	; 0x02
BaseType_t xYieldRequired = pdFALSE;
    383c:	19 82       	std	Y+1, r1	; 0x01
	relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
	configASSERT( uxSchedulerSuspended == 0 );

	/* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
	the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
	vTaskSuspendAll();
    383e:	0e 94 0f 1b 	call	0x361e	; 0x361e <vTaskSuspendAll>
	xPendedTicks += xTicksToCatchUp;
    3842:	20 91 7f 04 	lds	r18, 0x047F
    3846:	30 91 80 04 	lds	r19, 0x0480
    384a:	8a 81       	ldd	r24, Y+2	; 0x02
    384c:	9b 81       	ldd	r25, Y+3	; 0x03
    384e:	82 0f       	add	r24, r18
    3850:	93 1f       	adc	r25, r19
    3852:	90 93 80 04 	sts	0x0480, r25
    3856:	80 93 7f 04 	sts	0x047F, r24
	xYieldRequired = xTaskResumeAll();
    385a:	0e 94 1b 1b 	call	0x3636	; 0x3636 <xTaskResumeAll>
    385e:	89 83       	std	Y+1, r24	; 0x01

	return xYieldRequired;
    3860:	89 81       	ldd	r24, Y+1	; 0x01
}
    3862:	0f 90       	pop	r0
    3864:	0f 90       	pop	r0
    3866:	0f 90       	pop	r0
    3868:	cf 91       	pop	r28
    386a:	df 91       	pop	r29
    386c:	08 95       	ret

0000386e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    386e:	df 93       	push	r29
    3870:	cf 93       	push	r28
    3872:	cd b7       	in	r28, 0x3d	; 61
    3874:	de b7       	in	r29, 0x3e	; 62
    3876:	29 97       	sbiw	r28, 0x09	; 9
    3878:	0f b6       	in	r0, 0x3f	; 63
    387a:	f8 94       	cli
    387c:	de bf       	out	0x3e, r29	; 62
    387e:	0f be       	out	0x3f, r0	; 63
    3880:	cd bf       	out	0x3d, r28	; 61
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    3882:	1d 82       	std	Y+5, r1	; 0x05

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3884:	80 91 88 04 	lds	r24, 0x0488
    3888:	88 23       	and	r24, r24
    388a:	09 f0       	breq	.+2      	; 0x388e <xTaskIncrementTick+0x20>
    388c:	c6 c0       	rjmp	.+396    	; 0x3a1a <xTaskIncrementTick+0x1ac>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    388e:	80 91 7b 04 	lds	r24, 0x047B
    3892:	90 91 7c 04 	lds	r25, 0x047C
    3896:	01 96       	adiw	r24, 0x01	; 1
    3898:	9c 83       	std	Y+4, r25	; 0x04
    389a:	8b 83       	std	Y+3, r24	; 0x03

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
    389c:	8b 81       	ldd	r24, Y+3	; 0x03
    389e:	9c 81       	ldd	r25, Y+4	; 0x04
    38a0:	90 93 7c 04 	sts	0x047C, r25
    38a4:	80 93 7b 04 	sts	0x047B, r24

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    38a8:	8b 81       	ldd	r24, Y+3	; 0x03
    38aa:	9c 81       	ldd	r25, Y+4	; 0x04
    38ac:	00 97       	sbiw	r24, 0x00	; 0
    38ae:	d9 f4       	brne	.+54     	; 0x38e6 <xTaskIncrementTick+0x78>
		{
			taskSWITCH_DELAYED_LISTS();
    38b0:	80 91 c8 04 	lds	r24, 0x04C8
    38b4:	90 91 c9 04 	lds	r25, 0x04C9
    38b8:	9a 83       	std	Y+2, r25	; 0x02
    38ba:	89 83       	std	Y+1, r24	; 0x01
    38bc:	80 91 ca 04 	lds	r24, 0x04CA
    38c0:	90 91 cb 04 	lds	r25, 0x04CB
    38c4:	90 93 c9 04 	sts	0x04C9, r25
    38c8:	80 93 c8 04 	sts	0x04C8, r24
    38cc:	89 81       	ldd	r24, Y+1	; 0x01
    38ce:	9a 81       	ldd	r25, Y+2	; 0x02
    38d0:	90 93 cb 04 	sts	0x04CB, r25
    38d4:	80 93 ca 04 	sts	0x04CA, r24
    38d8:	80 91 82 04 	lds	r24, 0x0482
    38dc:	8f 5f       	subi	r24, 0xFF	; 255
    38de:	80 93 82 04 	sts	0x0482, r24
    38e2:	0e 94 e5 1f 	call	0x3fca	; 0x3fca <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
    38e6:	20 91 84 04 	lds	r18, 0x0484
    38ea:	30 91 85 04 	lds	r19, 0x0485
    38ee:	8b 81       	ldd	r24, Y+3	; 0x03
    38f0:	9c 81       	ldd	r25, Y+4	; 0x04
    38f2:	82 17       	cp	r24, r18
    38f4:	93 07       	cpc	r25, r19
    38f6:	08 f4       	brcc	.+2      	; 0x38fa <xTaskIncrementTick+0x8c>
    38f8:	71 c0       	rjmp	.+226    	; 0x39dc <xTaskIncrementTick+0x16e>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    38fa:	e0 91 c8 04 	lds	r30, 0x04C8
    38fe:	f0 91 c9 04 	lds	r31, 0x04C9
    3902:	80 81       	ld	r24, Z
    3904:	88 23       	and	r24, r24
    3906:	39 f4       	brne	.+14     	; 0x3916 <xTaskIncrementTick+0xa8>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    3908:	8f ef       	ldi	r24, 0xFF	; 255
    390a:	9f ef       	ldi	r25, 0xFF	; 255
    390c:	90 93 85 04 	sts	0x0485, r25
    3910:	80 93 84 04 	sts	0x0484, r24
    3914:	63 c0       	rjmp	.+198    	; 0x39dc <xTaskIncrementTick+0x16e>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3916:	e0 91 c8 04 	lds	r30, 0x04C8
    391a:	f0 91 c9 04 	lds	r31, 0x04C9
    391e:	05 80       	ldd	r0, Z+5	; 0x05
    3920:	f6 81       	ldd	r31, Z+6	; 0x06
    3922:	e0 2d       	mov	r30, r0
    3924:	86 81       	ldd	r24, Z+6	; 0x06
    3926:	97 81       	ldd	r25, Z+7	; 0x07
    3928:	99 87       	std	Y+9, r25	; 0x09
    392a:	88 87       	std	Y+8, r24	; 0x08
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    392c:	e8 85       	ldd	r30, Y+8	; 0x08
    392e:	f9 85       	ldd	r31, Y+9	; 0x09
    3930:	82 81       	ldd	r24, Z+2	; 0x02
    3932:	93 81       	ldd	r25, Z+3	; 0x03
    3934:	9f 83       	std	Y+7, r25	; 0x07
    3936:	8e 83       	std	Y+6, r24	; 0x06

					if( xConstTickCount < xItemValue )
    3938:	2b 81       	ldd	r18, Y+3	; 0x03
    393a:	3c 81       	ldd	r19, Y+4	; 0x04
    393c:	8e 81       	ldd	r24, Y+6	; 0x06
    393e:	9f 81       	ldd	r25, Y+7	; 0x07
    3940:	28 17       	cp	r18, r24
    3942:	39 07       	cpc	r19, r25
    3944:	38 f4       	brcc	.+14     	; 0x3954 <xTaskIncrementTick+0xe6>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
    3946:	8e 81       	ldd	r24, Y+6	; 0x06
    3948:	9f 81       	ldd	r25, Y+7	; 0x07
    394a:	90 93 85 04 	sts	0x0485, r25
    394e:	80 93 84 04 	sts	0x0484, r24
    3952:	44 c0       	rjmp	.+136    	; 0x39dc <xTaskIncrementTick+0x16e>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3954:	88 85       	ldd	r24, Y+8	; 0x08
    3956:	99 85       	ldd	r25, Y+9	; 0x09
    3958:	02 96       	adiw	r24, 0x02	; 2
    395a:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    395e:	e8 85       	ldd	r30, Y+8	; 0x08
    3960:	f9 85       	ldd	r31, Y+9	; 0x09
    3962:	84 89       	ldd	r24, Z+20	; 0x14
    3964:	95 89       	ldd	r25, Z+21	; 0x15
    3966:	00 97       	sbiw	r24, 0x00	; 0
    3968:	29 f0       	breq	.+10     	; 0x3974 <xTaskIncrementTick+0x106>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    396a:	88 85       	ldd	r24, Y+8	; 0x08
    396c:	99 85       	ldd	r25, Y+9	; 0x09
    396e:	0c 96       	adiw	r24, 0x0c	; 12
    3970:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
    3974:	e8 85       	ldd	r30, Y+8	; 0x08
    3976:	f9 85       	ldd	r31, Y+9	; 0x09
    3978:	96 89       	ldd	r25, Z+22	; 0x16
    397a:	80 91 7d 04 	lds	r24, 0x047D
    397e:	89 17       	cp	r24, r25
    3980:	28 f4       	brcc	.+10     	; 0x398c <xTaskIncrementTick+0x11e>
    3982:	e8 85       	ldd	r30, Y+8	; 0x08
    3984:	f9 85       	ldd	r31, Y+9	; 0x09
    3986:	86 89       	ldd	r24, Z+22	; 0x16
    3988:	80 93 7d 04 	sts	0x047D, r24
    398c:	e8 85       	ldd	r30, Y+8	; 0x08
    398e:	f9 85       	ldd	r31, Y+9	; 0x09
    3990:	86 89       	ldd	r24, Z+22	; 0x16
    3992:	28 2f       	mov	r18, r24
    3994:	30 e0       	ldi	r19, 0x00	; 0
    3996:	c9 01       	movw	r24, r18
    3998:	88 0f       	add	r24, r24
    399a:	99 1f       	adc	r25, r25
    399c:	88 0f       	add	r24, r24
    399e:	99 1f       	adc	r25, r25
    39a0:	88 0f       	add	r24, r24
    39a2:	99 1f       	adc	r25, r25
    39a4:	82 0f       	add	r24, r18
    39a6:	93 1f       	adc	r25, r19
    39a8:	ac 01       	movw	r20, r24
    39aa:	47 57       	subi	r20, 0x77	; 119
    39ac:	5b 4f       	sbci	r21, 0xFB	; 251
    39ae:	88 85       	ldd	r24, Y+8	; 0x08
    39b0:	99 85       	ldd	r25, Y+9	; 0x09
    39b2:	9c 01       	movw	r18, r24
    39b4:	2e 5f       	subi	r18, 0xFE	; 254
    39b6:	3f 4f       	sbci	r19, 0xFF	; 255
    39b8:	ca 01       	movw	r24, r20
    39ba:	b9 01       	movw	r22, r18
    39bc:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    39c0:	e8 85       	ldd	r30, Y+8	; 0x08
    39c2:	f9 85       	ldd	r31, Y+9	; 0x09
    39c4:	96 89       	ldd	r25, Z+22	; 0x16
    39c6:	e0 91 77 04 	lds	r30, 0x0477
    39ca:	f0 91 78 04 	lds	r31, 0x0478
    39ce:	86 89       	ldd	r24, Z+22	; 0x16
    39d0:	98 17       	cp	r25, r24
    39d2:	08 f4       	brcc	.+2      	; 0x39d6 <xTaskIncrementTick+0x168>
    39d4:	92 cf       	rjmp	.-220    	; 0x38fa <xTaskIncrementTick+0x8c>
						{
							xSwitchRequired = pdTRUE;
    39d6:	81 e0       	ldi	r24, 0x01	; 1
    39d8:	8d 83       	std	Y+5, r24	; 0x05
    39da:	8f cf       	rjmp	.-226    	; 0x38fa <xTaskIncrementTick+0x8c>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    39dc:	e0 91 77 04 	lds	r30, 0x0477
    39e0:	f0 91 78 04 	lds	r31, 0x0478
    39e4:	86 89       	ldd	r24, Z+22	; 0x16
    39e6:	28 2f       	mov	r18, r24
    39e8:	30 e0       	ldi	r19, 0x00	; 0
    39ea:	c9 01       	movw	r24, r18
    39ec:	88 0f       	add	r24, r24
    39ee:	99 1f       	adc	r25, r25
    39f0:	88 0f       	add	r24, r24
    39f2:	99 1f       	adc	r25, r25
    39f4:	88 0f       	add	r24, r24
    39f6:	99 1f       	adc	r25, r25
    39f8:	82 0f       	add	r24, r18
    39fa:	93 1f       	adc	r25, r19
    39fc:	fc 01       	movw	r30, r24
    39fe:	e7 57       	subi	r30, 0x77	; 119
    3a00:	fb 4f       	sbci	r31, 0xFB	; 251
    3a02:	80 81       	ld	r24, Z
    3a04:	82 30       	cpi	r24, 0x02	; 2
    3a06:	10 f0       	brcs	.+4      	; 0x3a0c <xTaskIncrementTick+0x19e>
			{
				xSwitchRequired = pdTRUE;
    3a08:	81 e0       	ldi	r24, 0x01	; 1
    3a0a:	8d 83       	std	Y+5, r24	; 0x05
		}
		#endif /* configUSE_TICK_HOOK */

		#if ( configUSE_PREEMPTION == 1 )
		{
			if( xYieldPending != pdFALSE )
    3a0c:	80 91 81 04 	lds	r24, 0x0481
    3a10:	88 23       	and	r24, r24
    3a12:	61 f0       	breq	.+24     	; 0x3a2c <xTaskIncrementTick+0x1be>
			{
				xSwitchRequired = pdTRUE;
    3a14:	81 e0       	ldi	r24, 0x01	; 1
    3a16:	8d 83       	std	Y+5, r24	; 0x05
    3a18:	09 c0       	rjmp	.+18     	; 0x3a2c <xTaskIncrementTick+0x1be>
		}
		#endif /* configUSE_PREEMPTION */
	}
	else
	{
		++xPendedTicks;
    3a1a:	80 91 7f 04 	lds	r24, 0x047F
    3a1e:	90 91 80 04 	lds	r25, 0x0480
    3a22:	01 96       	adiw	r24, 0x01	; 1
    3a24:	90 93 80 04 	sts	0x0480, r25
    3a28:	80 93 7f 04 	sts	0x047F, r24
			vApplicationTickHook();
		}
		#endif
	}

	return xSwitchRequired;
    3a2c:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3a2e:	29 96       	adiw	r28, 0x09	; 9
    3a30:	0f b6       	in	r0, 0x3f	; 63
    3a32:	f8 94       	cli
    3a34:	de bf       	out	0x3e, r29	; 62
    3a36:	0f be       	out	0x3f, r0	; 63
    3a38:	cd bf       	out	0x3d, r28	; 61
    3a3a:	cf 91       	pop	r28
    3a3c:	df 91       	pop	r29
    3a3e:	08 95       	ret

00003a40 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    3a40:	df 93       	push	r29
    3a42:	cf 93       	push	r28
    3a44:	00 d0       	rcall	.+0      	; 0x3a46 <vTaskSwitchContext+0x6>
    3a46:	0f 92       	push	r0
    3a48:	cd b7       	in	r28, 0x3d	; 61
    3a4a:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    3a4c:	80 91 88 04 	lds	r24, 0x0488
    3a50:	88 23       	and	r24, r24
    3a52:	21 f0       	breq	.+8      	; 0x3a5c <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    3a54:	81 e0       	ldi	r24, 0x01	; 1
    3a56:	80 93 81 04 	sts	0x0481, r24
    3a5a:	59 c0       	rjmp	.+178    	; 0x3b0e <vTaskSwitchContext+0xce>
	}
	else
	{
		xYieldPending = pdFALSE;
    3a5c:	10 92 81 04 	sts	0x0481, r1
		}
		#endif

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3a60:	80 91 7d 04 	lds	r24, 0x047D
    3a64:	8b 83       	std	Y+3, r24	; 0x03
    3a66:	03 c0       	rjmp	.+6      	; 0x3a6e <vTaskSwitchContext+0x2e>
    3a68:	8b 81       	ldd	r24, Y+3	; 0x03
    3a6a:	81 50       	subi	r24, 0x01	; 1
    3a6c:	8b 83       	std	Y+3, r24	; 0x03
    3a6e:	8b 81       	ldd	r24, Y+3	; 0x03
    3a70:	28 2f       	mov	r18, r24
    3a72:	30 e0       	ldi	r19, 0x00	; 0
    3a74:	c9 01       	movw	r24, r18
    3a76:	88 0f       	add	r24, r24
    3a78:	99 1f       	adc	r25, r25
    3a7a:	88 0f       	add	r24, r24
    3a7c:	99 1f       	adc	r25, r25
    3a7e:	88 0f       	add	r24, r24
    3a80:	99 1f       	adc	r25, r25
    3a82:	82 0f       	add	r24, r18
    3a84:	93 1f       	adc	r25, r19
    3a86:	fc 01       	movw	r30, r24
    3a88:	e7 57       	subi	r30, 0x77	; 119
    3a8a:	fb 4f       	sbci	r31, 0xFB	; 251
    3a8c:	80 81       	ld	r24, Z
    3a8e:	88 23       	and	r24, r24
    3a90:	59 f3       	breq	.-42     	; 0x3a68 <vTaskSwitchContext+0x28>
    3a92:	8b 81       	ldd	r24, Y+3	; 0x03
    3a94:	28 2f       	mov	r18, r24
    3a96:	30 e0       	ldi	r19, 0x00	; 0
    3a98:	c9 01       	movw	r24, r18
    3a9a:	88 0f       	add	r24, r24
    3a9c:	99 1f       	adc	r25, r25
    3a9e:	88 0f       	add	r24, r24
    3aa0:	99 1f       	adc	r25, r25
    3aa2:	88 0f       	add	r24, r24
    3aa4:	99 1f       	adc	r25, r25
    3aa6:	82 0f       	add	r24, r18
    3aa8:	93 1f       	adc	r25, r19
    3aaa:	87 57       	subi	r24, 0x77	; 119
    3aac:	9b 4f       	sbci	r25, 0xFB	; 251
    3aae:	9a 83       	std	Y+2, r25	; 0x02
    3ab0:	89 83       	std	Y+1, r24	; 0x01
    3ab2:	e9 81       	ldd	r30, Y+1	; 0x01
    3ab4:	fa 81       	ldd	r31, Y+2	; 0x02
    3ab6:	01 80       	ldd	r0, Z+1	; 0x01
    3ab8:	f2 81       	ldd	r31, Z+2	; 0x02
    3aba:	e0 2d       	mov	r30, r0
    3abc:	82 81       	ldd	r24, Z+2	; 0x02
    3abe:	93 81       	ldd	r25, Z+3	; 0x03
    3ac0:	e9 81       	ldd	r30, Y+1	; 0x01
    3ac2:	fa 81       	ldd	r31, Y+2	; 0x02
    3ac4:	92 83       	std	Z+2, r25	; 0x02
    3ac6:	81 83       	std	Z+1, r24	; 0x01
    3ac8:	e9 81       	ldd	r30, Y+1	; 0x01
    3aca:	fa 81       	ldd	r31, Y+2	; 0x02
    3acc:	21 81       	ldd	r18, Z+1	; 0x01
    3ace:	32 81       	ldd	r19, Z+2	; 0x02
    3ad0:	89 81       	ldd	r24, Y+1	; 0x01
    3ad2:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad4:	03 96       	adiw	r24, 0x03	; 3
    3ad6:	28 17       	cp	r18, r24
    3ad8:	39 07       	cpc	r19, r25
    3ada:	59 f4       	brne	.+22     	; 0x3af2 <vTaskSwitchContext+0xb2>
    3adc:	e9 81       	ldd	r30, Y+1	; 0x01
    3ade:	fa 81       	ldd	r31, Y+2	; 0x02
    3ae0:	01 80       	ldd	r0, Z+1	; 0x01
    3ae2:	f2 81       	ldd	r31, Z+2	; 0x02
    3ae4:	e0 2d       	mov	r30, r0
    3ae6:	82 81       	ldd	r24, Z+2	; 0x02
    3ae8:	93 81       	ldd	r25, Z+3	; 0x03
    3aea:	e9 81       	ldd	r30, Y+1	; 0x01
    3aec:	fa 81       	ldd	r31, Y+2	; 0x02
    3aee:	92 83       	std	Z+2, r25	; 0x02
    3af0:	81 83       	std	Z+1, r24	; 0x01
    3af2:	e9 81       	ldd	r30, Y+1	; 0x01
    3af4:	fa 81       	ldd	r31, Y+2	; 0x02
    3af6:	01 80       	ldd	r0, Z+1	; 0x01
    3af8:	f2 81       	ldd	r31, Z+2	; 0x02
    3afa:	e0 2d       	mov	r30, r0
    3afc:	86 81       	ldd	r24, Z+6	; 0x06
    3afe:	97 81       	ldd	r25, Z+7	; 0x07
    3b00:	90 93 78 04 	sts	0x0478, r25
    3b04:	80 93 77 04 	sts	0x0477, r24
    3b08:	8b 81       	ldd	r24, Y+3	; 0x03
    3b0a:	80 93 7d 04 	sts	0x047D, r24
			for additional information. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
    3b0e:	0f 90       	pop	r0
    3b10:	0f 90       	pop	r0
    3b12:	0f 90       	pop	r0
    3b14:	cf 91       	pop	r28
    3b16:	df 91       	pop	r29
    3b18:	08 95       	ret

00003b1a <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    3b1a:	df 93       	push	r29
    3b1c:	cf 93       	push	r28
    3b1e:	00 d0       	rcall	.+0      	; 0x3b20 <vTaskPlaceOnEventList+0x6>
    3b20:	00 d0       	rcall	.+0      	; 0x3b22 <vTaskPlaceOnEventList+0x8>
    3b22:	cd b7       	in	r28, 0x3d	; 61
    3b24:	de b7       	in	r29, 0x3e	; 62
    3b26:	9a 83       	std	Y+2, r25	; 0x02
    3b28:	89 83       	std	Y+1, r24	; 0x01
    3b2a:	7c 83       	std	Y+4, r23	; 0x04
    3b2c:	6b 83       	std	Y+3, r22	; 0x03

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3b2e:	80 91 77 04 	lds	r24, 0x0477
    3b32:	90 91 78 04 	lds	r25, 0x0478
    3b36:	9c 01       	movw	r18, r24
    3b38:	24 5f       	subi	r18, 0xF4	; 244
    3b3a:	3f 4f       	sbci	r19, 0xFF	; 255
    3b3c:	89 81       	ldd	r24, Y+1	; 0x01
    3b3e:	9a 81       	ldd	r25, Y+2	; 0x02
    3b40:	b9 01       	movw	r22, r18
    3b42:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <vListInsert>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3b46:	8b 81       	ldd	r24, Y+3	; 0x03
    3b48:	9c 81       	ldd	r25, Y+4	; 0x04
    3b4a:	61 e0       	ldi	r22, 0x01	; 1
    3b4c:	0e 94 3a 24 	call	0x4874	; 0x4874 <prvAddCurrentTaskToDelayedList>
}
    3b50:	0f 90       	pop	r0
    3b52:	0f 90       	pop	r0
    3b54:	0f 90       	pop	r0
    3b56:	0f 90       	pop	r0
    3b58:	cf 91       	pop	r28
    3b5a:	df 91       	pop	r29
    3b5c:	08 95       	ret

00003b5e <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
{
    3b5e:	df 93       	push	r29
    3b60:	cf 93       	push	r28
    3b62:	00 d0       	rcall	.+0      	; 0x3b64 <vTaskPlaceOnUnorderedEventList+0x6>
    3b64:	00 d0       	rcall	.+0      	; 0x3b66 <vTaskPlaceOnUnorderedEventList+0x8>
    3b66:	00 d0       	rcall	.+0      	; 0x3b68 <vTaskPlaceOnUnorderedEventList+0xa>
    3b68:	cd b7       	in	r28, 0x3d	; 61
    3b6a:	de b7       	in	r29, 0x3e	; 62
    3b6c:	9a 83       	std	Y+2, r25	; 0x02
    3b6e:	89 83       	std	Y+1, r24	; 0x01
    3b70:	7c 83       	std	Y+4, r23	; 0x04
    3b72:	6b 83       	std	Y+3, r22	; 0x03
    3b74:	5e 83       	std	Y+6, r21	; 0x06
    3b76:	4d 83       	std	Y+5, r20	; 0x05
	configASSERT( uxSchedulerSuspended != 0 );

	/* Store the item value in the event list item.  It is safe to access the
	event list item here as interrupts won't access the event list item of a
	task that is not in the Blocked state. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3b78:	e0 91 77 04 	lds	r30, 0x0477
    3b7c:	f0 91 78 04 	lds	r31, 0x0478
    3b80:	8b 81       	ldd	r24, Y+3	; 0x03
    3b82:	9c 81       	ldd	r25, Y+4	; 0x04
    3b84:	90 68       	ori	r25, 0x80	; 128
    3b86:	95 87       	std	Z+13, r25	; 0x0d
    3b88:	84 87       	std	Z+12, r24	; 0x0c
	/* Place the event list item of the TCB at the end of the appropriate event
	list.  It is safe to access the event list here because it is part of an
	event group implementation - and interrupts don't access event groups
	directly (instead they access them indirectly by pending function calls to
	the task level). */
	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    3b8a:	80 91 77 04 	lds	r24, 0x0477
    3b8e:	90 91 78 04 	lds	r25, 0x0478
    3b92:	9c 01       	movw	r18, r24
    3b94:	24 5f       	subi	r18, 0xF4	; 244
    3b96:	3f 4f       	sbci	r19, 0xFF	; 255
    3b98:	89 81       	ldd	r24, Y+1	; 0x01
    3b9a:	9a 81       	ldd	r25, Y+2	; 0x02
    3b9c:	b9 01       	movw	r22, r18
    3b9e:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>

	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    3ba2:	8d 81       	ldd	r24, Y+5	; 0x05
    3ba4:	9e 81       	ldd	r25, Y+6	; 0x06
    3ba6:	61 e0       	ldi	r22, 0x01	; 1
    3ba8:	0e 94 3a 24 	call	0x4874	; 0x4874 <prvAddCurrentTaskToDelayedList>
}
    3bac:	26 96       	adiw	r28, 0x06	; 6
    3bae:	0f b6       	in	r0, 0x3f	; 63
    3bb0:	f8 94       	cli
    3bb2:	de bf       	out	0x3e, r29	; 62
    3bb4:	0f be       	out	0x3f, r0	; 63
    3bb6:	cd bf       	out	0x3d, r28	; 61
    3bb8:	cf 91       	pop	r28
    3bba:	df 91       	pop	r29
    3bbc:	08 95       	ret

00003bbe <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    3bbe:	df 93       	push	r29
    3bc0:	cf 93       	push	r28
    3bc2:	00 d0       	rcall	.+0      	; 0x3bc4 <xTaskRemoveFromEventList+0x6>
    3bc4:	00 d0       	rcall	.+0      	; 0x3bc6 <xTaskRemoveFromEventList+0x8>
    3bc6:	0f 92       	push	r0
    3bc8:	cd b7       	in	r28, 0x3d	; 61
    3bca:	de b7       	in	r29, 0x3e	; 62
    3bcc:	9d 83       	std	Y+5, r25	; 0x05
    3bce:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3bd0:	ec 81       	ldd	r30, Y+4	; 0x04
    3bd2:	fd 81       	ldd	r31, Y+5	; 0x05
    3bd4:	05 80       	ldd	r0, Z+5	; 0x05
    3bd6:	f6 81       	ldd	r31, Z+6	; 0x06
    3bd8:	e0 2d       	mov	r30, r0
    3bda:	86 81       	ldd	r24, Z+6	; 0x06
    3bdc:	97 81       	ldd	r25, Z+7	; 0x07
    3bde:	9b 83       	std	Y+3, r25	; 0x03
    3be0:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    3be2:	8a 81       	ldd	r24, Y+2	; 0x02
    3be4:	9b 81       	ldd	r25, Y+3	; 0x03
    3be6:	0c 96       	adiw	r24, 0x0c	; 12
    3be8:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    3bec:	80 91 88 04 	lds	r24, 0x0488
    3bf0:	88 23       	and	r24, r24
    3bf2:	61 f5       	brne	.+88     	; 0x3c4c <xTaskRemoveFromEventList+0x8e>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3bf4:	8a 81       	ldd	r24, Y+2	; 0x02
    3bf6:	9b 81       	ldd	r25, Y+3	; 0x03
    3bf8:	02 96       	adiw	r24, 0x02	; 2
    3bfa:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    3bfe:	ea 81       	ldd	r30, Y+2	; 0x02
    3c00:	fb 81       	ldd	r31, Y+3	; 0x03
    3c02:	96 89       	ldd	r25, Z+22	; 0x16
    3c04:	80 91 7d 04 	lds	r24, 0x047D
    3c08:	89 17       	cp	r24, r25
    3c0a:	28 f4       	brcc	.+10     	; 0x3c16 <xTaskRemoveFromEventList+0x58>
    3c0c:	ea 81       	ldd	r30, Y+2	; 0x02
    3c0e:	fb 81       	ldd	r31, Y+3	; 0x03
    3c10:	86 89       	ldd	r24, Z+22	; 0x16
    3c12:	80 93 7d 04 	sts	0x047D, r24
    3c16:	ea 81       	ldd	r30, Y+2	; 0x02
    3c18:	fb 81       	ldd	r31, Y+3	; 0x03
    3c1a:	86 89       	ldd	r24, Z+22	; 0x16
    3c1c:	28 2f       	mov	r18, r24
    3c1e:	30 e0       	ldi	r19, 0x00	; 0
    3c20:	c9 01       	movw	r24, r18
    3c22:	88 0f       	add	r24, r24
    3c24:	99 1f       	adc	r25, r25
    3c26:	88 0f       	add	r24, r24
    3c28:	99 1f       	adc	r25, r25
    3c2a:	88 0f       	add	r24, r24
    3c2c:	99 1f       	adc	r25, r25
    3c2e:	82 0f       	add	r24, r18
    3c30:	93 1f       	adc	r25, r19
    3c32:	ac 01       	movw	r20, r24
    3c34:	47 57       	subi	r20, 0x77	; 119
    3c36:	5b 4f       	sbci	r21, 0xFB	; 251
    3c38:	8a 81       	ldd	r24, Y+2	; 0x02
    3c3a:	9b 81       	ldd	r25, Y+3	; 0x03
    3c3c:	9c 01       	movw	r18, r24
    3c3e:	2e 5f       	subi	r18, 0xFE	; 254
    3c40:	3f 4f       	sbci	r19, 0xFF	; 255
    3c42:	ca 01       	movw	r24, r20
    3c44:	b9 01       	movw	r22, r18
    3c46:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>
    3c4a:	0a c0       	rjmp	.+20     	; 0x3c60 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    3c4c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c4e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c50:	9c 01       	movw	r18, r24
    3c52:	24 5f       	subi	r18, 0xF4	; 244
    3c54:	3f 4f       	sbci	r19, 0xFF	; 255
    3c56:	8c ec       	ldi	r24, 0xCC	; 204
    3c58:	94 e0       	ldi	r25, 0x04	; 4
    3c5a:	b9 01       	movw	r22, r18
    3c5c:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3c60:	ea 81       	ldd	r30, Y+2	; 0x02
    3c62:	fb 81       	ldd	r31, Y+3	; 0x03
    3c64:	96 89       	ldd	r25, Z+22	; 0x16
    3c66:	e0 91 77 04 	lds	r30, 0x0477
    3c6a:	f0 91 78 04 	lds	r31, 0x0478
    3c6e:	86 89       	ldd	r24, Z+22	; 0x16
    3c70:	89 17       	cp	r24, r25
    3c72:	30 f4       	brcc	.+12     	; 0x3c80 <xTaskRemoveFromEventList+0xc2>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
    3c74:	81 e0       	ldi	r24, 0x01	; 1
    3c76:	89 83       	std	Y+1, r24	; 0x01

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    3c78:	81 e0       	ldi	r24, 0x01	; 1
    3c7a:	80 93 81 04 	sts	0x0481, r24
    3c7e:	01 c0       	rjmp	.+2      	; 0x3c82 <xTaskRemoveFromEventList+0xc4>
	}
	else
	{
		xReturn = pdFALSE;
    3c80:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3c82:	89 81       	ldd	r24, Y+1	; 0x01
}
    3c84:	0f 90       	pop	r0
    3c86:	0f 90       	pop	r0
    3c88:	0f 90       	pop	r0
    3c8a:	0f 90       	pop	r0
    3c8c:	0f 90       	pop	r0
    3c8e:	cf 91       	pop	r28
    3c90:	df 91       	pop	r29
    3c92:	08 95       	ret

00003c94 <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
{
    3c94:	df 93       	push	r29
    3c96:	cf 93       	push	r28
    3c98:	00 d0       	rcall	.+0      	; 0x3c9a <vTaskRemoveFromUnorderedEventList+0x6>
    3c9a:	00 d0       	rcall	.+0      	; 0x3c9c <vTaskRemoveFromUnorderedEventList+0x8>
    3c9c:	00 d0       	rcall	.+0      	; 0x3c9e <vTaskRemoveFromUnorderedEventList+0xa>
    3c9e:	cd b7       	in	r28, 0x3d	; 61
    3ca0:	de b7       	in	r29, 0x3e	; 62
    3ca2:	9c 83       	std	Y+4, r25	; 0x04
    3ca4:	8b 83       	std	Y+3, r24	; 0x03
    3ca6:	7e 83       	std	Y+6, r23	; 0x06
    3ca8:	6d 83       	std	Y+5, r22	; 0x05
	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
	the event flags implementation. */
	configASSERT( uxSchedulerSuspended != pdFALSE );

	/* Store the new item value in the event list. */
	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    3caa:	8d 81       	ldd	r24, Y+5	; 0x05
    3cac:	9e 81       	ldd	r25, Y+6	; 0x06
    3cae:	90 68       	ori	r25, 0x80	; 128
    3cb0:	eb 81       	ldd	r30, Y+3	; 0x03
    3cb2:	fc 81       	ldd	r31, Y+4	; 0x04
    3cb4:	91 83       	std	Z+1, r25	; 0x01
    3cb6:	80 83       	st	Z, r24

	/* Remove the event list form the event flag.  Interrupts do not access
	event flags. */
	pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3cb8:	eb 81       	ldd	r30, Y+3	; 0x03
    3cba:	fc 81       	ldd	r31, Y+4	; 0x04
    3cbc:	86 81       	ldd	r24, Z+6	; 0x06
    3cbe:	97 81       	ldd	r25, Z+7	; 0x07
    3cc0:	9a 83       	std	Y+2, r25	; 0x02
    3cc2:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( pxEventListItem );
    3cc4:	8b 81       	ldd	r24, Y+3	; 0x03
    3cc6:	9c 81       	ldd	r25, Y+4	; 0x04
    3cc8:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
	#endif

	/* Remove the task from the delayed list and add it to the ready list.  The
	scheduler is suspended so interrupts will not be accessing the ready
	lists. */
	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
    3ccc:	89 81       	ldd	r24, Y+1	; 0x01
    3cce:	9a 81       	ldd	r25, Y+2	; 0x02
    3cd0:	02 96       	adiw	r24, 0x02	; 2
    3cd2:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
	prvAddTaskToReadyList( pxUnblockedTCB );
    3cd6:	e9 81       	ldd	r30, Y+1	; 0x01
    3cd8:	fa 81       	ldd	r31, Y+2	; 0x02
    3cda:	96 89       	ldd	r25, Z+22	; 0x16
    3cdc:	80 91 7d 04 	lds	r24, 0x047D
    3ce0:	89 17       	cp	r24, r25
    3ce2:	28 f4       	brcc	.+10     	; 0x3cee <vTaskRemoveFromUnorderedEventList+0x5a>
    3ce4:	e9 81       	ldd	r30, Y+1	; 0x01
    3ce6:	fa 81       	ldd	r31, Y+2	; 0x02
    3ce8:	86 89       	ldd	r24, Z+22	; 0x16
    3cea:	80 93 7d 04 	sts	0x047D, r24
    3cee:	e9 81       	ldd	r30, Y+1	; 0x01
    3cf0:	fa 81       	ldd	r31, Y+2	; 0x02
    3cf2:	86 89       	ldd	r24, Z+22	; 0x16
    3cf4:	28 2f       	mov	r18, r24
    3cf6:	30 e0       	ldi	r19, 0x00	; 0
    3cf8:	c9 01       	movw	r24, r18
    3cfa:	88 0f       	add	r24, r24
    3cfc:	99 1f       	adc	r25, r25
    3cfe:	88 0f       	add	r24, r24
    3d00:	99 1f       	adc	r25, r25
    3d02:	88 0f       	add	r24, r24
    3d04:	99 1f       	adc	r25, r25
    3d06:	82 0f       	add	r24, r18
    3d08:	93 1f       	adc	r25, r19
    3d0a:	ac 01       	movw	r20, r24
    3d0c:	47 57       	subi	r20, 0x77	; 119
    3d0e:	5b 4f       	sbci	r21, 0xFB	; 251
    3d10:	89 81       	ldd	r24, Y+1	; 0x01
    3d12:	9a 81       	ldd	r25, Y+2	; 0x02
    3d14:	9c 01       	movw	r18, r24
    3d16:	2e 5f       	subi	r18, 0xFE	; 254
    3d18:	3f 4f       	sbci	r19, 0xFF	; 255
    3d1a:	ca 01       	movw	r24, r20
    3d1c:	b9 01       	movw	r22, r18
    3d1e:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    3d22:	e9 81       	ldd	r30, Y+1	; 0x01
    3d24:	fa 81       	ldd	r31, Y+2	; 0x02
    3d26:	96 89       	ldd	r25, Z+22	; 0x16
    3d28:	e0 91 77 04 	lds	r30, 0x0477
    3d2c:	f0 91 78 04 	lds	r31, 0x0478
    3d30:	86 89       	ldd	r24, Z+22	; 0x16
    3d32:	89 17       	cp	r24, r25
    3d34:	18 f4       	brcc	.+6      	; 0x3d3c <vTaskRemoveFromUnorderedEventList+0xa8>
	{
		/* The unblocked task has a priority above that of the calling task, so
		a context switch is required.  This function is called with the
		scheduler suspended so xYieldPending is set so the context switch
		occurs immediately that the scheduler is resumed (unsuspended). */
		xYieldPending = pdTRUE;
    3d36:	81 e0       	ldi	r24, 0x01	; 1
    3d38:	80 93 81 04 	sts	0x0481, r24
	}
}
    3d3c:	26 96       	adiw	r28, 0x06	; 6
    3d3e:	0f b6       	in	r0, 0x3f	; 63
    3d40:	f8 94       	cli
    3d42:	de bf       	out	0x3e, r29	; 62
    3d44:	0f be       	out	0x3f, r0	; 63
    3d46:	cd bf       	out	0x3d, r28	; 61
    3d48:	cf 91       	pop	r28
    3d4a:	df 91       	pop	r29
    3d4c:	08 95       	ret

00003d4e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3d4e:	df 93       	push	r29
    3d50:	cf 93       	push	r28
    3d52:	00 d0       	rcall	.+0      	; 0x3d54 <vTaskSetTimeOutState+0x6>
    3d54:	cd b7       	in	r28, 0x3d	; 61
    3d56:	de b7       	in	r29, 0x3e	; 62
    3d58:	9a 83       	std	Y+2, r25	; 0x02
    3d5a:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	taskENTER_CRITICAL();
    3d5c:	0f b6       	in	r0, 0x3f	; 63
    3d5e:	f8 94       	cli
    3d60:	0f 92       	push	r0
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
    3d62:	80 91 82 04 	lds	r24, 0x0482
    3d66:	e9 81       	ldd	r30, Y+1	; 0x01
    3d68:	fa 81       	ldd	r31, Y+2	; 0x02
    3d6a:	80 83       	st	Z, r24
		pxTimeOut->xTimeOnEntering = xTickCount;
    3d6c:	80 91 7b 04 	lds	r24, 0x047B
    3d70:	90 91 7c 04 	lds	r25, 0x047C
    3d74:	e9 81       	ldd	r30, Y+1	; 0x01
    3d76:	fa 81       	ldd	r31, Y+2	; 0x02
    3d78:	92 83       	std	Z+2, r25	; 0x02
    3d7a:	81 83       	std	Z+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    3d7c:	0f 90       	pop	r0
    3d7e:	0f be       	out	0x3f, r0	; 63
}
    3d80:	0f 90       	pop	r0
    3d82:	0f 90       	pop	r0
    3d84:	cf 91       	pop	r28
    3d86:	df 91       	pop	r29
    3d88:	08 95       	ret

00003d8a <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    3d8a:	df 93       	push	r29
    3d8c:	cf 93       	push	r28
    3d8e:	00 d0       	rcall	.+0      	; 0x3d90 <vTaskInternalSetTimeOutState+0x6>
    3d90:	cd b7       	in	r28, 0x3d	; 61
    3d92:	de b7       	in	r29, 0x3e	; 62
    3d94:	9a 83       	std	Y+2, r25	; 0x02
    3d96:	89 83       	std	Y+1, r24	; 0x01
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3d98:	80 91 82 04 	lds	r24, 0x0482
    3d9c:	e9 81       	ldd	r30, Y+1	; 0x01
    3d9e:	fa 81       	ldd	r31, Y+2	; 0x02
    3da0:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3da2:	80 91 7b 04 	lds	r24, 0x047B
    3da6:	90 91 7c 04 	lds	r25, 0x047C
    3daa:	e9 81       	ldd	r30, Y+1	; 0x01
    3dac:	fa 81       	ldd	r31, Y+2	; 0x02
    3dae:	92 83       	std	Z+2, r25	; 0x02
    3db0:	81 83       	std	Z+1, r24	; 0x01
}
    3db2:	0f 90       	pop	r0
    3db4:	0f 90       	pop	r0
    3db6:	cf 91       	pop	r28
    3db8:	df 91       	pop	r29
    3dba:	08 95       	ret

00003dbc <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    3dbc:	df 93       	push	r29
    3dbe:	cf 93       	push	r28
    3dc0:	cd b7       	in	r28, 0x3d	; 61
    3dc2:	de b7       	in	r29, 0x3e	; 62
    3dc4:	29 97       	sbiw	r28, 0x09	; 9
    3dc6:	0f b6       	in	r0, 0x3f	; 63
    3dc8:	f8 94       	cli
    3dca:	de bf       	out	0x3e, r29	; 62
    3dcc:	0f be       	out	0x3f, r0	; 63
    3dce:	cd bf       	out	0x3d, r28	; 61
    3dd0:	9f 83       	std	Y+7, r25	; 0x07
    3dd2:	8e 83       	std	Y+6, r24	; 0x06
    3dd4:	79 87       	std	Y+9, r23	; 0x09
    3dd6:	68 87       	std	Y+8, r22	; 0x08
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3dd8:	0f b6       	in	r0, 0x3f	; 63
    3dda:	f8 94       	cli
    3ddc:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    3dde:	80 91 7b 04 	lds	r24, 0x047B
    3de2:	90 91 7c 04 	lds	r25, 0x047C
    3de6:	9c 83       	std	Y+4, r25	; 0x04
    3de8:	8b 83       	std	Y+3, r24	; 0x03
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    3dea:	ee 81       	ldd	r30, Y+6	; 0x06
    3dec:	ff 81       	ldd	r31, Y+7	; 0x07
    3dee:	21 81       	ldd	r18, Z+1	; 0x01
    3df0:	32 81       	ldd	r19, Z+2	; 0x02
    3df2:	8b 81       	ldd	r24, Y+3	; 0x03
    3df4:	9c 81       	ldd	r25, Y+4	; 0x04
    3df6:	82 1b       	sub	r24, r18
    3df8:	93 0b       	sbc	r25, r19
    3dfa:	9a 83       	std	Y+2, r25	; 0x02
    3dfc:	89 83       	std	Y+1, r24	; 0x01
			}
			else
		#endif

		#if ( INCLUDE_vTaskSuspend == 1 )
			if( *pxTicksToWait == portMAX_DELAY )
    3dfe:	e8 85       	ldd	r30, Y+8	; 0x08
    3e00:	f9 85       	ldd	r31, Y+9	; 0x09
    3e02:	80 81       	ld	r24, Z
    3e04:	91 81       	ldd	r25, Z+1	; 0x01
    3e06:	2f ef       	ldi	r18, 0xFF	; 255
    3e08:	8f 3f       	cpi	r24, 0xFF	; 255
    3e0a:	92 07       	cpc	r25, r18
    3e0c:	11 f4       	brne	.+4      	; 0x3e12 <xTaskCheckForTimeOut+0x56>
			{
				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
				specified is the maximum block time then the task should block
				indefinitely, and therefore never time out. */
				xReturn = pdFALSE;
    3e0e:	1d 82       	std	Y+5, r1	; 0x05
    3e10:	36 c0       	rjmp	.+108    	; 0x3e7e <xTaskCheckForTimeOut+0xc2>
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    3e12:	ee 81       	ldd	r30, Y+6	; 0x06
    3e14:	ff 81       	ldd	r31, Y+7	; 0x07
    3e16:	90 81       	ld	r25, Z
    3e18:	80 91 82 04 	lds	r24, 0x0482
    3e1c:	98 17       	cp	r25, r24
    3e1e:	61 f0       	breq	.+24     	; 0x3e38 <xTaskCheckForTimeOut+0x7c>
    3e20:	ee 81       	ldd	r30, Y+6	; 0x06
    3e22:	ff 81       	ldd	r31, Y+7	; 0x07
    3e24:	21 81       	ldd	r18, Z+1	; 0x01
    3e26:	32 81       	ldd	r19, Z+2	; 0x02
    3e28:	8b 81       	ldd	r24, Y+3	; 0x03
    3e2a:	9c 81       	ldd	r25, Y+4	; 0x04
    3e2c:	82 17       	cp	r24, r18
    3e2e:	93 07       	cpc	r25, r19
    3e30:	18 f0       	brcs	.+6      	; 0x3e38 <xTaskCheckForTimeOut+0x7c>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    3e32:	81 e0       	ldi	r24, 0x01	; 1
    3e34:	8d 83       	std	Y+5, r24	; 0x05
    3e36:	23 c0       	rjmp	.+70     	; 0x3e7e <xTaskCheckForTimeOut+0xc2>
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    3e38:	e8 85       	ldd	r30, Y+8	; 0x08
    3e3a:	f9 85       	ldd	r31, Y+9	; 0x09
    3e3c:	20 81       	ld	r18, Z
    3e3e:	31 81       	ldd	r19, Z+1	; 0x01
    3e40:	89 81       	ldd	r24, Y+1	; 0x01
    3e42:	9a 81       	ldd	r25, Y+2	; 0x02
    3e44:	82 17       	cp	r24, r18
    3e46:	93 07       	cpc	r25, r19
    3e48:	a0 f4       	brcc	.+40     	; 0x3e72 <xTaskCheckForTimeOut+0xb6>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    3e4a:	e8 85       	ldd	r30, Y+8	; 0x08
    3e4c:	f9 85       	ldd	r31, Y+9	; 0x09
    3e4e:	20 81       	ld	r18, Z
    3e50:	31 81       	ldd	r19, Z+1	; 0x01
    3e52:	89 81       	ldd	r24, Y+1	; 0x01
    3e54:	9a 81       	ldd	r25, Y+2	; 0x02
    3e56:	a9 01       	movw	r20, r18
    3e58:	48 1b       	sub	r20, r24
    3e5a:	59 0b       	sbc	r21, r25
    3e5c:	ca 01       	movw	r24, r20
    3e5e:	e8 85       	ldd	r30, Y+8	; 0x08
    3e60:	f9 85       	ldd	r31, Y+9	; 0x09
    3e62:	91 83       	std	Z+1, r25	; 0x01
    3e64:	80 83       	st	Z, r24
			vTaskInternalSetTimeOutState( pxTimeOut );
    3e66:	8e 81       	ldd	r24, Y+6	; 0x06
    3e68:	9f 81       	ldd	r25, Y+7	; 0x07
    3e6a:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    3e6e:	1d 82       	std	Y+5, r1	; 0x05
    3e70:	06 c0       	rjmp	.+12     	; 0x3e7e <xTaskCheckForTimeOut+0xc2>
		}
		else
		{
			*pxTicksToWait = 0;
    3e72:	e8 85       	ldd	r30, Y+8	; 0x08
    3e74:	f9 85       	ldd	r31, Y+9	; 0x09
    3e76:	11 82       	std	Z+1, r1	; 0x01
    3e78:	10 82       	st	Z, r1
			xReturn = pdTRUE;
    3e7a:	81 e0       	ldi	r24, 0x01	; 1
    3e7c:	8d 83       	std	Y+5, r24	; 0x05
		}
	}
	taskEXIT_CRITICAL();
    3e7e:	0f 90       	pop	r0
    3e80:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3e82:	8d 81       	ldd	r24, Y+5	; 0x05
}
    3e84:	29 96       	adiw	r28, 0x09	; 9
    3e86:	0f b6       	in	r0, 0x3f	; 63
    3e88:	f8 94       	cli
    3e8a:	de bf       	out	0x3e, r29	; 62
    3e8c:	0f be       	out	0x3f, r0	; 63
    3e8e:	cd bf       	out	0x3d, r28	; 61
    3e90:	cf 91       	pop	r28
    3e92:	df 91       	pop	r29
    3e94:	08 95       	ret

00003e96 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    3e96:	df 93       	push	r29
    3e98:	cf 93       	push	r28
    3e9a:	cd b7       	in	r28, 0x3d	; 61
    3e9c:	de b7       	in	r29, 0x3e	; 62
	xYieldPending = pdTRUE;
    3e9e:	81 e0       	ldi	r24, 0x01	; 1
    3ea0:	80 93 81 04 	sts	0x0481, r24
}
    3ea4:	cf 91       	pop	r28
    3ea6:	df 91       	pop	r29
    3ea8:	08 95       	ret

00003eaa <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    3eaa:	df 93       	push	r29
    3eac:	cf 93       	push	r28
    3eae:	00 d0       	rcall	.+0      	; 0x3eb0 <prvIdleTask+0x6>
    3eb0:	cd b7       	in	r28, 0x3d	; 61
    3eb2:	de b7       	in	r29, 0x3e	; 62
    3eb4:	9a 83       	std	Y+2, r25	; 0x02
    3eb6:	89 83       	std	Y+1, r24	; 0x01

	for( ;; )
	{
		/* See if any tasks have deleted themselves - if so then the idle task
		is responsible for freeing the deleted task's TCB and stack. */
		prvCheckTasksWaitingTermination();
    3eb8:	0e 94 a0 1f 	call	0x3f40	; 0x3f40 <prvCheckTasksWaitingTermination>
    3ebc:	fd cf       	rjmp	.-6      	; 0x3eb8 <prvIdleTask+0xe>

00003ebe <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
    3ebe:	df 93       	push	r29
    3ec0:	cf 93       	push	r28
    3ec2:	0f 92       	push	r0
    3ec4:	cd b7       	in	r28, 0x3d	; 61
    3ec6:	de b7       	in	r29, 0x3e	; 62
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3ec8:	19 82       	std	Y+1, r1	; 0x01
    3eca:	13 c0       	rjmp	.+38     	; 0x3ef2 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    3ecc:	89 81       	ldd	r24, Y+1	; 0x01
    3ece:	28 2f       	mov	r18, r24
    3ed0:	30 e0       	ldi	r19, 0x00	; 0
    3ed2:	c9 01       	movw	r24, r18
    3ed4:	88 0f       	add	r24, r24
    3ed6:	99 1f       	adc	r25, r25
    3ed8:	88 0f       	add	r24, r24
    3eda:	99 1f       	adc	r25, r25
    3edc:	88 0f       	add	r24, r24
    3ede:	99 1f       	adc	r25, r25
    3ee0:	82 0f       	add	r24, r18
    3ee2:	93 1f       	adc	r25, r19
    3ee4:	87 57       	subi	r24, 0x77	; 119
    3ee6:	9b 4f       	sbci	r25, 0xFB	; 251
    3ee8:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    3eec:	89 81       	ldd	r24, Y+1	; 0x01
    3eee:	8f 5f       	subi	r24, 0xFF	; 255
    3ef0:	89 83       	std	Y+1, r24	; 0x01
    3ef2:	89 81       	ldd	r24, Y+1	; 0x01
    3ef4:	85 30       	cpi	r24, 0x05	; 5
    3ef6:	50 f3       	brcs	.-44     	; 0x3ecc <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
    3ef8:	86 eb       	ldi	r24, 0xB6	; 182
    3efa:	94 e0       	ldi	r25, 0x04	; 4
    3efc:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
    3f00:	8f eb       	ldi	r24, 0xBF	; 191
    3f02:	94 e0       	ldi	r25, 0x04	; 4
    3f04:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vListInitialise>
	vListInitialise( &xPendingReadyList );
    3f08:	8c ec       	ldi	r24, 0xCC	; 204
    3f0a:	94 e0       	ldi	r25, 0x04	; 4
    3f0c:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
    3f10:	85 ed       	ldi	r24, 0xD5	; 213
    3f12:	94 e0       	ldi	r25, 0x04	; 4
    3f14:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
    3f18:	8e ed       	ldi	r24, 0xDE	; 222
    3f1a:	94 e0       	ldi	r25, 0x04	; 4
    3f1c:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    3f20:	86 eb       	ldi	r24, 0xB6	; 182
    3f22:	94 e0       	ldi	r25, 0x04	; 4
    3f24:	90 93 c9 04 	sts	0x04C9, r25
    3f28:	80 93 c8 04 	sts	0x04C8, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    3f2c:	8f eb       	ldi	r24, 0xBF	; 191
    3f2e:	94 e0       	ldi	r25, 0x04	; 4
    3f30:	90 93 cb 04 	sts	0x04CB, r25
    3f34:	80 93 ca 04 	sts	0x04CA, r24
}
    3f38:	0f 90       	pop	r0
    3f3a:	cf 91       	pop	r28
    3f3c:	df 91       	pop	r29
    3f3e:	08 95       	ret

00003f40 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    3f40:	df 93       	push	r29
    3f42:	cf 93       	push	r28
    3f44:	00 d0       	rcall	.+0      	; 0x3f46 <prvCheckTasksWaitingTermination+0x6>
    3f46:	cd b7       	in	r28, 0x3d	; 61
    3f48:	de b7       	in	r29, 0x3e	; 62
    3f4a:	20 c0       	rjmp	.+64     	; 0x3f8c <prvCheckTasksWaitingTermination+0x4c>

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
		{
			taskENTER_CRITICAL();
    3f4c:	0f b6       	in	r0, 0x3f	; 63
    3f4e:	f8 94       	cli
    3f50:	0f 92       	push	r0
			{
				pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3f52:	e0 91 da 04 	lds	r30, 0x04DA
    3f56:	f0 91 db 04 	lds	r31, 0x04DB
    3f5a:	86 81       	ldd	r24, Z+6	; 0x06
    3f5c:	97 81       	ldd	r25, Z+7	; 0x07
    3f5e:	9a 83       	std	Y+2, r25	; 0x02
    3f60:	89 83       	std	Y+1, r24	; 0x01
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    3f62:	89 81       	ldd	r24, Y+1	; 0x01
    3f64:	9a 81       	ldd	r25, Y+2	; 0x02
    3f66:	02 96       	adiw	r24, 0x02	; 2
    3f68:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
				--uxCurrentNumberOfTasks;
    3f6c:	80 91 7a 04 	lds	r24, 0x047A
    3f70:	81 50       	subi	r24, 0x01	; 1
    3f72:	80 93 7a 04 	sts	0x047A, r24
				--uxDeletedTasksWaitingCleanUp;
    3f76:	80 91 79 04 	lds	r24, 0x0479
    3f7a:	81 50       	subi	r24, 0x01	; 1
    3f7c:	80 93 79 04 	sts	0x0479, r24
			}
			taskEXIT_CRITICAL();
    3f80:	0f 90       	pop	r0
    3f82:	0f be       	out	0x3f, r0	; 63

			prvDeleteTCB( pxTCB );
    3f84:	89 81       	ldd	r24, Y+1	; 0x01
    3f86:	9a 81       	ldd	r25, Y+2	; 0x02
    3f88:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <prvDeleteTCB>
	{
		TCB_t *pxTCB;

		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
		being called too often in the idle task. */
		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    3f8c:	80 91 79 04 	lds	r24, 0x0479
    3f90:	88 23       	and	r24, r24
    3f92:	e1 f6       	brne	.-72     	; 0x3f4c <prvCheckTasksWaitingTermination+0xc>

			prvDeleteTCB( pxTCB );
		}
	}
	#endif /* INCLUDE_vTaskDelete */
}
    3f94:	0f 90       	pop	r0
    3f96:	0f 90       	pop	r0
    3f98:	cf 91       	pop	r28
    3f9a:	df 91       	pop	r29
    3f9c:	08 95       	ret

00003f9e <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
    3f9e:	df 93       	push	r29
    3fa0:	cf 93       	push	r28
    3fa2:	00 d0       	rcall	.+0      	; 0x3fa4 <prvDeleteTCB+0x6>
    3fa4:	cd b7       	in	r28, 0x3d	; 61
    3fa6:	de b7       	in	r29, 0x3e	; 62
    3fa8:	9a 83       	std	Y+2, r25	; 0x02
    3faa:	89 83       	std	Y+1, r24	; 0x01

		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
		{
			/* The task can only have been allocated dynamically - free both
			the stack and TCB. */
			vPortFree( pxTCB->pxStack );
    3fac:	e9 81       	ldd	r30, Y+1	; 0x01
    3fae:	fa 81       	ldd	r31, Y+2	; 0x02
    3fb0:	87 89       	ldd	r24, Z+23	; 0x17
    3fb2:	90 8d       	ldd	r25, Z+24	; 0x18
    3fb4:	0e 94 44 0a 	call	0x1488	; 0x1488 <vPortFree>
			vPortFree( pxTCB );
    3fb8:	89 81       	ldd	r24, Y+1	; 0x01
    3fba:	9a 81       	ldd	r25, Y+2	; 0x02
    3fbc:	0e 94 44 0a 	call	0x1488	; 0x1488 <vPortFree>
				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
	}
    3fc0:	0f 90       	pop	r0
    3fc2:	0f 90       	pop	r0
    3fc4:	cf 91       	pop	r28
    3fc6:	df 91       	pop	r29
    3fc8:	08 95       	ret

00003fca <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    3fca:	df 93       	push	r29
    3fcc:	cf 93       	push	r28
    3fce:	00 d0       	rcall	.+0      	; 0x3fd0 <prvResetNextTaskUnblockTime+0x6>
    3fd0:	cd b7       	in	r28, 0x3d	; 61
    3fd2:	de b7       	in	r29, 0x3e	; 62
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    3fd4:	e0 91 c8 04 	lds	r30, 0x04C8
    3fd8:	f0 91 c9 04 	lds	r31, 0x04C9
    3fdc:	80 81       	ld	r24, Z
    3fde:	88 23       	and	r24, r24
    3fe0:	39 f4       	brne	.+14     	; 0x3ff0 <prvResetNextTaskUnblockTime+0x26>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
    3fe2:	8f ef       	ldi	r24, 0xFF	; 255
    3fe4:	9f ef       	ldi	r25, 0xFF	; 255
    3fe6:	90 93 85 04 	sts	0x0485, r25
    3fea:	80 93 84 04 	sts	0x0484, r24
    3fee:	13 c0       	rjmp	.+38     	; 0x4016 <prvResetNextTaskUnblockTime+0x4c>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    3ff0:	e0 91 c8 04 	lds	r30, 0x04C8
    3ff4:	f0 91 c9 04 	lds	r31, 0x04C9
    3ff8:	05 80       	ldd	r0, Z+5	; 0x05
    3ffa:	f6 81       	ldd	r31, Z+6	; 0x06
    3ffc:	e0 2d       	mov	r30, r0
    3ffe:	86 81       	ldd	r24, Z+6	; 0x06
    4000:	97 81       	ldd	r25, Z+7	; 0x07
    4002:	9a 83       	std	Y+2, r25	; 0x02
    4004:	89 83       	std	Y+1, r24	; 0x01
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
    4006:	e9 81       	ldd	r30, Y+1	; 0x01
    4008:	fa 81       	ldd	r31, Y+2	; 0x02
    400a:	82 81       	ldd	r24, Z+2	; 0x02
    400c:	93 81       	ldd	r25, Z+3	; 0x03
    400e:	90 93 85 04 	sts	0x0485, r25
    4012:	80 93 84 04 	sts	0x0484, r24
	}
}
    4016:	0f 90       	pop	r0
    4018:	0f 90       	pop	r0
    401a:	cf 91       	pop	r28
    401c:	df 91       	pop	r29
    401e:	08 95       	ret

00004020 <uxTaskResetEventItemValue>:

#endif /* ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS > 0 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) ) */
/*-----------------------------------------------------------*/

TickType_t uxTaskResetEventItemValue( void )
{
    4020:	df 93       	push	r29
    4022:	cf 93       	push	r28
    4024:	00 d0       	rcall	.+0      	; 0x4026 <uxTaskResetEventItemValue+0x6>
    4026:	cd b7       	in	r28, 0x3d	; 61
    4028:	de b7       	in	r29, 0x3e	; 62
TickType_t uxReturn;

	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    402a:	e0 91 77 04 	lds	r30, 0x0477
    402e:	f0 91 78 04 	lds	r31, 0x0478
    4032:	84 85       	ldd	r24, Z+12	; 0x0c
    4034:	95 85       	ldd	r25, Z+13	; 0x0d
    4036:	9a 83       	std	Y+2, r25	; 0x02
    4038:	89 83       	std	Y+1, r24	; 0x01

	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    403a:	a0 91 77 04 	lds	r26, 0x0477
    403e:	b0 91 78 04 	lds	r27, 0x0478
    4042:	e0 91 77 04 	lds	r30, 0x0477
    4046:	f0 91 78 04 	lds	r31, 0x0478
    404a:	86 89       	ldd	r24, Z+22	; 0x16
    404c:	28 2f       	mov	r18, r24
    404e:	30 e0       	ldi	r19, 0x00	; 0
    4050:	85 e0       	ldi	r24, 0x05	; 5
    4052:	90 e0       	ldi	r25, 0x00	; 0
    4054:	82 1b       	sub	r24, r18
    4056:	93 0b       	sbc	r25, r19
    4058:	1d 96       	adiw	r26, 0x0d	; 13
    405a:	9c 93       	st	X, r25
    405c:	8e 93       	st	-X, r24
    405e:	1c 97       	sbiw	r26, 0x0c	; 12

	return uxReturn;
    4060:	89 81       	ldd	r24, Y+1	; 0x01
    4062:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4064:	0f 90       	pop	r0
    4066:	0f 90       	pop	r0
    4068:	cf 91       	pop	r28
    406a:	df 91       	pop	r29
    406c:	08 95       	ret

0000406e <ulTaskNotifyTake>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
	{
    406e:	df 93       	push	r29
    4070:	cf 93       	push	r28
    4072:	cd b7       	in	r28, 0x3d	; 61
    4074:	de b7       	in	r29, 0x3e	; 62
    4076:	27 97       	sbiw	r28, 0x07	; 7
    4078:	0f b6       	in	r0, 0x3f	; 63
    407a:	f8 94       	cli
    407c:	de bf       	out	0x3e, r29	; 62
    407e:	0f be       	out	0x3f, r0	; 63
    4080:	cd bf       	out	0x3d, r28	; 61
    4082:	8d 83       	std	Y+5, r24	; 0x05
    4084:	7f 83       	std	Y+7, r23	; 0x07
    4086:	6e 83       	std	Y+6, r22	; 0x06
	uint32_t ulReturn;

		taskENTER_CRITICAL();
    4088:	0f b6       	in	r0, 0x3f	; 63
    408a:	f8 94       	cli
    408c:	0f 92       	push	r0
		{
			/* Only block if the notification count is not already non-zero. */
			if( pxCurrentTCB->ulNotifiedValue == 0UL )
    408e:	e0 91 77 04 	lds	r30, 0x0477
    4092:	f0 91 78 04 	lds	r31, 0x0478
    4096:	81 a1       	ldd	r24, Z+33	; 0x21
    4098:	92 a1       	ldd	r25, Z+34	; 0x22
    409a:	a3 a1       	ldd	r26, Z+35	; 0x23
    409c:	b4 a1       	ldd	r27, Z+36	; 0x24
    409e:	00 97       	sbiw	r24, 0x00	; 0
    40a0:	a1 05       	cpc	r26, r1
    40a2:	b1 05       	cpc	r27, r1
    40a4:	89 f4       	brne	.+34     	; 0x40c8 <ulTaskNotifyTake+0x5a>
			{
				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    40a6:	e0 91 77 04 	lds	r30, 0x0477
    40aa:	f0 91 78 04 	lds	r31, 0x0478
    40ae:	81 e0       	ldi	r24, 0x01	; 1
    40b0:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    40b2:	8e 81       	ldd	r24, Y+6	; 0x06
    40b4:	9f 81       	ldd	r25, Y+7	; 0x07
    40b6:	00 97       	sbiw	r24, 0x00	; 0
    40b8:	39 f0       	breq	.+14     	; 0x40c8 <ulTaskNotifyTake+0x5a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    40ba:	8e 81       	ldd	r24, Y+6	; 0x06
    40bc:	9f 81       	ldd	r25, Y+7	; 0x07
    40be:	61 e0       	ldi	r22, 0x01	; 1
    40c0:	0e 94 3a 24 	call	0x4874	; 0x4874 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    40c4:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    40c8:	0f 90       	pop	r0
    40ca:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    40cc:	0f b6       	in	r0, 0x3f	; 63
    40ce:	f8 94       	cli
    40d0:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_TAKE();
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    40d2:	e0 91 77 04 	lds	r30, 0x0477
    40d6:	f0 91 78 04 	lds	r31, 0x0478
    40da:	81 a1       	ldd	r24, Z+33	; 0x21
    40dc:	92 a1       	ldd	r25, Z+34	; 0x22
    40de:	a3 a1       	ldd	r26, Z+35	; 0x23
    40e0:	b4 a1       	ldd	r27, Z+36	; 0x24
    40e2:	89 83       	std	Y+1, r24	; 0x01
    40e4:	9a 83       	std	Y+2, r25	; 0x02
    40e6:	ab 83       	std	Y+3, r26	; 0x03
    40e8:	bc 83       	std	Y+4, r27	; 0x04

			if( ulReturn != 0UL )
    40ea:	89 81       	ldd	r24, Y+1	; 0x01
    40ec:	9a 81       	ldd	r25, Y+2	; 0x02
    40ee:	ab 81       	ldd	r26, Y+3	; 0x03
    40f0:	bc 81       	ldd	r27, Y+4	; 0x04
    40f2:	00 97       	sbiw	r24, 0x00	; 0
    40f4:	a1 05       	cpc	r26, r1
    40f6:	b1 05       	cpc	r27, r1
    40f8:	d9 f0       	breq	.+54     	; 0x4130 <ulTaskNotifyTake+0xc2>
			{
				if( xClearCountOnExit != pdFALSE )
    40fa:	8d 81       	ldd	r24, Y+5	; 0x05
    40fc:	88 23       	and	r24, r24
    40fe:	49 f0       	breq	.+18     	; 0x4112 <ulTaskNotifyTake+0xa4>
				{
					pxCurrentTCB->ulNotifiedValue = 0UL;
    4100:	e0 91 77 04 	lds	r30, 0x0477
    4104:	f0 91 78 04 	lds	r31, 0x0478
    4108:	11 a2       	std	Z+33, r1	; 0x21
    410a:	12 a2       	std	Z+34, r1	; 0x22
    410c:	13 a2       	std	Z+35, r1	; 0x23
    410e:	14 a2       	std	Z+36, r1	; 0x24
    4110:	0f c0       	rjmp	.+30     	; 0x4130 <ulTaskNotifyTake+0xc2>
				}
				else
				{
					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
    4112:	e0 91 77 04 	lds	r30, 0x0477
    4116:	f0 91 78 04 	lds	r31, 0x0478
    411a:	89 81       	ldd	r24, Y+1	; 0x01
    411c:	9a 81       	ldd	r25, Y+2	; 0x02
    411e:	ab 81       	ldd	r26, Y+3	; 0x03
    4120:	bc 81       	ldd	r27, Y+4	; 0x04
    4122:	01 97       	sbiw	r24, 0x01	; 1
    4124:	a1 09       	sbc	r26, r1
    4126:	b1 09       	sbc	r27, r1
    4128:	81 a3       	std	Z+33, r24	; 0x21
    412a:	92 a3       	std	Z+34, r25	; 0x22
    412c:	a3 a3       	std	Z+35, r26	; 0x23
    412e:	b4 a3       	std	Z+36, r27	; 0x24
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4130:	e0 91 77 04 	lds	r30, 0x0477
    4134:	f0 91 78 04 	lds	r31, 0x0478
    4138:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    413a:	0f 90       	pop	r0
    413c:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    413e:	89 81       	ldd	r24, Y+1	; 0x01
    4140:	9a 81       	ldd	r25, Y+2	; 0x02
    4142:	ab 81       	ldd	r26, Y+3	; 0x03
    4144:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    4146:	bc 01       	movw	r22, r24
    4148:	cd 01       	movw	r24, r26
    414a:	27 96       	adiw	r28, 0x07	; 7
    414c:	0f b6       	in	r0, 0x3f	; 63
    414e:	f8 94       	cli
    4150:	de bf       	out	0x3e, r29	; 62
    4152:	0f be       	out	0x3f, r0	; 63
    4154:	cd bf       	out	0x3d, r28	; 61
    4156:	cf 91       	pop	r28
    4158:	df 91       	pop	r29
    415a:	08 95       	ret

0000415c <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    415c:	ef 92       	push	r14
    415e:	ff 92       	push	r15
    4160:	0f 93       	push	r16
    4162:	1f 93       	push	r17
    4164:	df 93       	push	r29
    4166:	cf 93       	push	r28
    4168:	cd b7       	in	r28, 0x3d	; 61
    416a:	de b7       	in	r29, 0x3e	; 62
    416c:	2d 97       	sbiw	r28, 0x0d	; 13
    416e:	0f b6       	in	r0, 0x3f	; 63
    4170:	f8 94       	cli
    4172:	de bf       	out	0x3e, r29	; 62
    4174:	0f be       	out	0x3f, r0	; 63
    4176:	cd bf       	out	0x3d, r28	; 61
    4178:	6a 83       	std	Y+2, r22	; 0x02
    417a:	7b 83       	std	Y+3, r23	; 0x03
    417c:	8c 83       	std	Y+4, r24	; 0x04
    417e:	9d 83       	std	Y+5, r25	; 0x05
    4180:	2e 83       	std	Y+6, r18	; 0x06
    4182:	3f 83       	std	Y+7, r19	; 0x07
    4184:	48 87       	std	Y+8, r20	; 0x08
    4186:	59 87       	std	Y+9, r21	; 0x09
    4188:	1b 87       	std	Y+11, r17	; 0x0b
    418a:	0a 87       	std	Y+10, r16	; 0x0a
    418c:	fd 86       	std	Y+13, r15	; 0x0d
    418e:	ec 86       	std	Y+12, r14	; 0x0c
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    4190:	0f b6       	in	r0, 0x3f	; 63
    4192:	f8 94       	cli
    4194:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4196:	e0 91 77 04 	lds	r30, 0x0477
    419a:	f0 91 78 04 	lds	r31, 0x0478
    419e:	85 a1       	ldd	r24, Z+37	; 0x25
    41a0:	82 30       	cpi	r24, 0x02	; 2
    41a2:	49 f1       	breq	.+82     	; 0x41f6 <xTaskNotifyWait+0x9a>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    41a4:	e0 91 77 04 	lds	r30, 0x0477
    41a8:	f0 91 78 04 	lds	r31, 0x0478
    41ac:	21 a1       	ldd	r18, Z+33	; 0x21
    41ae:	32 a1       	ldd	r19, Z+34	; 0x22
    41b0:	43 a1       	ldd	r20, Z+35	; 0x23
    41b2:	54 a1       	ldd	r21, Z+36	; 0x24
    41b4:	8a 81       	ldd	r24, Y+2	; 0x02
    41b6:	9b 81       	ldd	r25, Y+3	; 0x03
    41b8:	ac 81       	ldd	r26, Y+4	; 0x04
    41ba:	bd 81       	ldd	r27, Y+5	; 0x05
    41bc:	80 95       	com	r24
    41be:	90 95       	com	r25
    41c0:	a0 95       	com	r26
    41c2:	b0 95       	com	r27
    41c4:	82 23       	and	r24, r18
    41c6:	93 23       	and	r25, r19
    41c8:	a4 23       	and	r26, r20
    41ca:	b5 23       	and	r27, r21
    41cc:	81 a3       	std	Z+33, r24	; 0x21
    41ce:	92 a3       	std	Z+34, r25	; 0x22
    41d0:	a3 a3       	std	Z+35, r26	; 0x23
    41d2:	b4 a3       	std	Z+36, r27	; 0x24

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
    41d4:	e0 91 77 04 	lds	r30, 0x0477
    41d8:	f0 91 78 04 	lds	r31, 0x0478
    41dc:	81 e0       	ldi	r24, 0x01	; 1
    41de:	85 a3       	std	Z+37, r24	; 0x25

				if( xTicksToWait > ( TickType_t ) 0 )
    41e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    41e2:	9d 85       	ldd	r25, Y+13	; 0x0d
    41e4:	00 97       	sbiw	r24, 0x00	; 0
    41e6:	39 f0       	breq	.+14     	; 0x41f6 <xTaskNotifyWait+0x9a>
				{
					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    41e8:	8c 85       	ldd	r24, Y+12	; 0x0c
    41ea:	9d 85       	ldd	r25, Y+13	; 0x0d
    41ec:	61 e0       	ldi	r22, 0x01	; 1
    41ee:	0e 94 3a 24 	call	0x4874	; 0x4874 <prvAddCurrentTaskToDelayedList>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    41f2:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    41f6:	0f 90       	pop	r0
    41f8:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    41fa:	0f b6       	in	r0, 0x3f	; 63
    41fc:	f8 94       	cli
    41fe:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    4200:	8a 85       	ldd	r24, Y+10	; 0x0a
    4202:	9b 85       	ldd	r25, Y+11	; 0x0b
    4204:	00 97       	sbiw	r24, 0x00	; 0
    4206:	71 f0       	breq	.+28     	; 0x4224 <xTaskNotifyWait+0xc8>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    4208:	e0 91 77 04 	lds	r30, 0x0477
    420c:	f0 91 78 04 	lds	r31, 0x0478
    4210:	81 a1       	ldd	r24, Z+33	; 0x21
    4212:	92 a1       	ldd	r25, Z+34	; 0x22
    4214:	a3 a1       	ldd	r26, Z+35	; 0x23
    4216:	b4 a1       	ldd	r27, Z+36	; 0x24
    4218:	ea 85       	ldd	r30, Y+10	; 0x0a
    421a:	fb 85       	ldd	r31, Y+11	; 0x0b
    421c:	80 83       	st	Z, r24
    421e:	91 83       	std	Z+1, r25	; 0x01
    4220:	a2 83       	std	Z+2, r26	; 0x02
    4222:	b3 83       	std	Z+3, r27	; 0x03

			/* If ucNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
    4224:	e0 91 77 04 	lds	r30, 0x0477
    4228:	f0 91 78 04 	lds	r31, 0x0478
    422c:	85 a1       	ldd	r24, Z+37	; 0x25
    422e:	82 30       	cpi	r24, 0x02	; 2
    4230:	11 f0       	breq	.+4      	; 0x4236 <xTaskNotifyWait+0xda>
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    4232:	19 82       	std	Y+1, r1	; 0x01
    4234:	1a c0       	rjmp	.+52     	; 0x426a <xTaskNotifyWait+0x10e>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    4236:	e0 91 77 04 	lds	r30, 0x0477
    423a:	f0 91 78 04 	lds	r31, 0x0478
    423e:	21 a1       	ldd	r18, Z+33	; 0x21
    4240:	32 a1       	ldd	r19, Z+34	; 0x22
    4242:	43 a1       	ldd	r20, Z+35	; 0x23
    4244:	54 a1       	ldd	r21, Z+36	; 0x24
    4246:	8e 81       	ldd	r24, Y+6	; 0x06
    4248:	9f 81       	ldd	r25, Y+7	; 0x07
    424a:	a8 85       	ldd	r26, Y+8	; 0x08
    424c:	b9 85       	ldd	r27, Y+9	; 0x09
    424e:	80 95       	com	r24
    4250:	90 95       	com	r25
    4252:	a0 95       	com	r26
    4254:	b0 95       	com	r27
    4256:	82 23       	and	r24, r18
    4258:	93 23       	and	r25, r19
    425a:	a4 23       	and	r26, r20
    425c:	b5 23       	and	r27, r21
    425e:	81 a3       	std	Z+33, r24	; 0x21
    4260:	92 a3       	std	Z+34, r25	; 0x22
    4262:	a3 a3       	std	Z+35, r26	; 0x23
    4264:	b4 a3       	std	Z+36, r27	; 0x24
				xReturn = pdTRUE;
    4266:	81 e0       	ldi	r24, 0x01	; 1
    4268:	89 83       	std	Y+1, r24	; 0x01
			}

			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    426a:	e0 91 77 04 	lds	r30, 0x0477
    426e:	f0 91 78 04 	lds	r31, 0x0478
    4272:	15 a2       	std	Z+37, r1	; 0x25
		}
		taskEXIT_CRITICAL();
    4274:	0f 90       	pop	r0
    4276:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4278:	89 81       	ldd	r24, Y+1	; 0x01
	}
    427a:	2d 96       	adiw	r28, 0x0d	; 13
    427c:	0f b6       	in	r0, 0x3f	; 63
    427e:	f8 94       	cli
    4280:	de bf       	out	0x3e, r29	; 62
    4282:	0f be       	out	0x3f, r0	; 63
    4284:	cd bf       	out	0x3d, r28	; 61
    4286:	cf 91       	pop	r28
    4288:	df 91       	pop	r29
    428a:	1f 91       	pop	r17
    428c:	0f 91       	pop	r16
    428e:	ff 90       	pop	r15
    4290:	ef 90       	pop	r14
    4292:	08 95       	ret

00004294 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    4294:	0f 93       	push	r16
    4296:	1f 93       	push	r17
    4298:	df 93       	push	r29
    429a:	cf 93       	push	r28
    429c:	cd b7       	in	r28, 0x3d	; 61
    429e:	de b7       	in	r29, 0x3e	; 62
    42a0:	2f 97       	sbiw	r28, 0x0f	; 15
    42a2:	0f b6       	in	r0, 0x3f	; 63
    42a4:	f8 94       	cli
    42a6:	de bf       	out	0x3e, r29	; 62
    42a8:	0f be       	out	0x3f, r0	; 63
    42aa:	cd bf       	out	0x3d, r28	; 61
    42ac:	9e 83       	std	Y+6, r25	; 0x06
    42ae:	8d 83       	std	Y+5, r24	; 0x05
    42b0:	4f 83       	std	Y+7, r20	; 0x07
    42b2:	58 87       	std	Y+8, r21	; 0x08
    42b4:	69 87       	std	Y+9, r22	; 0x09
    42b6:	7a 87       	std	Y+10, r23	; 0x0a
    42b8:	2b 87       	std	Y+11, r18	; 0x0b
    42ba:	1d 87       	std	Y+13, r17	; 0x0d
    42bc:	0c 87       	std	Y+12, r16	; 0x0c
	TCB_t * pxTCB;
	BaseType_t xReturn = pdPASS;
    42be:	81 e0       	ldi	r24, 0x01	; 1
    42c0:	8a 83       	std	Y+2, r24	; 0x02
	uint8_t ucOriginalNotifyState;

		configASSERT( xTaskToNotify );
		pxTCB = xTaskToNotify;
    42c2:	8d 81       	ldd	r24, Y+5	; 0x05
    42c4:	9e 81       	ldd	r25, Y+6	; 0x06
    42c6:	9c 83       	std	Y+4, r25	; 0x04
    42c8:	8b 83       	std	Y+3, r24	; 0x03

		taskENTER_CRITICAL();
    42ca:	0f b6       	in	r0, 0x3f	; 63
    42cc:	f8 94       	cli
    42ce:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    42d0:	8c 85       	ldd	r24, Y+12	; 0x0c
    42d2:	9d 85       	ldd	r25, Y+13	; 0x0d
    42d4:	00 97       	sbiw	r24, 0x00	; 0
    42d6:	61 f0       	breq	.+24     	; 0x42f0 <xTaskGenericNotify+0x5c>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    42d8:	eb 81       	ldd	r30, Y+3	; 0x03
    42da:	fc 81       	ldd	r31, Y+4	; 0x04
    42dc:	81 a1       	ldd	r24, Z+33	; 0x21
    42de:	92 a1       	ldd	r25, Z+34	; 0x22
    42e0:	a3 a1       	ldd	r26, Z+35	; 0x23
    42e2:	b4 a1       	ldd	r27, Z+36	; 0x24
    42e4:	ec 85       	ldd	r30, Y+12	; 0x0c
    42e6:	fd 85       	ldd	r31, Y+13	; 0x0d
    42e8:	80 83       	st	Z, r24
    42ea:	91 83       	std	Z+1, r25	; 0x01
    42ec:	a2 83       	std	Z+2, r26	; 0x02
    42ee:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    42f0:	eb 81       	ldd	r30, Y+3	; 0x03
    42f2:	fc 81       	ldd	r31, Y+4	; 0x04
    42f4:	85 a1       	ldd	r24, Z+37	; 0x25
    42f6:	89 83       	std	Y+1, r24	; 0x01

			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    42f8:	eb 81       	ldd	r30, Y+3	; 0x03
    42fa:	fc 81       	ldd	r31, Y+4	; 0x04
    42fc:	82 e0       	ldi	r24, 0x02	; 2
    42fe:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    4300:	8b 85       	ldd	r24, Y+11	; 0x0b
    4302:	28 2f       	mov	r18, r24
    4304:	30 e0       	ldi	r19, 0x00	; 0
    4306:	3f 87       	std	Y+15, r19	; 0x0f
    4308:	2e 87       	std	Y+14, r18	; 0x0e
    430a:	8e 85       	ldd	r24, Y+14	; 0x0e
    430c:	9f 85       	ldd	r25, Y+15	; 0x0f
    430e:	82 30       	cpi	r24, 0x02	; 2
    4310:	91 05       	cpc	r25, r1
    4312:	59 f1       	breq	.+86     	; 0x436a <xTaskGenericNotify+0xd6>
    4314:	2e 85       	ldd	r18, Y+14	; 0x0e
    4316:	3f 85       	ldd	r19, Y+15	; 0x0f
    4318:	23 30       	cpi	r18, 0x03	; 3
    431a:	31 05       	cpc	r19, r1
    431c:	34 f4       	brge	.+12     	; 0x432a <xTaskGenericNotify+0x96>
    431e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4320:	9f 85       	ldd	r25, Y+15	; 0x0f
    4322:	81 30       	cpi	r24, 0x01	; 1
    4324:	91 05       	cpc	r25, r1
    4326:	61 f0       	breq	.+24     	; 0x4340 <xTaskGenericNotify+0xac>
    4328:	4a c0       	rjmp	.+148    	; 0x43be <xTaskGenericNotify+0x12a>
    432a:	2e 85       	ldd	r18, Y+14	; 0x0e
    432c:	3f 85       	ldd	r19, Y+15	; 0x0f
    432e:	23 30       	cpi	r18, 0x03	; 3
    4330:	31 05       	cpc	r19, r1
    4332:	59 f1       	breq	.+86     	; 0x438a <xTaskGenericNotify+0xf6>
    4334:	8e 85       	ldd	r24, Y+14	; 0x0e
    4336:	9f 85       	ldd	r25, Y+15	; 0x0f
    4338:	84 30       	cpi	r24, 0x04	; 4
    433a:	91 05       	cpc	r25, r1
    433c:	89 f1       	breq	.+98     	; 0x43a0 <xTaskGenericNotify+0x10c>
    433e:	3f c0       	rjmp	.+126    	; 0x43be <xTaskGenericNotify+0x12a>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    4340:	eb 81       	ldd	r30, Y+3	; 0x03
    4342:	fc 81       	ldd	r31, Y+4	; 0x04
    4344:	21 a1       	ldd	r18, Z+33	; 0x21
    4346:	32 a1       	ldd	r19, Z+34	; 0x22
    4348:	43 a1       	ldd	r20, Z+35	; 0x23
    434a:	54 a1       	ldd	r21, Z+36	; 0x24
    434c:	8f 81       	ldd	r24, Y+7	; 0x07
    434e:	98 85       	ldd	r25, Y+8	; 0x08
    4350:	a9 85       	ldd	r26, Y+9	; 0x09
    4352:	ba 85       	ldd	r27, Y+10	; 0x0a
    4354:	82 2b       	or	r24, r18
    4356:	93 2b       	or	r25, r19
    4358:	a4 2b       	or	r26, r20
    435a:	b5 2b       	or	r27, r21
    435c:	eb 81       	ldd	r30, Y+3	; 0x03
    435e:	fc 81       	ldd	r31, Y+4	; 0x04
    4360:	81 a3       	std	Z+33, r24	; 0x21
    4362:	92 a3       	std	Z+34, r25	; 0x22
    4364:	a3 a3       	std	Z+35, r26	; 0x23
    4366:	b4 a3       	std	Z+36, r27	; 0x24
    4368:	2a c0       	rjmp	.+84     	; 0x43be <xTaskGenericNotify+0x12a>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    436a:	eb 81       	ldd	r30, Y+3	; 0x03
    436c:	fc 81       	ldd	r31, Y+4	; 0x04
    436e:	81 a1       	ldd	r24, Z+33	; 0x21
    4370:	92 a1       	ldd	r25, Z+34	; 0x22
    4372:	a3 a1       	ldd	r26, Z+35	; 0x23
    4374:	b4 a1       	ldd	r27, Z+36	; 0x24
    4376:	01 96       	adiw	r24, 0x01	; 1
    4378:	a1 1d       	adc	r26, r1
    437a:	b1 1d       	adc	r27, r1
    437c:	eb 81       	ldd	r30, Y+3	; 0x03
    437e:	fc 81       	ldd	r31, Y+4	; 0x04
    4380:	81 a3       	std	Z+33, r24	; 0x21
    4382:	92 a3       	std	Z+34, r25	; 0x22
    4384:	a3 a3       	std	Z+35, r26	; 0x23
    4386:	b4 a3       	std	Z+36, r27	; 0x24
    4388:	1a c0       	rjmp	.+52     	; 0x43be <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    438a:	eb 81       	ldd	r30, Y+3	; 0x03
    438c:	fc 81       	ldd	r31, Y+4	; 0x04
    438e:	8f 81       	ldd	r24, Y+7	; 0x07
    4390:	98 85       	ldd	r25, Y+8	; 0x08
    4392:	a9 85       	ldd	r26, Y+9	; 0x09
    4394:	ba 85       	ldd	r27, Y+10	; 0x0a
    4396:	81 a3       	std	Z+33, r24	; 0x21
    4398:	92 a3       	std	Z+34, r25	; 0x22
    439a:	a3 a3       	std	Z+35, r26	; 0x23
    439c:	b4 a3       	std	Z+36, r27	; 0x24
    439e:	0f c0       	rjmp	.+30     	; 0x43be <xTaskGenericNotify+0x12a>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    43a0:	89 81       	ldd	r24, Y+1	; 0x01
    43a2:	82 30       	cpi	r24, 0x02	; 2
    43a4:	59 f0       	breq	.+22     	; 0x43bc <xTaskGenericNotify+0x128>
					{
						pxTCB->ulNotifiedValue = ulValue;
    43a6:	eb 81       	ldd	r30, Y+3	; 0x03
    43a8:	fc 81       	ldd	r31, Y+4	; 0x04
    43aa:	8f 81       	ldd	r24, Y+7	; 0x07
    43ac:	98 85       	ldd	r25, Y+8	; 0x08
    43ae:	a9 85       	ldd	r26, Y+9	; 0x09
    43b0:	ba 85       	ldd	r27, Y+10	; 0x0a
    43b2:	81 a3       	std	Z+33, r24	; 0x21
    43b4:	92 a3       	std	Z+34, r25	; 0x22
    43b6:	a3 a3       	std	Z+35, r26	; 0x23
    43b8:	b4 a3       	std	Z+36, r27	; 0x24
    43ba:	01 c0       	rjmp	.+2      	; 0x43be <xTaskGenericNotify+0x12a>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    43bc:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    43be:	89 81       	ldd	r24, Y+1	; 0x01
    43c0:	81 30       	cpi	r24, 0x01	; 1
    43c2:	b9 f5       	brne	.+110    	; 0x4432 <xTaskGenericNotify+0x19e>
			{
				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    43c4:	8b 81       	ldd	r24, Y+3	; 0x03
    43c6:	9c 81       	ldd	r25, Y+4	; 0x04
    43c8:	02 96       	adiw	r24, 0x02	; 2
    43ca:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    43ce:	eb 81       	ldd	r30, Y+3	; 0x03
    43d0:	fc 81       	ldd	r31, Y+4	; 0x04
    43d2:	96 89       	ldd	r25, Z+22	; 0x16
    43d4:	80 91 7d 04 	lds	r24, 0x047D
    43d8:	89 17       	cp	r24, r25
    43da:	28 f4       	brcc	.+10     	; 0x43e6 <xTaskGenericNotify+0x152>
    43dc:	eb 81       	ldd	r30, Y+3	; 0x03
    43de:	fc 81       	ldd	r31, Y+4	; 0x04
    43e0:	86 89       	ldd	r24, Z+22	; 0x16
    43e2:	80 93 7d 04 	sts	0x047D, r24
    43e6:	eb 81       	ldd	r30, Y+3	; 0x03
    43e8:	fc 81       	ldd	r31, Y+4	; 0x04
    43ea:	86 89       	ldd	r24, Z+22	; 0x16
    43ec:	28 2f       	mov	r18, r24
    43ee:	30 e0       	ldi	r19, 0x00	; 0
    43f0:	c9 01       	movw	r24, r18
    43f2:	88 0f       	add	r24, r24
    43f4:	99 1f       	adc	r25, r25
    43f6:	88 0f       	add	r24, r24
    43f8:	99 1f       	adc	r25, r25
    43fa:	88 0f       	add	r24, r24
    43fc:	99 1f       	adc	r25, r25
    43fe:	82 0f       	add	r24, r18
    4400:	93 1f       	adc	r25, r19
    4402:	ac 01       	movw	r20, r24
    4404:	47 57       	subi	r20, 0x77	; 119
    4406:	5b 4f       	sbci	r21, 0xFB	; 251
    4408:	8b 81       	ldd	r24, Y+3	; 0x03
    440a:	9c 81       	ldd	r25, Y+4	; 0x04
    440c:	9c 01       	movw	r18, r24
    440e:	2e 5f       	subi	r18, 0xFE	; 254
    4410:	3f 4f       	sbci	r19, 0xFF	; 255
    4412:	ca 01       	movw	r24, r20
    4414:	b9 01       	movw	r22, r18
    4416:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    441a:	eb 81       	ldd	r30, Y+3	; 0x03
    441c:	fc 81       	ldd	r31, Y+4	; 0x04
    441e:	96 89       	ldd	r25, Z+22	; 0x16
    4420:	e0 91 77 04 	lds	r30, 0x0477
    4424:	f0 91 78 04 	lds	r31, 0x0478
    4428:	86 89       	ldd	r24, Z+22	; 0x16
    442a:	89 17       	cp	r24, r25
    442c:	10 f4       	brcc	.+4      	; 0x4432 <xTaskGenericNotify+0x19e>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    442e:	0e 94 5f 0d 	call	0x1abe	; 0x1abe <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    4432:	0f 90       	pop	r0
    4434:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    4436:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4438:	2f 96       	adiw	r28, 0x0f	; 15
    443a:	0f b6       	in	r0, 0x3f	; 63
    443c:	f8 94       	cli
    443e:	de bf       	out	0x3e, r29	; 62
    4440:	0f be       	out	0x3f, r0	; 63
    4442:	cd bf       	out	0x3d, r28	; 61
    4444:	cf 91       	pop	r28
    4446:	df 91       	pop	r29
    4448:	1f 91       	pop	r17
    444a:	0f 91       	pop	r16
    444c:	08 95       	ret

0000444e <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    444e:	ef 92       	push	r14
    4450:	ff 92       	push	r15
    4452:	0f 93       	push	r16
    4454:	1f 93       	push	r17
    4456:	df 93       	push	r29
    4458:	cf 93       	push	r28
    445a:	cd b7       	in	r28, 0x3d	; 61
    445c:	de b7       	in	r29, 0x3e	; 62
    445e:	62 97       	sbiw	r28, 0x12	; 18
    4460:	0f b6       	in	r0, 0x3f	; 63
    4462:	f8 94       	cli
    4464:	de bf       	out	0x3e, r29	; 62
    4466:	0f be       	out	0x3f, r0	; 63
    4468:	cd bf       	out	0x3d, r28	; 61
    446a:	9f 83       	std	Y+7, r25	; 0x07
    446c:	8e 83       	std	Y+6, r24	; 0x06
    446e:	48 87       	std	Y+8, r20	; 0x08
    4470:	59 87       	std	Y+9, r21	; 0x09
    4472:	6a 87       	std	Y+10, r22	; 0x0a
    4474:	7b 87       	std	Y+11, r23	; 0x0b
    4476:	2c 87       	std	Y+12, r18	; 0x0c
    4478:	1e 87       	std	Y+14, r17	; 0x0e
    447a:	0d 87       	std	Y+13, r16	; 0x0d
    447c:	f8 8a       	std	Y+16, r15	; 0x10
    447e:	ef 86       	std	Y+15, r14	; 0x0f
	TCB_t * pxTCB;
	uint8_t ucOriginalNotifyState;
	BaseType_t xReturn = pdPASS;
    4480:	81 e0       	ldi	r24, 0x01	; 1
    4482:	8a 83       	std	Y+2, r24	; 0x02
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    4484:	8e 81       	ldd	r24, Y+6	; 0x06
    4486:	9f 81       	ldd	r25, Y+7	; 0x07
    4488:	9d 83       	std	Y+5, r25	; 0x05
    448a:	8c 83       	std	Y+4, r24	; 0x04

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    448c:	19 82       	std	Y+1, r1	; 0x01
		{
			if( pulPreviousNotificationValue != NULL )
    448e:	8d 85       	ldd	r24, Y+13	; 0x0d
    4490:	9e 85       	ldd	r25, Y+14	; 0x0e
    4492:	00 97       	sbiw	r24, 0x00	; 0
    4494:	61 f0       	breq	.+24     	; 0x44ae <xTaskGenericNotifyFromISR+0x60>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    4496:	ec 81       	ldd	r30, Y+4	; 0x04
    4498:	fd 81       	ldd	r31, Y+5	; 0x05
    449a:	81 a1       	ldd	r24, Z+33	; 0x21
    449c:	92 a1       	ldd	r25, Z+34	; 0x22
    449e:	a3 a1       	ldd	r26, Z+35	; 0x23
    44a0:	b4 a1       	ldd	r27, Z+36	; 0x24
    44a2:	ed 85       	ldd	r30, Y+13	; 0x0d
    44a4:	fe 85       	ldd	r31, Y+14	; 0x0e
    44a6:	80 83       	st	Z, r24
    44a8:	91 83       	std	Z+1, r25	; 0x01
    44aa:	a2 83       	std	Z+2, r26	; 0x02
    44ac:	b3 83       	std	Z+3, r27	; 0x03
			}

			ucOriginalNotifyState = pxTCB->ucNotifyState;
    44ae:	ec 81       	ldd	r30, Y+4	; 0x04
    44b0:	fd 81       	ldd	r31, Y+5	; 0x05
    44b2:	85 a1       	ldd	r24, Z+37	; 0x25
    44b4:	8b 83       	std	Y+3, r24	; 0x03
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    44b6:	ec 81       	ldd	r30, Y+4	; 0x04
    44b8:	fd 81       	ldd	r31, Y+5	; 0x05
    44ba:	82 e0       	ldi	r24, 0x02	; 2
    44bc:	85 a3       	std	Z+37, r24	; 0x25

			switch( eAction )
    44be:	8c 85       	ldd	r24, Y+12	; 0x0c
    44c0:	28 2f       	mov	r18, r24
    44c2:	30 e0       	ldi	r19, 0x00	; 0
    44c4:	3a 8b       	std	Y+18, r19	; 0x12
    44c6:	29 8b       	std	Y+17, r18	; 0x11
    44c8:	89 89       	ldd	r24, Y+17	; 0x11
    44ca:	9a 89       	ldd	r25, Y+18	; 0x12
    44cc:	82 30       	cpi	r24, 0x02	; 2
    44ce:	91 05       	cpc	r25, r1
    44d0:	59 f1       	breq	.+86     	; 0x4528 <xTaskGenericNotifyFromISR+0xda>
    44d2:	29 89       	ldd	r18, Y+17	; 0x11
    44d4:	3a 89       	ldd	r19, Y+18	; 0x12
    44d6:	23 30       	cpi	r18, 0x03	; 3
    44d8:	31 05       	cpc	r19, r1
    44da:	34 f4       	brge	.+12     	; 0x44e8 <xTaskGenericNotifyFromISR+0x9a>
    44dc:	89 89       	ldd	r24, Y+17	; 0x11
    44de:	9a 89       	ldd	r25, Y+18	; 0x12
    44e0:	81 30       	cpi	r24, 0x01	; 1
    44e2:	91 05       	cpc	r25, r1
    44e4:	61 f0       	breq	.+24     	; 0x44fe <xTaskGenericNotifyFromISR+0xb0>
    44e6:	4a c0       	rjmp	.+148    	; 0x457c <xTaskGenericNotifyFromISR+0x12e>
    44e8:	29 89       	ldd	r18, Y+17	; 0x11
    44ea:	3a 89       	ldd	r19, Y+18	; 0x12
    44ec:	23 30       	cpi	r18, 0x03	; 3
    44ee:	31 05       	cpc	r19, r1
    44f0:	59 f1       	breq	.+86     	; 0x4548 <xTaskGenericNotifyFromISR+0xfa>
    44f2:	89 89       	ldd	r24, Y+17	; 0x11
    44f4:	9a 89       	ldd	r25, Y+18	; 0x12
    44f6:	84 30       	cpi	r24, 0x04	; 4
    44f8:	91 05       	cpc	r25, r1
    44fa:	89 f1       	breq	.+98     	; 0x455e <xTaskGenericNotifyFromISR+0x110>
    44fc:	3f c0       	rjmp	.+126    	; 0x457c <xTaskGenericNotifyFromISR+0x12e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    44fe:	ec 81       	ldd	r30, Y+4	; 0x04
    4500:	fd 81       	ldd	r31, Y+5	; 0x05
    4502:	21 a1       	ldd	r18, Z+33	; 0x21
    4504:	32 a1       	ldd	r19, Z+34	; 0x22
    4506:	43 a1       	ldd	r20, Z+35	; 0x23
    4508:	54 a1       	ldd	r21, Z+36	; 0x24
    450a:	88 85       	ldd	r24, Y+8	; 0x08
    450c:	99 85       	ldd	r25, Y+9	; 0x09
    450e:	aa 85       	ldd	r26, Y+10	; 0x0a
    4510:	bb 85       	ldd	r27, Y+11	; 0x0b
    4512:	82 2b       	or	r24, r18
    4514:	93 2b       	or	r25, r19
    4516:	a4 2b       	or	r26, r20
    4518:	b5 2b       	or	r27, r21
    451a:	ec 81       	ldd	r30, Y+4	; 0x04
    451c:	fd 81       	ldd	r31, Y+5	; 0x05
    451e:	81 a3       	std	Z+33, r24	; 0x21
    4520:	92 a3       	std	Z+34, r25	; 0x22
    4522:	a3 a3       	std	Z+35, r26	; 0x23
    4524:	b4 a3       	std	Z+36, r27	; 0x24
    4526:	2a c0       	rjmp	.+84     	; 0x457c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    4528:	ec 81       	ldd	r30, Y+4	; 0x04
    452a:	fd 81       	ldd	r31, Y+5	; 0x05
    452c:	81 a1       	ldd	r24, Z+33	; 0x21
    452e:	92 a1       	ldd	r25, Z+34	; 0x22
    4530:	a3 a1       	ldd	r26, Z+35	; 0x23
    4532:	b4 a1       	ldd	r27, Z+36	; 0x24
    4534:	01 96       	adiw	r24, 0x01	; 1
    4536:	a1 1d       	adc	r26, r1
    4538:	b1 1d       	adc	r27, r1
    453a:	ec 81       	ldd	r30, Y+4	; 0x04
    453c:	fd 81       	ldd	r31, Y+5	; 0x05
    453e:	81 a3       	std	Z+33, r24	; 0x21
    4540:	92 a3       	std	Z+34, r25	; 0x22
    4542:	a3 a3       	std	Z+35, r26	; 0x23
    4544:	b4 a3       	std	Z+36, r27	; 0x24
    4546:	1a c0       	rjmp	.+52     	; 0x457c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    4548:	ec 81       	ldd	r30, Y+4	; 0x04
    454a:	fd 81       	ldd	r31, Y+5	; 0x05
    454c:	88 85       	ldd	r24, Y+8	; 0x08
    454e:	99 85       	ldd	r25, Y+9	; 0x09
    4550:	aa 85       	ldd	r26, Y+10	; 0x0a
    4552:	bb 85       	ldd	r27, Y+11	; 0x0b
    4554:	81 a3       	std	Z+33, r24	; 0x21
    4556:	92 a3       	std	Z+34, r25	; 0x22
    4558:	a3 a3       	std	Z+35, r26	; 0x23
    455a:	b4 a3       	std	Z+36, r27	; 0x24
    455c:	0f c0       	rjmp	.+30     	; 0x457c <xTaskGenericNotifyFromISR+0x12e>
					break;

				case eSetValueWithoutOverwrite :
					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    455e:	8b 81       	ldd	r24, Y+3	; 0x03
    4560:	82 30       	cpi	r24, 0x02	; 2
    4562:	59 f0       	breq	.+22     	; 0x457a <xTaskGenericNotifyFromISR+0x12c>
					{
						pxTCB->ulNotifiedValue = ulValue;
    4564:	ec 81       	ldd	r30, Y+4	; 0x04
    4566:	fd 81       	ldd	r31, Y+5	; 0x05
    4568:	88 85       	ldd	r24, Y+8	; 0x08
    456a:	99 85       	ldd	r25, Y+9	; 0x09
    456c:	aa 85       	ldd	r26, Y+10	; 0x0a
    456e:	bb 85       	ldd	r27, Y+11	; 0x0b
    4570:	81 a3       	std	Z+33, r24	; 0x21
    4572:	92 a3       	std	Z+34, r25	; 0x22
    4574:	a3 a3       	std	Z+35, r26	; 0x23
    4576:	b4 a3       	std	Z+36, r27	; 0x24
    4578:	01 c0       	rjmp	.+2      	; 0x457c <xTaskGenericNotifyFromISR+0x12e>
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    457a:	1a 82       	std	Y+2, r1	; 0x02

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    457c:	8b 81       	ldd	r24, Y+3	; 0x03
    457e:	81 30       	cpi	r24, 0x01	; 1
    4580:	09 f0       	breq	.+2      	; 0x4584 <xTaskGenericNotifyFromISR+0x136>
    4582:	4f c0       	rjmp	.+158    	; 0x4622 <xTaskGenericNotifyFromISR+0x1d4>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4584:	80 91 88 04 	lds	r24, 0x0488
    4588:	88 23       	and	r24, r24
    458a:	61 f5       	brne	.+88     	; 0x45e4 <xTaskGenericNotifyFromISR+0x196>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    458c:	8c 81       	ldd	r24, Y+4	; 0x04
    458e:	9d 81       	ldd	r25, Y+5	; 0x05
    4590:	02 96       	adiw	r24, 0x02	; 2
    4592:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    4596:	ec 81       	ldd	r30, Y+4	; 0x04
    4598:	fd 81       	ldd	r31, Y+5	; 0x05
    459a:	96 89       	ldd	r25, Z+22	; 0x16
    459c:	80 91 7d 04 	lds	r24, 0x047D
    45a0:	89 17       	cp	r24, r25
    45a2:	28 f4       	brcc	.+10     	; 0x45ae <xTaskGenericNotifyFromISR+0x160>
    45a4:	ec 81       	ldd	r30, Y+4	; 0x04
    45a6:	fd 81       	ldd	r31, Y+5	; 0x05
    45a8:	86 89       	ldd	r24, Z+22	; 0x16
    45aa:	80 93 7d 04 	sts	0x047D, r24
    45ae:	ec 81       	ldd	r30, Y+4	; 0x04
    45b0:	fd 81       	ldd	r31, Y+5	; 0x05
    45b2:	86 89       	ldd	r24, Z+22	; 0x16
    45b4:	28 2f       	mov	r18, r24
    45b6:	30 e0       	ldi	r19, 0x00	; 0
    45b8:	c9 01       	movw	r24, r18
    45ba:	88 0f       	add	r24, r24
    45bc:	99 1f       	adc	r25, r25
    45be:	88 0f       	add	r24, r24
    45c0:	99 1f       	adc	r25, r25
    45c2:	88 0f       	add	r24, r24
    45c4:	99 1f       	adc	r25, r25
    45c6:	82 0f       	add	r24, r18
    45c8:	93 1f       	adc	r25, r19
    45ca:	ac 01       	movw	r20, r24
    45cc:	47 57       	subi	r20, 0x77	; 119
    45ce:	5b 4f       	sbci	r21, 0xFB	; 251
    45d0:	8c 81       	ldd	r24, Y+4	; 0x04
    45d2:	9d 81       	ldd	r25, Y+5	; 0x05
    45d4:	9c 01       	movw	r18, r24
    45d6:	2e 5f       	subi	r18, 0xFE	; 254
    45d8:	3f 4f       	sbci	r19, 0xFF	; 255
    45da:	ca 01       	movw	r24, r20
    45dc:	b9 01       	movw	r22, r18
    45de:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>
    45e2:	0a c0       	rjmp	.+20     	; 0x45f8 <xTaskGenericNotifyFromISR+0x1aa>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    45e4:	8c 81       	ldd	r24, Y+4	; 0x04
    45e6:	9d 81       	ldd	r25, Y+5	; 0x05
    45e8:	9c 01       	movw	r18, r24
    45ea:	24 5f       	subi	r18, 0xF4	; 244
    45ec:	3f 4f       	sbci	r19, 0xFF	; 255
    45ee:	8c ec       	ldi	r24, 0xCC	; 204
    45f0:	94 e0       	ldi	r25, 0x04	; 4
    45f2:	b9 01       	movw	r22, r18
    45f4:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    45f8:	ec 81       	ldd	r30, Y+4	; 0x04
    45fa:	fd 81       	ldd	r31, Y+5	; 0x05
    45fc:	96 89       	ldd	r25, Z+22	; 0x16
    45fe:	e0 91 77 04 	lds	r30, 0x0477
    4602:	f0 91 78 04 	lds	r31, 0x0478
    4606:	86 89       	ldd	r24, Z+22	; 0x16
    4608:	89 17       	cp	r24, r25
    460a:	58 f4       	brcc	.+22     	; 0x4622 <xTaskGenericNotifyFromISR+0x1d4>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    460c:	8f 85       	ldd	r24, Y+15	; 0x0f
    460e:	98 89       	ldd	r25, Y+16	; 0x10
    4610:	00 97       	sbiw	r24, 0x00	; 0
    4612:	21 f0       	breq	.+8      	; 0x461c <xTaskGenericNotifyFromISR+0x1ce>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    4614:	ef 85       	ldd	r30, Y+15	; 0x0f
    4616:	f8 89       	ldd	r31, Y+16	; 0x10
    4618:	81 e0       	ldi	r24, 0x01	; 1
    461a:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter to an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    461c:	81 e0       	ldi	r24, 0x01	; 1
    461e:	80 93 81 04 	sts	0x0481, r24
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
    4622:	8a 81       	ldd	r24, Y+2	; 0x02
	}
    4624:	62 96       	adiw	r28, 0x12	; 18
    4626:	0f b6       	in	r0, 0x3f	; 63
    4628:	f8 94       	cli
    462a:	de bf       	out	0x3e, r29	; 62
    462c:	0f be       	out	0x3f, r0	; 63
    462e:	cd bf       	out	0x3d, r28	; 61
    4630:	cf 91       	pop	r28
    4632:	df 91       	pop	r29
    4634:	1f 91       	pop	r17
    4636:	0f 91       	pop	r16
    4638:	ff 90       	pop	r15
    463a:	ef 90       	pop	r14
    463c:	08 95       	ret

0000463e <vTaskNotifyGiveFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
	{
    463e:	df 93       	push	r29
    4640:	cf 93       	push	r28
    4642:	cd b7       	in	r28, 0x3d	; 61
    4644:	de b7       	in	r29, 0x3e	; 62
    4646:	28 97       	sbiw	r28, 0x08	; 8
    4648:	0f b6       	in	r0, 0x3f	; 63
    464a:	f8 94       	cli
    464c:	de bf       	out	0x3e, r29	; 62
    464e:	0f be       	out	0x3f, r0	; 63
    4650:	cd bf       	out	0x3d, r28	; 61
    4652:	9e 83       	std	Y+6, r25	; 0x06
    4654:	8d 83       	std	Y+5, r24	; 0x05
    4656:	78 87       	std	Y+8, r23	; 0x08
    4658:	6f 83       	std	Y+7, r22	; 0x07
		simple as possible.  More information (albeit Cortex-M specific) is
		provided on the following link:
		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

		pxTCB = xTaskToNotify;
    465a:	8d 81       	ldd	r24, Y+5	; 0x05
    465c:	9e 81       	ldd	r25, Y+6	; 0x06
    465e:	9c 83       	std	Y+4, r25	; 0x04
    4660:	8b 83       	std	Y+3, r24	; 0x03

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4662:	19 82       	std	Y+1, r1	; 0x01
		{
			ucOriginalNotifyState = pxTCB->ucNotifyState;
    4664:	eb 81       	ldd	r30, Y+3	; 0x03
    4666:	fc 81       	ldd	r31, Y+4	; 0x04
    4668:	85 a1       	ldd	r24, Z+37	; 0x25
    466a:	8a 83       	std	Y+2, r24	; 0x02
			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
    466c:	eb 81       	ldd	r30, Y+3	; 0x03
    466e:	fc 81       	ldd	r31, Y+4	; 0x04
    4670:	82 e0       	ldi	r24, 0x02	; 2
    4672:	85 a3       	std	Z+37, r24	; 0x25

			/* 'Giving' is equivalent to incrementing a count in a counting
			semaphore. */
			( pxTCB->ulNotifiedValue )++;
    4674:	eb 81       	ldd	r30, Y+3	; 0x03
    4676:	fc 81       	ldd	r31, Y+4	; 0x04
    4678:	81 a1       	ldd	r24, Z+33	; 0x21
    467a:	92 a1       	ldd	r25, Z+34	; 0x22
    467c:	a3 a1       	ldd	r26, Z+35	; 0x23
    467e:	b4 a1       	ldd	r27, Z+36	; 0x24
    4680:	01 96       	adiw	r24, 0x01	; 1
    4682:	a1 1d       	adc	r26, r1
    4684:	b1 1d       	adc	r27, r1
    4686:	eb 81       	ldd	r30, Y+3	; 0x03
    4688:	fc 81       	ldd	r31, Y+4	; 0x04
    468a:	81 a3       	std	Z+33, r24	; 0x21
    468c:	92 a3       	std	Z+34, r25	; 0x22
    468e:	a3 a3       	std	Z+35, r26	; 0x23
    4690:	b4 a3       	std	Z+36, r27	; 0x24

			traceTASK_NOTIFY_GIVE_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    4692:	8a 81       	ldd	r24, Y+2	; 0x02
    4694:	81 30       	cpi	r24, 0x01	; 1
    4696:	09 f0       	breq	.+2      	; 0x469a <vTaskNotifyGiveFromISR+0x5c>
    4698:	4f c0       	rjmp	.+158    	; 0x4738 <vTaskNotifyGiveFromISR+0xfa>
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    469a:	80 91 88 04 	lds	r24, 0x0488
    469e:	88 23       	and	r24, r24
    46a0:	61 f5       	brne	.+88     	; 0x46fa <vTaskNotifyGiveFromISR+0xbc>
				{
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    46a2:	8b 81       	ldd	r24, Y+3	; 0x03
    46a4:	9c 81       	ldd	r25, Y+4	; 0x04
    46a6:	02 96       	adiw	r24, 0x02	; 2
    46a8:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    46ac:	eb 81       	ldd	r30, Y+3	; 0x03
    46ae:	fc 81       	ldd	r31, Y+4	; 0x04
    46b0:	96 89       	ldd	r25, Z+22	; 0x16
    46b2:	80 91 7d 04 	lds	r24, 0x047D
    46b6:	89 17       	cp	r24, r25
    46b8:	28 f4       	brcc	.+10     	; 0x46c4 <vTaskNotifyGiveFromISR+0x86>
    46ba:	eb 81       	ldd	r30, Y+3	; 0x03
    46bc:	fc 81       	ldd	r31, Y+4	; 0x04
    46be:	86 89       	ldd	r24, Z+22	; 0x16
    46c0:	80 93 7d 04 	sts	0x047D, r24
    46c4:	eb 81       	ldd	r30, Y+3	; 0x03
    46c6:	fc 81       	ldd	r31, Y+4	; 0x04
    46c8:	86 89       	ldd	r24, Z+22	; 0x16
    46ca:	28 2f       	mov	r18, r24
    46cc:	30 e0       	ldi	r19, 0x00	; 0
    46ce:	c9 01       	movw	r24, r18
    46d0:	88 0f       	add	r24, r24
    46d2:	99 1f       	adc	r25, r25
    46d4:	88 0f       	add	r24, r24
    46d6:	99 1f       	adc	r25, r25
    46d8:	88 0f       	add	r24, r24
    46da:	99 1f       	adc	r25, r25
    46dc:	82 0f       	add	r24, r18
    46de:	93 1f       	adc	r25, r19
    46e0:	ac 01       	movw	r20, r24
    46e2:	47 57       	subi	r20, 0x77	; 119
    46e4:	5b 4f       	sbci	r21, 0xFB	; 251
    46e6:	8b 81       	ldd	r24, Y+3	; 0x03
    46e8:	9c 81       	ldd	r25, Y+4	; 0x04
    46ea:	9c 01       	movw	r18, r24
    46ec:	2e 5f       	subi	r18, 0xFE	; 254
    46ee:	3f 4f       	sbci	r19, 0xFF	; 255
    46f0:	ca 01       	movw	r24, r20
    46f2:	b9 01       	movw	r22, r18
    46f4:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>
    46f8:	0a c0       	rjmp	.+20     	; 0x470e <vTaskNotifyGiveFromISR+0xd0>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    46fa:	8b 81       	ldd	r24, Y+3	; 0x03
    46fc:	9c 81       	ldd	r25, Y+4	; 0x04
    46fe:	9c 01       	movw	r18, r24
    4700:	24 5f       	subi	r18, 0xF4	; 244
    4702:	3f 4f       	sbci	r19, 0xFF	; 255
    4704:	8c ec       	ldi	r24, 0xCC	; 204
    4706:	94 e0       	ldi	r25, 0x04	; 4
    4708:	b9 01       	movw	r22, r18
    470a:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    470e:	eb 81       	ldd	r30, Y+3	; 0x03
    4710:	fc 81       	ldd	r31, Y+4	; 0x04
    4712:	96 89       	ldd	r25, Z+22	; 0x16
    4714:	e0 91 77 04 	lds	r30, 0x0477
    4718:	f0 91 78 04 	lds	r31, 0x0478
    471c:	86 89       	ldd	r24, Z+22	; 0x16
    471e:	89 17       	cp	r24, r25
    4720:	58 f4       	brcc	.+22     	; 0x4738 <vTaskNotifyGiveFromISR+0xfa>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    4722:	8f 81       	ldd	r24, Y+7	; 0x07
    4724:	98 85       	ldd	r25, Y+8	; 0x08
    4726:	00 97       	sbiw	r24, 0x00	; 0
    4728:	21 f0       	breq	.+8      	; 0x4732 <vTaskNotifyGiveFromISR+0xf4>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    472a:	ef 81       	ldd	r30, Y+7	; 0x07
    472c:	f8 85       	ldd	r31, Y+8	; 0x08
    472e:	81 e0       	ldi	r24, 0x01	; 1
    4730:	80 83       	st	Z, r24
					}

					/* Mark that a yield is pending in case the user is not
					using the "xHigherPriorityTaskWoken" parameter in an ISR
					safe FreeRTOS function. */
					xYieldPending = pdTRUE;
    4732:	81 e0       	ldi	r24, 0x01	; 1
    4734:	80 93 81 04 	sts	0x0481, r24
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
    4738:	28 96       	adiw	r28, 0x08	; 8
    473a:	0f b6       	in	r0, 0x3f	; 63
    473c:	f8 94       	cli
    473e:	de bf       	out	0x3e, r29	; 62
    4740:	0f be       	out	0x3f, r0	; 63
    4742:	cd bf       	out	0x3d, r28	; 61
    4744:	cf 91       	pop	r28
    4746:	df 91       	pop	r29
    4748:	08 95       	ret

0000474a <xTaskNotifyStateClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
	{
    474a:	df 93       	push	r29
    474c:	cf 93       	push	r28
    474e:	cd b7       	in	r28, 0x3d	; 61
    4750:	de b7       	in	r29, 0x3e	; 62
    4752:	27 97       	sbiw	r28, 0x07	; 7
    4754:	0f b6       	in	r0, 0x3f	; 63
    4756:	f8 94       	cli
    4758:	de bf       	out	0x3e, r29	; 62
    475a:	0f be       	out	0x3f, r0	; 63
    475c:	cd bf       	out	0x3d, r28	; 61
    475e:	9d 83       	std	Y+5, r25	; 0x05
    4760:	8c 83       	std	Y+4, r24	; 0x04
	TCB_t *pxTCB;
	BaseType_t xReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    4762:	8c 81       	ldd	r24, Y+4	; 0x04
    4764:	9d 81       	ldd	r25, Y+5	; 0x05
    4766:	00 97       	sbiw	r24, 0x00	; 0
    4768:	39 f4       	brne	.+14     	; 0x4778 <xTaskNotifyStateClear+0x2e>
    476a:	80 91 77 04 	lds	r24, 0x0477
    476e:	90 91 78 04 	lds	r25, 0x0478
    4772:	9f 83       	std	Y+7, r25	; 0x07
    4774:	8e 83       	std	Y+6, r24	; 0x06
    4776:	04 c0       	rjmp	.+8      	; 0x4780 <xTaskNotifyStateClear+0x36>
    4778:	8c 81       	ldd	r24, Y+4	; 0x04
    477a:	9d 81       	ldd	r25, Y+5	; 0x05
    477c:	9f 83       	std	Y+7, r25	; 0x07
    477e:	8e 83       	std	Y+6, r24	; 0x06
    4780:	8e 81       	ldd	r24, Y+6	; 0x06
    4782:	9f 81       	ldd	r25, Y+7	; 0x07
    4784:	9b 83       	std	Y+3, r25	; 0x03
    4786:	8a 83       	std	Y+2, r24	; 0x02

		taskENTER_CRITICAL();
    4788:	0f b6       	in	r0, 0x3f	; 63
    478a:	f8 94       	cli
    478c:	0f 92       	push	r0
		{
			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
    478e:	ea 81       	ldd	r30, Y+2	; 0x02
    4790:	fb 81       	ldd	r31, Y+3	; 0x03
    4792:	85 a1       	ldd	r24, Z+37	; 0x25
    4794:	82 30       	cpi	r24, 0x02	; 2
    4796:	31 f4       	brne	.+12     	; 0x47a4 <xTaskNotifyStateClear+0x5a>
			{
				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
    4798:	ea 81       	ldd	r30, Y+2	; 0x02
    479a:	fb 81       	ldd	r31, Y+3	; 0x03
    479c:	15 a2       	std	Z+37, r1	; 0x25
				xReturn = pdPASS;
    479e:	81 e0       	ldi	r24, 0x01	; 1
    47a0:	89 83       	std	Y+1, r24	; 0x01
    47a2:	01 c0       	rjmp	.+2      	; 0x47a6 <xTaskNotifyStateClear+0x5c>
			}
			else
			{
				xReturn = pdFAIL;
    47a4:	19 82       	std	Y+1, r1	; 0x01
			}
		}
		taskEXIT_CRITICAL();
    47a6:	0f 90       	pop	r0
    47a8:	0f be       	out	0x3f, r0	; 63

		return xReturn;
    47aa:	89 81       	ldd	r24, Y+1	; 0x01
	}
    47ac:	27 96       	adiw	r28, 0x07	; 7
    47ae:	0f b6       	in	r0, 0x3f	; 63
    47b0:	f8 94       	cli
    47b2:	de bf       	out	0x3e, r29	; 62
    47b4:	0f be       	out	0x3f, r0	; 63
    47b6:	cd bf       	out	0x3d, r28	; 61
    47b8:	cf 91       	pop	r28
    47ba:	df 91       	pop	r29
    47bc:	08 95       	ret

000047be <ulTaskNotifyValueClear>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	uint32_t ulTaskNotifyValueClear( TaskHandle_t xTask, uint32_t ulBitsToClear )
	{
    47be:	df 93       	push	r29
    47c0:	cf 93       	push	r28
    47c2:	cd b7       	in	r28, 0x3d	; 61
    47c4:	de b7       	in	r29, 0x3e	; 62
    47c6:	2e 97       	sbiw	r28, 0x0e	; 14
    47c8:	0f b6       	in	r0, 0x3f	; 63
    47ca:	f8 94       	cli
    47cc:	de bf       	out	0x3e, r29	; 62
    47ce:	0f be       	out	0x3f, r0	; 63
    47d0:	cd bf       	out	0x3d, r28	; 61
    47d2:	98 87       	std	Y+8, r25	; 0x08
    47d4:	8f 83       	std	Y+7, r24	; 0x07
    47d6:	49 87       	std	Y+9, r20	; 0x09
    47d8:	5a 87       	std	Y+10, r21	; 0x0a
    47da:	6b 87       	std	Y+11, r22	; 0x0b
    47dc:	7c 87       	std	Y+12, r23	; 0x0c
	TCB_t *pxTCB;
	uint32_t ulReturn;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( xTask );
    47de:	8f 81       	ldd	r24, Y+7	; 0x07
    47e0:	98 85       	ldd	r25, Y+8	; 0x08
    47e2:	00 97       	sbiw	r24, 0x00	; 0
    47e4:	39 f4       	brne	.+14     	; 0x47f4 <ulTaskNotifyValueClear+0x36>
    47e6:	80 91 77 04 	lds	r24, 0x0477
    47ea:	90 91 78 04 	lds	r25, 0x0478
    47ee:	9e 87       	std	Y+14, r25	; 0x0e
    47f0:	8d 87       	std	Y+13, r24	; 0x0d
    47f2:	04 c0       	rjmp	.+8      	; 0x47fc <ulTaskNotifyValueClear+0x3e>
    47f4:	8f 81       	ldd	r24, Y+7	; 0x07
    47f6:	98 85       	ldd	r25, Y+8	; 0x08
    47f8:	9e 87       	std	Y+14, r25	; 0x0e
    47fa:	8d 87       	std	Y+13, r24	; 0x0d
    47fc:	8d 85       	ldd	r24, Y+13	; 0x0d
    47fe:	9e 85       	ldd	r25, Y+14	; 0x0e
    4800:	9e 83       	std	Y+6, r25	; 0x06
    4802:	8d 83       	std	Y+5, r24	; 0x05

		taskENTER_CRITICAL();
    4804:	0f b6       	in	r0, 0x3f	; 63
    4806:	f8 94       	cli
    4808:	0f 92       	push	r0
		{
			/* Return the notification as it was before the bits were cleared,
			then clear the bit mask. */
			ulReturn = pxCurrentTCB->ulNotifiedValue;
    480a:	e0 91 77 04 	lds	r30, 0x0477
    480e:	f0 91 78 04 	lds	r31, 0x0478
    4812:	81 a1       	ldd	r24, Z+33	; 0x21
    4814:	92 a1       	ldd	r25, Z+34	; 0x22
    4816:	a3 a1       	ldd	r26, Z+35	; 0x23
    4818:	b4 a1       	ldd	r27, Z+36	; 0x24
    481a:	89 83       	std	Y+1, r24	; 0x01
    481c:	9a 83       	std	Y+2, r25	; 0x02
    481e:	ab 83       	std	Y+3, r26	; 0x03
    4820:	bc 83       	std	Y+4, r27	; 0x04
			pxTCB->ulNotifiedValue &= ~ulBitsToClear;
    4822:	ed 81       	ldd	r30, Y+5	; 0x05
    4824:	fe 81       	ldd	r31, Y+6	; 0x06
    4826:	21 a1       	ldd	r18, Z+33	; 0x21
    4828:	32 a1       	ldd	r19, Z+34	; 0x22
    482a:	43 a1       	ldd	r20, Z+35	; 0x23
    482c:	54 a1       	ldd	r21, Z+36	; 0x24
    482e:	89 85       	ldd	r24, Y+9	; 0x09
    4830:	9a 85       	ldd	r25, Y+10	; 0x0a
    4832:	ab 85       	ldd	r26, Y+11	; 0x0b
    4834:	bc 85       	ldd	r27, Y+12	; 0x0c
    4836:	80 95       	com	r24
    4838:	90 95       	com	r25
    483a:	a0 95       	com	r26
    483c:	b0 95       	com	r27
    483e:	82 23       	and	r24, r18
    4840:	93 23       	and	r25, r19
    4842:	a4 23       	and	r26, r20
    4844:	b5 23       	and	r27, r21
    4846:	ed 81       	ldd	r30, Y+5	; 0x05
    4848:	fe 81       	ldd	r31, Y+6	; 0x06
    484a:	81 a3       	std	Z+33, r24	; 0x21
    484c:	92 a3       	std	Z+34, r25	; 0x22
    484e:	a3 a3       	std	Z+35, r26	; 0x23
    4850:	b4 a3       	std	Z+36, r27	; 0x24
		}
		taskEXIT_CRITICAL();
    4852:	0f 90       	pop	r0
    4854:	0f be       	out	0x3f, r0	; 63

		return ulReturn;
    4856:	89 81       	ldd	r24, Y+1	; 0x01
    4858:	9a 81       	ldd	r25, Y+2	; 0x02
    485a:	ab 81       	ldd	r26, Y+3	; 0x03
    485c:	bc 81       	ldd	r27, Y+4	; 0x04
	}
    485e:	bc 01       	movw	r22, r24
    4860:	cd 01       	movw	r24, r26
    4862:	2e 96       	adiw	r28, 0x0e	; 14
    4864:	0f b6       	in	r0, 0x3f	; 63
    4866:	f8 94       	cli
    4868:	de bf       	out	0x3e, r29	; 62
    486a:	0f be       	out	0x3f, r0	; 63
    486c:	cd bf       	out	0x3d, r28	; 61
    486e:	cf 91       	pop	r28
    4870:	df 91       	pop	r29
    4872:	08 95       	ret

00004874 <prvAddCurrentTaskToDelayedList>:

#endif
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
{
    4874:	df 93       	push	r29
    4876:	cf 93       	push	r28
    4878:	cd b7       	in	r28, 0x3d	; 61
    487a:	de b7       	in	r29, 0x3e	; 62
    487c:	27 97       	sbiw	r28, 0x07	; 7
    487e:	0f b6       	in	r0, 0x3f	; 63
    4880:	f8 94       	cli
    4882:	de bf       	out	0x3e, r29	; 62
    4884:	0f be       	out	0x3f, r0	; 63
    4886:	cd bf       	out	0x3d, r28	; 61
    4888:	9e 83       	std	Y+6, r25	; 0x06
    488a:	8d 83       	std	Y+5, r24	; 0x05
    488c:	6f 83       	std	Y+7, r22	; 0x07
TickType_t xTimeToWake;
const TickType_t xConstTickCount = xTickCount;
    488e:	80 91 7b 04 	lds	r24, 0x047B
    4892:	90 91 7c 04 	lds	r25, 0x047C
    4896:	9a 83       	std	Y+2, r25	; 0x02
    4898:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	/* Remove the task from the ready list before adding it to the blocked list
	as the same list item is used for both lists. */
	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    489a:	80 91 77 04 	lds	r24, 0x0477
    489e:	90 91 78 04 	lds	r25, 0x0478
    48a2:	02 96       	adiw	r24, 0x02	; 2
    48a4:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
    48a8:	8d 81       	ldd	r24, Y+5	; 0x05
    48aa:	9e 81       	ldd	r25, Y+6	; 0x06
    48ac:	2f ef       	ldi	r18, 0xFF	; 255
    48ae:	8f 3f       	cpi	r24, 0xFF	; 255
    48b0:	92 07       	cpc	r25, r18
    48b2:	81 f4       	brne	.+32     	; 0x48d4 <prvAddCurrentTaskToDelayedList+0x60>
    48b4:	8f 81       	ldd	r24, Y+7	; 0x07
    48b6:	88 23       	and	r24, r24
    48b8:	69 f0       	breq	.+26     	; 0x48d4 <prvAddCurrentTaskToDelayedList+0x60>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure it is not woken by a timing event.  It will block
			indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
    48ba:	80 91 77 04 	lds	r24, 0x0477
    48be:	90 91 78 04 	lds	r25, 0x0478
    48c2:	9c 01       	movw	r18, r24
    48c4:	2e 5f       	subi	r18, 0xFE	; 254
    48c6:	3f 4f       	sbci	r19, 0xFF	; 255
    48c8:	8e ed       	ldi	r24, 0xDE	; 222
    48ca:	94 e0       	ldi	r25, 0x04	; 4
    48cc:	b9 01       	movw	r22, r18
    48ce:	0e 94 a4 0a 	call	0x1548	; 0x1548 <vListInsertEnd>
    48d2:	43 c0       	rjmp	.+134    	; 0x495a <prvAddCurrentTaskToDelayedList+0xe6>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			kernel will manage it correctly. */
			xTimeToWake = xConstTickCount + xTicksToWait;
    48d4:	29 81       	ldd	r18, Y+1	; 0x01
    48d6:	3a 81       	ldd	r19, Y+2	; 0x02
    48d8:	8d 81       	ldd	r24, Y+5	; 0x05
    48da:	9e 81       	ldd	r25, Y+6	; 0x06
    48dc:	82 0f       	add	r24, r18
    48de:	93 1f       	adc	r25, r19
    48e0:	9c 83       	std	Y+4, r25	; 0x04
    48e2:	8b 83       	std	Y+3, r24	; 0x03

			/* The list item will be inserted in wake time order. */
			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    48e4:	e0 91 77 04 	lds	r30, 0x0477
    48e8:	f0 91 78 04 	lds	r31, 0x0478
    48ec:	8b 81       	ldd	r24, Y+3	; 0x03
    48ee:	9c 81       	ldd	r25, Y+4	; 0x04
    48f0:	93 83       	std	Z+3, r25	; 0x03
    48f2:	82 83       	std	Z+2, r24	; 0x02

			if( xTimeToWake < xConstTickCount )
    48f4:	2b 81       	ldd	r18, Y+3	; 0x03
    48f6:	3c 81       	ldd	r19, Y+4	; 0x04
    48f8:	89 81       	ldd	r24, Y+1	; 0x01
    48fa:	9a 81       	ldd	r25, Y+2	; 0x02
    48fc:	28 17       	cp	r18, r24
    48fe:	39 07       	cpc	r19, r25
    4900:	70 f4       	brcc	.+28     	; 0x491e <prvAddCurrentTaskToDelayedList+0xaa>
			{
				/* Wake time has overflowed.  Place this item in the overflow
				list. */
				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    4902:	80 91 ca 04 	lds	r24, 0x04CA
    4906:	90 91 cb 04 	lds	r25, 0x04CB
    490a:	20 91 77 04 	lds	r18, 0x0477
    490e:	30 91 78 04 	lds	r19, 0x0478
    4912:	2e 5f       	subi	r18, 0xFE	; 254
    4914:	3f 4f       	sbci	r19, 0xFF	; 255
    4916:	b9 01       	movw	r22, r18
    4918:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <vListInsert>
    491c:	1e c0       	rjmp	.+60     	; 0x495a <prvAddCurrentTaskToDelayedList+0xe6>
			}
			else
			{
				/* The wake time has not overflowed, so the current block list
				is used. */
				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    491e:	40 91 c8 04 	lds	r20, 0x04C8
    4922:	50 91 c9 04 	lds	r21, 0x04C9
    4926:	80 91 77 04 	lds	r24, 0x0477
    492a:	90 91 78 04 	lds	r25, 0x0478
    492e:	9c 01       	movw	r18, r24
    4930:	2e 5f       	subi	r18, 0xFE	; 254
    4932:	3f 4f       	sbci	r19, 0xFF	; 255
    4934:	ca 01       	movw	r24, r20
    4936:	b9 01       	movw	r22, r18
    4938:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <vListInsert>

				/* If the task entering the blocked state was placed at the
				head of the list of blocked tasks then xNextTaskUnblockTime
				needs to be updated too. */
				if( xTimeToWake < xNextTaskUnblockTime )
    493c:	20 91 84 04 	lds	r18, 0x0484
    4940:	30 91 85 04 	lds	r19, 0x0485
    4944:	8b 81       	ldd	r24, Y+3	; 0x03
    4946:	9c 81       	ldd	r25, Y+4	; 0x04
    4948:	82 17       	cp	r24, r18
    494a:	93 07       	cpc	r25, r19
    494c:	30 f4       	brcc	.+12     	; 0x495a <prvAddCurrentTaskToDelayedList+0xe6>
				{
					xNextTaskUnblockTime = xTimeToWake;
    494e:	8b 81       	ldd	r24, Y+3	; 0x03
    4950:	9c 81       	ldd	r25, Y+4	; 0x04
    4952:	90 93 85 04 	sts	0x0485, r25
    4956:	80 93 84 04 	sts	0x0484, r24

		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
		( void ) xCanBlockIndefinitely;
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    495a:	27 96       	adiw	r28, 0x07	; 7
    495c:	0f b6       	in	r0, 0x3f	; 63
    495e:	f8 94       	cli
    4960:	de bf       	out	0x3e, r29	; 62
    4962:	0f be       	out	0x3f, r0	; 63
    4964:	cd bf       	out	0x3d, r28	; 61
    4966:	cf 91       	pop	r28
    4968:	df 91       	pop	r29
    496a:	08 95       	ret

0000496c <MDIO_vSetPinDir>:




void MDIO_vSetPinDir(DIO_PORT_e A_portID, DIO_PIN_e A_pinID, DIO_DIRECTION_e A_pinDirection)
{
    496c:	df 93       	push	r29
    496e:	cf 93       	push	r28
    4970:	cd b7       	in	r28, 0x3d	; 61
    4972:	de b7       	in	r29, 0x3e	; 62
    4974:	2d 97       	sbiw	r28, 0x0d	; 13
    4976:	0f b6       	in	r0, 0x3f	; 63
    4978:	f8 94       	cli
    497a:	de bf       	out	0x3e, r29	; 62
    497c:	0f be       	out	0x3f, r0	; 63
    497e:	cd bf       	out	0x3d, r28	; 61
    4980:	89 83       	std	Y+1, r24	; 0x01
    4982:	6a 83       	std	Y+2, r22	; 0x02
    4984:	4b 83       	std	Y+3, r20	; 0x03
	// Input Validation
	if ( (A_portID <= DIO_PORTD) && (A_pinID <= PIN7) && (A_pinDirection <= DIO_OUTPUT) )
    4986:	89 81       	ldd	r24, Y+1	; 0x01
    4988:	84 30       	cpi	r24, 0x04	; 4
    498a:	08 f0       	brcs	.+2      	; 0x498e <MDIO_vSetPinDir+0x22>
    498c:	09 c1       	rjmp	.+530    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
    498e:	8a 81       	ldd	r24, Y+2	; 0x02
    4990:	88 30       	cpi	r24, 0x08	; 8
    4992:	08 f0       	brcs	.+2      	; 0x4996 <MDIO_vSetPinDir+0x2a>
    4994:	05 c1       	rjmp	.+522    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
    4996:	8b 81       	ldd	r24, Y+3	; 0x03
    4998:	82 30       	cpi	r24, 0x02	; 2
    499a:	08 f0       	brcs	.+2      	; 0x499e <MDIO_vSetPinDir+0x32>
    499c:	01 c1       	rjmp	.+514    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
	{
		switch (A_portID)
    499e:	89 81       	ldd	r24, Y+1	; 0x01
    49a0:	28 2f       	mov	r18, r24
    49a2:	30 e0       	ldi	r19, 0x00	; 0
    49a4:	3d 87       	std	Y+13, r19	; 0x0d
    49a6:	2c 87       	std	Y+12, r18	; 0x0c
    49a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    49aa:	9d 85       	ldd	r25, Y+13	; 0x0d
    49ac:	81 30       	cpi	r24, 0x01	; 1
    49ae:	91 05       	cpc	r25, r1
    49b0:	09 f4       	brne	.+2      	; 0x49b4 <MDIO_vSetPinDir+0x48>
    49b2:	4f c0       	rjmp	.+158    	; 0x4a52 <MDIO_vSetPinDir+0xe6>
    49b4:	2c 85       	ldd	r18, Y+12	; 0x0c
    49b6:	3d 85       	ldd	r19, Y+13	; 0x0d
    49b8:	22 30       	cpi	r18, 0x02	; 2
    49ba:	31 05       	cpc	r19, r1
    49bc:	2c f4       	brge	.+10     	; 0x49c8 <MDIO_vSetPinDir+0x5c>
    49be:	8c 85       	ldd	r24, Y+12	; 0x0c
    49c0:	9d 85       	ldd	r25, Y+13	; 0x0d
    49c2:	00 97       	sbiw	r24, 0x00	; 0
    49c4:	71 f0       	breq	.+28     	; 0x49e2 <MDIO_vSetPinDir+0x76>
    49c6:	ec c0       	rjmp	.+472    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
    49c8:	2c 85       	ldd	r18, Y+12	; 0x0c
    49ca:	3d 85       	ldd	r19, Y+13	; 0x0d
    49cc:	22 30       	cpi	r18, 0x02	; 2
    49ce:	31 05       	cpc	r19, r1
    49d0:	09 f4       	brne	.+2      	; 0x49d4 <MDIO_vSetPinDir+0x68>
    49d2:	77 c0       	rjmp	.+238    	; 0x4ac2 <MDIO_vSetPinDir+0x156>
    49d4:	8c 85       	ldd	r24, Y+12	; 0x0c
    49d6:	9d 85       	ldd	r25, Y+13	; 0x0d
    49d8:	83 30       	cpi	r24, 0x03	; 3
    49da:	91 05       	cpc	r25, r1
    49dc:	09 f4       	brne	.+2      	; 0x49e0 <MDIO_vSetPinDir+0x74>
    49de:	a9 c0       	rjmp	.+338    	; 0x4b32 <MDIO_vSetPinDir+0x1c6>
    49e0:	df c0       	rjmp	.+446    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
		{
		case DIO_PORTA:
			switch (A_pinDirection)
    49e2:	8b 81       	ldd	r24, Y+3	; 0x03
    49e4:	28 2f       	mov	r18, r24
    49e6:	30 e0       	ldi	r19, 0x00	; 0
    49e8:	3b 87       	std	Y+11, r19	; 0x0b
    49ea:	2a 87       	std	Y+10, r18	; 0x0a
    49ec:	8a 85       	ldd	r24, Y+10	; 0x0a
    49ee:	9b 85       	ldd	r25, Y+11	; 0x0b
    49f0:	00 97       	sbiw	r24, 0x00	; 0
    49f2:	31 f0       	breq	.+12     	; 0x4a00 <MDIO_vSetPinDir+0x94>
    49f4:	2a 85       	ldd	r18, Y+10	; 0x0a
    49f6:	3b 85       	ldd	r19, Y+11	; 0x0b
    49f8:	21 30       	cpi	r18, 0x01	; 1
    49fa:	31 05       	cpc	r19, r1
    49fc:	b1 f0       	breq	.+44     	; 0x4a2a <MDIO_vSetPinDir+0xbe>
    49fe:	d0 c0       	rjmp	.+416    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
			{
			case DIO_INPUT:
				CLR_BIT(DDRA_REG,A_pinID);
    4a00:	aa e3       	ldi	r26, 0x3A	; 58
    4a02:	b0 e0       	ldi	r27, 0x00	; 0
    4a04:	ea e3       	ldi	r30, 0x3A	; 58
    4a06:	f0 e0       	ldi	r31, 0x00	; 0
    4a08:	80 81       	ld	r24, Z
    4a0a:	48 2f       	mov	r20, r24
    4a0c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a0e:	28 2f       	mov	r18, r24
    4a10:	30 e0       	ldi	r19, 0x00	; 0
    4a12:	81 e0       	ldi	r24, 0x01	; 1
    4a14:	90 e0       	ldi	r25, 0x00	; 0
    4a16:	02 2e       	mov	r0, r18
    4a18:	02 c0       	rjmp	.+4      	; 0x4a1e <MDIO_vSetPinDir+0xb2>
    4a1a:	88 0f       	add	r24, r24
    4a1c:	99 1f       	adc	r25, r25
    4a1e:	0a 94       	dec	r0
    4a20:	e2 f7       	brpl	.-8      	; 0x4a1a <MDIO_vSetPinDir+0xae>
    4a22:	80 95       	com	r24
    4a24:	84 23       	and	r24, r20
    4a26:	8c 93       	st	X, r24
    4a28:	bb c0       	rjmp	.+374    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
				break;
			case DIO_OUTPUT:
				SET_BIT(DDRA_REG,A_pinID);
    4a2a:	aa e3       	ldi	r26, 0x3A	; 58
    4a2c:	b0 e0       	ldi	r27, 0x00	; 0
    4a2e:	ea e3       	ldi	r30, 0x3A	; 58
    4a30:	f0 e0       	ldi	r31, 0x00	; 0
    4a32:	80 81       	ld	r24, Z
    4a34:	48 2f       	mov	r20, r24
    4a36:	8a 81       	ldd	r24, Y+2	; 0x02
    4a38:	28 2f       	mov	r18, r24
    4a3a:	30 e0       	ldi	r19, 0x00	; 0
    4a3c:	81 e0       	ldi	r24, 0x01	; 1
    4a3e:	90 e0       	ldi	r25, 0x00	; 0
    4a40:	02 2e       	mov	r0, r18
    4a42:	02 c0       	rjmp	.+4      	; 0x4a48 <MDIO_vSetPinDir+0xdc>
    4a44:	88 0f       	add	r24, r24
    4a46:	99 1f       	adc	r25, r25
    4a48:	0a 94       	dec	r0
    4a4a:	e2 f7       	brpl	.-8      	; 0x4a44 <MDIO_vSetPinDir+0xd8>
    4a4c:	84 2b       	or	r24, r20
    4a4e:	8c 93       	st	X, r24
    4a50:	a7 c0       	rjmp	.+334    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
				break;
			}
			break;
		case DIO_PORTB:
			switch (A_pinDirection)
    4a52:	8b 81       	ldd	r24, Y+3	; 0x03
    4a54:	28 2f       	mov	r18, r24
    4a56:	30 e0       	ldi	r19, 0x00	; 0
    4a58:	39 87       	std	Y+9, r19	; 0x09
    4a5a:	28 87       	std	Y+8, r18	; 0x08
    4a5c:	88 85       	ldd	r24, Y+8	; 0x08
    4a5e:	99 85       	ldd	r25, Y+9	; 0x09
    4a60:	00 97       	sbiw	r24, 0x00	; 0
    4a62:	31 f0       	breq	.+12     	; 0x4a70 <MDIO_vSetPinDir+0x104>
    4a64:	28 85       	ldd	r18, Y+8	; 0x08
    4a66:	39 85       	ldd	r19, Y+9	; 0x09
    4a68:	21 30       	cpi	r18, 0x01	; 1
    4a6a:	31 05       	cpc	r19, r1
    4a6c:	b1 f0       	breq	.+44     	; 0x4a9a <MDIO_vSetPinDir+0x12e>
    4a6e:	98 c0       	rjmp	.+304    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
			{
			case DIO_INPUT:
				CLR_BIT(DDRB_REG,A_pinID);
    4a70:	a7 e3       	ldi	r26, 0x37	; 55
    4a72:	b0 e0       	ldi	r27, 0x00	; 0
    4a74:	e7 e3       	ldi	r30, 0x37	; 55
    4a76:	f0 e0       	ldi	r31, 0x00	; 0
    4a78:	80 81       	ld	r24, Z
    4a7a:	48 2f       	mov	r20, r24
    4a7c:	8a 81       	ldd	r24, Y+2	; 0x02
    4a7e:	28 2f       	mov	r18, r24
    4a80:	30 e0       	ldi	r19, 0x00	; 0
    4a82:	81 e0       	ldi	r24, 0x01	; 1
    4a84:	90 e0       	ldi	r25, 0x00	; 0
    4a86:	02 2e       	mov	r0, r18
    4a88:	02 c0       	rjmp	.+4      	; 0x4a8e <MDIO_vSetPinDir+0x122>
    4a8a:	88 0f       	add	r24, r24
    4a8c:	99 1f       	adc	r25, r25
    4a8e:	0a 94       	dec	r0
    4a90:	e2 f7       	brpl	.-8      	; 0x4a8a <MDIO_vSetPinDir+0x11e>
    4a92:	80 95       	com	r24
    4a94:	84 23       	and	r24, r20
    4a96:	8c 93       	st	X, r24
    4a98:	83 c0       	rjmp	.+262    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
				break;
			case DIO_OUTPUT:
				SET_BIT(DDRB_REG,A_pinID);
    4a9a:	a7 e3       	ldi	r26, 0x37	; 55
    4a9c:	b0 e0       	ldi	r27, 0x00	; 0
    4a9e:	e7 e3       	ldi	r30, 0x37	; 55
    4aa0:	f0 e0       	ldi	r31, 0x00	; 0
    4aa2:	80 81       	ld	r24, Z
    4aa4:	48 2f       	mov	r20, r24
    4aa6:	8a 81       	ldd	r24, Y+2	; 0x02
    4aa8:	28 2f       	mov	r18, r24
    4aaa:	30 e0       	ldi	r19, 0x00	; 0
    4aac:	81 e0       	ldi	r24, 0x01	; 1
    4aae:	90 e0       	ldi	r25, 0x00	; 0
    4ab0:	02 2e       	mov	r0, r18
    4ab2:	02 c0       	rjmp	.+4      	; 0x4ab8 <MDIO_vSetPinDir+0x14c>
    4ab4:	88 0f       	add	r24, r24
    4ab6:	99 1f       	adc	r25, r25
    4ab8:	0a 94       	dec	r0
    4aba:	e2 f7       	brpl	.-8      	; 0x4ab4 <MDIO_vSetPinDir+0x148>
    4abc:	84 2b       	or	r24, r20
    4abe:	8c 93       	st	X, r24
    4ac0:	6f c0       	rjmp	.+222    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
				break;
			}
			break;
		case DIO_PORTC:
			switch (A_pinDirection)
    4ac2:	8b 81       	ldd	r24, Y+3	; 0x03
    4ac4:	28 2f       	mov	r18, r24
    4ac6:	30 e0       	ldi	r19, 0x00	; 0
    4ac8:	3f 83       	std	Y+7, r19	; 0x07
    4aca:	2e 83       	std	Y+6, r18	; 0x06
    4acc:	8e 81       	ldd	r24, Y+6	; 0x06
    4ace:	9f 81       	ldd	r25, Y+7	; 0x07
    4ad0:	00 97       	sbiw	r24, 0x00	; 0
    4ad2:	31 f0       	breq	.+12     	; 0x4ae0 <MDIO_vSetPinDir+0x174>
    4ad4:	2e 81       	ldd	r18, Y+6	; 0x06
    4ad6:	3f 81       	ldd	r19, Y+7	; 0x07
    4ad8:	21 30       	cpi	r18, 0x01	; 1
    4ada:	31 05       	cpc	r19, r1
    4adc:	b1 f0       	breq	.+44     	; 0x4b0a <MDIO_vSetPinDir+0x19e>
    4ade:	60 c0       	rjmp	.+192    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
			{
			case DIO_INPUT:
				CLR_BIT(DDRC_REG,A_pinID);
    4ae0:	a4 e3       	ldi	r26, 0x34	; 52
    4ae2:	b0 e0       	ldi	r27, 0x00	; 0
    4ae4:	e4 e3       	ldi	r30, 0x34	; 52
    4ae6:	f0 e0       	ldi	r31, 0x00	; 0
    4ae8:	80 81       	ld	r24, Z
    4aea:	48 2f       	mov	r20, r24
    4aec:	8a 81       	ldd	r24, Y+2	; 0x02
    4aee:	28 2f       	mov	r18, r24
    4af0:	30 e0       	ldi	r19, 0x00	; 0
    4af2:	81 e0       	ldi	r24, 0x01	; 1
    4af4:	90 e0       	ldi	r25, 0x00	; 0
    4af6:	02 2e       	mov	r0, r18
    4af8:	02 c0       	rjmp	.+4      	; 0x4afe <MDIO_vSetPinDir+0x192>
    4afa:	88 0f       	add	r24, r24
    4afc:	99 1f       	adc	r25, r25
    4afe:	0a 94       	dec	r0
    4b00:	e2 f7       	brpl	.-8      	; 0x4afa <MDIO_vSetPinDir+0x18e>
    4b02:	80 95       	com	r24
    4b04:	84 23       	and	r24, r20
    4b06:	8c 93       	st	X, r24
    4b08:	4b c0       	rjmp	.+150    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
				break;
			case DIO_OUTPUT:
				SET_BIT(DDRC_REG,A_pinID);
    4b0a:	a4 e3       	ldi	r26, 0x34	; 52
    4b0c:	b0 e0       	ldi	r27, 0x00	; 0
    4b0e:	e4 e3       	ldi	r30, 0x34	; 52
    4b10:	f0 e0       	ldi	r31, 0x00	; 0
    4b12:	80 81       	ld	r24, Z
    4b14:	48 2f       	mov	r20, r24
    4b16:	8a 81       	ldd	r24, Y+2	; 0x02
    4b18:	28 2f       	mov	r18, r24
    4b1a:	30 e0       	ldi	r19, 0x00	; 0
    4b1c:	81 e0       	ldi	r24, 0x01	; 1
    4b1e:	90 e0       	ldi	r25, 0x00	; 0
    4b20:	02 2e       	mov	r0, r18
    4b22:	02 c0       	rjmp	.+4      	; 0x4b28 <MDIO_vSetPinDir+0x1bc>
    4b24:	88 0f       	add	r24, r24
    4b26:	99 1f       	adc	r25, r25
    4b28:	0a 94       	dec	r0
    4b2a:	e2 f7       	brpl	.-8      	; 0x4b24 <MDIO_vSetPinDir+0x1b8>
    4b2c:	84 2b       	or	r24, r20
    4b2e:	8c 93       	st	X, r24
    4b30:	37 c0       	rjmp	.+110    	; 0x4ba0 <MDIO_vSetPinDir+0x234>
				break;
			}
			break;
		case DIO_PORTD:
			switch (A_pinDirection)
    4b32:	8b 81       	ldd	r24, Y+3	; 0x03
    4b34:	28 2f       	mov	r18, r24
    4b36:	30 e0       	ldi	r19, 0x00	; 0
    4b38:	3d 83       	std	Y+5, r19	; 0x05
    4b3a:	2c 83       	std	Y+4, r18	; 0x04
    4b3c:	8c 81       	ldd	r24, Y+4	; 0x04
    4b3e:	9d 81       	ldd	r25, Y+5	; 0x05
    4b40:	00 97       	sbiw	r24, 0x00	; 0
    4b42:	31 f0       	breq	.+12     	; 0x4b50 <MDIO_vSetPinDir+0x1e4>
    4b44:	2c 81       	ldd	r18, Y+4	; 0x04
    4b46:	3d 81       	ldd	r19, Y+5	; 0x05
    4b48:	21 30       	cpi	r18, 0x01	; 1
    4b4a:	31 05       	cpc	r19, r1
    4b4c:	b1 f0       	breq	.+44     	; 0x4b7a <MDIO_vSetPinDir+0x20e>
    4b4e:	28 c0       	rjmp	.+80     	; 0x4ba0 <MDIO_vSetPinDir+0x234>
			{
			case DIO_INPUT:
				CLR_BIT(DDRD_REG,A_pinID);
    4b50:	a1 e3       	ldi	r26, 0x31	; 49
    4b52:	b0 e0       	ldi	r27, 0x00	; 0
    4b54:	e1 e3       	ldi	r30, 0x31	; 49
    4b56:	f0 e0       	ldi	r31, 0x00	; 0
    4b58:	80 81       	ld	r24, Z
    4b5a:	48 2f       	mov	r20, r24
    4b5c:	8a 81       	ldd	r24, Y+2	; 0x02
    4b5e:	28 2f       	mov	r18, r24
    4b60:	30 e0       	ldi	r19, 0x00	; 0
    4b62:	81 e0       	ldi	r24, 0x01	; 1
    4b64:	90 e0       	ldi	r25, 0x00	; 0
    4b66:	02 2e       	mov	r0, r18
    4b68:	02 c0       	rjmp	.+4      	; 0x4b6e <MDIO_vSetPinDir+0x202>
    4b6a:	88 0f       	add	r24, r24
    4b6c:	99 1f       	adc	r25, r25
    4b6e:	0a 94       	dec	r0
    4b70:	e2 f7       	brpl	.-8      	; 0x4b6a <MDIO_vSetPinDir+0x1fe>
    4b72:	80 95       	com	r24
    4b74:	84 23       	and	r24, r20
    4b76:	8c 93       	st	X, r24
    4b78:	13 c0       	rjmp	.+38     	; 0x4ba0 <MDIO_vSetPinDir+0x234>
				break;
			case DIO_OUTPUT:
				SET_BIT(DDRD_REG,A_pinID);
    4b7a:	a1 e3       	ldi	r26, 0x31	; 49
    4b7c:	b0 e0       	ldi	r27, 0x00	; 0
    4b7e:	e1 e3       	ldi	r30, 0x31	; 49
    4b80:	f0 e0       	ldi	r31, 0x00	; 0
    4b82:	80 81       	ld	r24, Z
    4b84:	48 2f       	mov	r20, r24
    4b86:	8a 81       	ldd	r24, Y+2	; 0x02
    4b88:	28 2f       	mov	r18, r24
    4b8a:	30 e0       	ldi	r19, 0x00	; 0
    4b8c:	81 e0       	ldi	r24, 0x01	; 1
    4b8e:	90 e0       	ldi	r25, 0x00	; 0
    4b90:	02 2e       	mov	r0, r18
    4b92:	02 c0       	rjmp	.+4      	; 0x4b98 <MDIO_vSetPinDir+0x22c>
    4b94:	88 0f       	add	r24, r24
    4b96:	99 1f       	adc	r25, r25
    4b98:	0a 94       	dec	r0
    4b9a:	e2 f7       	brpl	.-8      	; 0x4b94 <MDIO_vSetPinDir+0x228>
    4b9c:	84 2b       	or	r24, r20
    4b9e:	8c 93       	st	X, r24
	}
	else
	{
		// Do Nothing
	}
}
    4ba0:	2d 96       	adiw	r28, 0x0d	; 13
    4ba2:	0f b6       	in	r0, 0x3f	; 63
    4ba4:	f8 94       	cli
    4ba6:	de bf       	out	0x3e, r29	; 62
    4ba8:	0f be       	out	0x3f, r0	; 63
    4baa:	cd bf       	out	0x3d, r28	; 61
    4bac:	cf 91       	pop	r28
    4bae:	df 91       	pop	r29
    4bb0:	08 95       	ret

00004bb2 <MDIO_vSetPinVal>:


void MDIO_vSetPinVal(DIO_PORT_e A_portID, DIO_PIN_e A_pinID, DIO_VALUE_e A_pinValue)
{
    4bb2:	df 93       	push	r29
    4bb4:	cf 93       	push	r28
    4bb6:	cd b7       	in	r28, 0x3d	; 61
    4bb8:	de b7       	in	r29, 0x3e	; 62
    4bba:	2d 97       	sbiw	r28, 0x0d	; 13
    4bbc:	0f b6       	in	r0, 0x3f	; 63
    4bbe:	f8 94       	cli
    4bc0:	de bf       	out	0x3e, r29	; 62
    4bc2:	0f be       	out	0x3f, r0	; 63
    4bc4:	cd bf       	out	0x3d, r28	; 61
    4bc6:	89 83       	std	Y+1, r24	; 0x01
    4bc8:	6a 83       	std	Y+2, r22	; 0x02
    4bca:	4b 83       	std	Y+3, r20	; 0x03
	// Input Validation
	if ( (A_portID <= DIO_PORTD) && (A_pinID <= PIN7) && (A_pinValue <= DIO_HIGH) )
    4bcc:	89 81       	ldd	r24, Y+1	; 0x01
    4bce:	84 30       	cpi	r24, 0x04	; 4
    4bd0:	08 f0       	brcs	.+2      	; 0x4bd4 <MDIO_vSetPinVal+0x22>
    4bd2:	09 c1       	rjmp	.+530    	; 0x4de6 <MDIO_vSetPinVal+0x234>
    4bd4:	8a 81       	ldd	r24, Y+2	; 0x02
    4bd6:	88 30       	cpi	r24, 0x08	; 8
    4bd8:	08 f0       	brcs	.+2      	; 0x4bdc <MDIO_vSetPinVal+0x2a>
    4bda:	05 c1       	rjmp	.+522    	; 0x4de6 <MDIO_vSetPinVal+0x234>
    4bdc:	8b 81       	ldd	r24, Y+3	; 0x03
    4bde:	82 30       	cpi	r24, 0x02	; 2
    4be0:	08 f0       	brcs	.+2      	; 0x4be4 <MDIO_vSetPinVal+0x32>
    4be2:	01 c1       	rjmp	.+514    	; 0x4de6 <MDIO_vSetPinVal+0x234>
	{
		switch (A_portID)
    4be4:	89 81       	ldd	r24, Y+1	; 0x01
    4be6:	28 2f       	mov	r18, r24
    4be8:	30 e0       	ldi	r19, 0x00	; 0
    4bea:	3d 87       	std	Y+13, r19	; 0x0d
    4bec:	2c 87       	std	Y+12, r18	; 0x0c
    4bee:	8c 85       	ldd	r24, Y+12	; 0x0c
    4bf0:	9d 85       	ldd	r25, Y+13	; 0x0d
    4bf2:	81 30       	cpi	r24, 0x01	; 1
    4bf4:	91 05       	cpc	r25, r1
    4bf6:	09 f4       	brne	.+2      	; 0x4bfa <MDIO_vSetPinVal+0x48>
    4bf8:	4f c0       	rjmp	.+158    	; 0x4c98 <MDIO_vSetPinVal+0xe6>
    4bfa:	2c 85       	ldd	r18, Y+12	; 0x0c
    4bfc:	3d 85       	ldd	r19, Y+13	; 0x0d
    4bfe:	22 30       	cpi	r18, 0x02	; 2
    4c00:	31 05       	cpc	r19, r1
    4c02:	2c f4       	brge	.+10     	; 0x4c0e <MDIO_vSetPinVal+0x5c>
    4c04:	8c 85       	ldd	r24, Y+12	; 0x0c
    4c06:	9d 85       	ldd	r25, Y+13	; 0x0d
    4c08:	00 97       	sbiw	r24, 0x00	; 0
    4c0a:	71 f0       	breq	.+28     	; 0x4c28 <MDIO_vSetPinVal+0x76>
    4c0c:	ec c0       	rjmp	.+472    	; 0x4de6 <MDIO_vSetPinVal+0x234>
    4c0e:	2c 85       	ldd	r18, Y+12	; 0x0c
    4c10:	3d 85       	ldd	r19, Y+13	; 0x0d
    4c12:	22 30       	cpi	r18, 0x02	; 2
    4c14:	31 05       	cpc	r19, r1
    4c16:	09 f4       	brne	.+2      	; 0x4c1a <MDIO_vSetPinVal+0x68>
    4c18:	77 c0       	rjmp	.+238    	; 0x4d08 <MDIO_vSetPinVal+0x156>
    4c1a:	8c 85       	ldd	r24, Y+12	; 0x0c
    4c1c:	9d 85       	ldd	r25, Y+13	; 0x0d
    4c1e:	83 30       	cpi	r24, 0x03	; 3
    4c20:	91 05       	cpc	r25, r1
    4c22:	09 f4       	brne	.+2      	; 0x4c26 <MDIO_vSetPinVal+0x74>
    4c24:	a9 c0       	rjmp	.+338    	; 0x4d78 <MDIO_vSetPinVal+0x1c6>
    4c26:	df c0       	rjmp	.+446    	; 0x4de6 <MDIO_vSetPinVal+0x234>
		{
		case DIO_PORTA:
			switch (A_pinValue)
    4c28:	8b 81       	ldd	r24, Y+3	; 0x03
    4c2a:	28 2f       	mov	r18, r24
    4c2c:	30 e0       	ldi	r19, 0x00	; 0
    4c2e:	3b 87       	std	Y+11, r19	; 0x0b
    4c30:	2a 87       	std	Y+10, r18	; 0x0a
    4c32:	8a 85       	ldd	r24, Y+10	; 0x0a
    4c34:	9b 85       	ldd	r25, Y+11	; 0x0b
    4c36:	00 97       	sbiw	r24, 0x00	; 0
    4c38:	31 f0       	breq	.+12     	; 0x4c46 <MDIO_vSetPinVal+0x94>
    4c3a:	2a 85       	ldd	r18, Y+10	; 0x0a
    4c3c:	3b 85       	ldd	r19, Y+11	; 0x0b
    4c3e:	21 30       	cpi	r18, 0x01	; 1
    4c40:	31 05       	cpc	r19, r1
    4c42:	b1 f0       	breq	.+44     	; 0x4c70 <MDIO_vSetPinVal+0xbe>
    4c44:	d0 c0       	rjmp	.+416    	; 0x4de6 <MDIO_vSetPinVal+0x234>
			{
			case DIO_LOW:
				CLR_BIT(PORTA_REG,A_pinID);
    4c46:	ab e3       	ldi	r26, 0x3B	; 59
    4c48:	b0 e0       	ldi	r27, 0x00	; 0
    4c4a:	eb e3       	ldi	r30, 0x3B	; 59
    4c4c:	f0 e0       	ldi	r31, 0x00	; 0
    4c4e:	80 81       	ld	r24, Z
    4c50:	48 2f       	mov	r20, r24
    4c52:	8a 81       	ldd	r24, Y+2	; 0x02
    4c54:	28 2f       	mov	r18, r24
    4c56:	30 e0       	ldi	r19, 0x00	; 0
    4c58:	81 e0       	ldi	r24, 0x01	; 1
    4c5a:	90 e0       	ldi	r25, 0x00	; 0
    4c5c:	02 2e       	mov	r0, r18
    4c5e:	02 c0       	rjmp	.+4      	; 0x4c64 <MDIO_vSetPinVal+0xb2>
    4c60:	88 0f       	add	r24, r24
    4c62:	99 1f       	adc	r25, r25
    4c64:	0a 94       	dec	r0
    4c66:	e2 f7       	brpl	.-8      	; 0x4c60 <MDIO_vSetPinVal+0xae>
    4c68:	80 95       	com	r24
    4c6a:	84 23       	and	r24, r20
    4c6c:	8c 93       	st	X, r24
    4c6e:	bb c0       	rjmp	.+374    	; 0x4de6 <MDIO_vSetPinVal+0x234>
				break;
			case DIO_HIGH:
				SET_BIT(PORTA_REG,A_pinID);
    4c70:	ab e3       	ldi	r26, 0x3B	; 59
    4c72:	b0 e0       	ldi	r27, 0x00	; 0
    4c74:	eb e3       	ldi	r30, 0x3B	; 59
    4c76:	f0 e0       	ldi	r31, 0x00	; 0
    4c78:	80 81       	ld	r24, Z
    4c7a:	48 2f       	mov	r20, r24
    4c7c:	8a 81       	ldd	r24, Y+2	; 0x02
    4c7e:	28 2f       	mov	r18, r24
    4c80:	30 e0       	ldi	r19, 0x00	; 0
    4c82:	81 e0       	ldi	r24, 0x01	; 1
    4c84:	90 e0       	ldi	r25, 0x00	; 0
    4c86:	02 2e       	mov	r0, r18
    4c88:	02 c0       	rjmp	.+4      	; 0x4c8e <MDIO_vSetPinVal+0xdc>
    4c8a:	88 0f       	add	r24, r24
    4c8c:	99 1f       	adc	r25, r25
    4c8e:	0a 94       	dec	r0
    4c90:	e2 f7       	brpl	.-8      	; 0x4c8a <MDIO_vSetPinVal+0xd8>
    4c92:	84 2b       	or	r24, r20
    4c94:	8c 93       	st	X, r24
    4c96:	a7 c0       	rjmp	.+334    	; 0x4de6 <MDIO_vSetPinVal+0x234>
				break;
			}
			break;
		case DIO_PORTB:
			switch (A_pinValue)
    4c98:	8b 81       	ldd	r24, Y+3	; 0x03
    4c9a:	28 2f       	mov	r18, r24
    4c9c:	30 e0       	ldi	r19, 0x00	; 0
    4c9e:	39 87       	std	Y+9, r19	; 0x09
    4ca0:	28 87       	std	Y+8, r18	; 0x08
    4ca2:	88 85       	ldd	r24, Y+8	; 0x08
    4ca4:	99 85       	ldd	r25, Y+9	; 0x09
    4ca6:	00 97       	sbiw	r24, 0x00	; 0
    4ca8:	31 f0       	breq	.+12     	; 0x4cb6 <MDIO_vSetPinVal+0x104>
    4caa:	28 85       	ldd	r18, Y+8	; 0x08
    4cac:	39 85       	ldd	r19, Y+9	; 0x09
    4cae:	21 30       	cpi	r18, 0x01	; 1
    4cb0:	31 05       	cpc	r19, r1
    4cb2:	b1 f0       	breq	.+44     	; 0x4ce0 <MDIO_vSetPinVal+0x12e>
    4cb4:	98 c0       	rjmp	.+304    	; 0x4de6 <MDIO_vSetPinVal+0x234>
			{
			case DIO_LOW:
				CLR_BIT(PORTB_REG,A_pinID);
    4cb6:	a8 e3       	ldi	r26, 0x38	; 56
    4cb8:	b0 e0       	ldi	r27, 0x00	; 0
    4cba:	e8 e3       	ldi	r30, 0x38	; 56
    4cbc:	f0 e0       	ldi	r31, 0x00	; 0
    4cbe:	80 81       	ld	r24, Z
    4cc0:	48 2f       	mov	r20, r24
    4cc2:	8a 81       	ldd	r24, Y+2	; 0x02
    4cc4:	28 2f       	mov	r18, r24
    4cc6:	30 e0       	ldi	r19, 0x00	; 0
    4cc8:	81 e0       	ldi	r24, 0x01	; 1
    4cca:	90 e0       	ldi	r25, 0x00	; 0
    4ccc:	02 2e       	mov	r0, r18
    4cce:	02 c0       	rjmp	.+4      	; 0x4cd4 <MDIO_vSetPinVal+0x122>
    4cd0:	88 0f       	add	r24, r24
    4cd2:	99 1f       	adc	r25, r25
    4cd4:	0a 94       	dec	r0
    4cd6:	e2 f7       	brpl	.-8      	; 0x4cd0 <MDIO_vSetPinVal+0x11e>
    4cd8:	80 95       	com	r24
    4cda:	84 23       	and	r24, r20
    4cdc:	8c 93       	st	X, r24
    4cde:	83 c0       	rjmp	.+262    	; 0x4de6 <MDIO_vSetPinVal+0x234>
				break;
			case DIO_HIGH:
				SET_BIT(PORTB_REG,A_pinID);
    4ce0:	a8 e3       	ldi	r26, 0x38	; 56
    4ce2:	b0 e0       	ldi	r27, 0x00	; 0
    4ce4:	e8 e3       	ldi	r30, 0x38	; 56
    4ce6:	f0 e0       	ldi	r31, 0x00	; 0
    4ce8:	80 81       	ld	r24, Z
    4cea:	48 2f       	mov	r20, r24
    4cec:	8a 81       	ldd	r24, Y+2	; 0x02
    4cee:	28 2f       	mov	r18, r24
    4cf0:	30 e0       	ldi	r19, 0x00	; 0
    4cf2:	81 e0       	ldi	r24, 0x01	; 1
    4cf4:	90 e0       	ldi	r25, 0x00	; 0
    4cf6:	02 2e       	mov	r0, r18
    4cf8:	02 c0       	rjmp	.+4      	; 0x4cfe <MDIO_vSetPinVal+0x14c>
    4cfa:	88 0f       	add	r24, r24
    4cfc:	99 1f       	adc	r25, r25
    4cfe:	0a 94       	dec	r0
    4d00:	e2 f7       	brpl	.-8      	; 0x4cfa <MDIO_vSetPinVal+0x148>
    4d02:	84 2b       	or	r24, r20
    4d04:	8c 93       	st	X, r24
    4d06:	6f c0       	rjmp	.+222    	; 0x4de6 <MDIO_vSetPinVal+0x234>
				break;
			}
			break;
		case DIO_PORTC:
			switch (A_pinValue)
    4d08:	8b 81       	ldd	r24, Y+3	; 0x03
    4d0a:	28 2f       	mov	r18, r24
    4d0c:	30 e0       	ldi	r19, 0x00	; 0
    4d0e:	3f 83       	std	Y+7, r19	; 0x07
    4d10:	2e 83       	std	Y+6, r18	; 0x06
    4d12:	8e 81       	ldd	r24, Y+6	; 0x06
    4d14:	9f 81       	ldd	r25, Y+7	; 0x07
    4d16:	00 97       	sbiw	r24, 0x00	; 0
    4d18:	31 f0       	breq	.+12     	; 0x4d26 <MDIO_vSetPinVal+0x174>
    4d1a:	2e 81       	ldd	r18, Y+6	; 0x06
    4d1c:	3f 81       	ldd	r19, Y+7	; 0x07
    4d1e:	21 30       	cpi	r18, 0x01	; 1
    4d20:	31 05       	cpc	r19, r1
    4d22:	b1 f0       	breq	.+44     	; 0x4d50 <MDIO_vSetPinVal+0x19e>
    4d24:	60 c0       	rjmp	.+192    	; 0x4de6 <MDIO_vSetPinVal+0x234>
			{
			case DIO_LOW:
				CLR_BIT(PORTC_REG,A_pinID);
    4d26:	a5 e3       	ldi	r26, 0x35	; 53
    4d28:	b0 e0       	ldi	r27, 0x00	; 0
    4d2a:	e5 e3       	ldi	r30, 0x35	; 53
    4d2c:	f0 e0       	ldi	r31, 0x00	; 0
    4d2e:	80 81       	ld	r24, Z
    4d30:	48 2f       	mov	r20, r24
    4d32:	8a 81       	ldd	r24, Y+2	; 0x02
    4d34:	28 2f       	mov	r18, r24
    4d36:	30 e0       	ldi	r19, 0x00	; 0
    4d38:	81 e0       	ldi	r24, 0x01	; 1
    4d3a:	90 e0       	ldi	r25, 0x00	; 0
    4d3c:	02 2e       	mov	r0, r18
    4d3e:	02 c0       	rjmp	.+4      	; 0x4d44 <MDIO_vSetPinVal+0x192>
    4d40:	88 0f       	add	r24, r24
    4d42:	99 1f       	adc	r25, r25
    4d44:	0a 94       	dec	r0
    4d46:	e2 f7       	brpl	.-8      	; 0x4d40 <MDIO_vSetPinVal+0x18e>
    4d48:	80 95       	com	r24
    4d4a:	84 23       	and	r24, r20
    4d4c:	8c 93       	st	X, r24
    4d4e:	4b c0       	rjmp	.+150    	; 0x4de6 <MDIO_vSetPinVal+0x234>
				break;
			case DIO_HIGH:
				SET_BIT(PORTC_REG,A_pinID);
    4d50:	a5 e3       	ldi	r26, 0x35	; 53
    4d52:	b0 e0       	ldi	r27, 0x00	; 0
    4d54:	e5 e3       	ldi	r30, 0x35	; 53
    4d56:	f0 e0       	ldi	r31, 0x00	; 0
    4d58:	80 81       	ld	r24, Z
    4d5a:	48 2f       	mov	r20, r24
    4d5c:	8a 81       	ldd	r24, Y+2	; 0x02
    4d5e:	28 2f       	mov	r18, r24
    4d60:	30 e0       	ldi	r19, 0x00	; 0
    4d62:	81 e0       	ldi	r24, 0x01	; 1
    4d64:	90 e0       	ldi	r25, 0x00	; 0
    4d66:	02 2e       	mov	r0, r18
    4d68:	02 c0       	rjmp	.+4      	; 0x4d6e <MDIO_vSetPinVal+0x1bc>
    4d6a:	88 0f       	add	r24, r24
    4d6c:	99 1f       	adc	r25, r25
    4d6e:	0a 94       	dec	r0
    4d70:	e2 f7       	brpl	.-8      	; 0x4d6a <MDIO_vSetPinVal+0x1b8>
    4d72:	84 2b       	or	r24, r20
    4d74:	8c 93       	st	X, r24
    4d76:	37 c0       	rjmp	.+110    	; 0x4de6 <MDIO_vSetPinVal+0x234>
				break;
			}
			break;
		case DIO_PORTD:
			switch (A_pinValue)
    4d78:	8b 81       	ldd	r24, Y+3	; 0x03
    4d7a:	28 2f       	mov	r18, r24
    4d7c:	30 e0       	ldi	r19, 0x00	; 0
    4d7e:	3d 83       	std	Y+5, r19	; 0x05
    4d80:	2c 83       	std	Y+4, r18	; 0x04
    4d82:	8c 81       	ldd	r24, Y+4	; 0x04
    4d84:	9d 81       	ldd	r25, Y+5	; 0x05
    4d86:	00 97       	sbiw	r24, 0x00	; 0
    4d88:	31 f0       	breq	.+12     	; 0x4d96 <MDIO_vSetPinVal+0x1e4>
    4d8a:	2c 81       	ldd	r18, Y+4	; 0x04
    4d8c:	3d 81       	ldd	r19, Y+5	; 0x05
    4d8e:	21 30       	cpi	r18, 0x01	; 1
    4d90:	31 05       	cpc	r19, r1
    4d92:	b1 f0       	breq	.+44     	; 0x4dc0 <MDIO_vSetPinVal+0x20e>
    4d94:	28 c0       	rjmp	.+80     	; 0x4de6 <MDIO_vSetPinVal+0x234>
			{
			case DIO_LOW:
				CLR_BIT(PORTD_REG,A_pinID);
    4d96:	a2 e3       	ldi	r26, 0x32	; 50
    4d98:	b0 e0       	ldi	r27, 0x00	; 0
    4d9a:	e2 e3       	ldi	r30, 0x32	; 50
    4d9c:	f0 e0       	ldi	r31, 0x00	; 0
    4d9e:	80 81       	ld	r24, Z
    4da0:	48 2f       	mov	r20, r24
    4da2:	8a 81       	ldd	r24, Y+2	; 0x02
    4da4:	28 2f       	mov	r18, r24
    4da6:	30 e0       	ldi	r19, 0x00	; 0
    4da8:	81 e0       	ldi	r24, 0x01	; 1
    4daa:	90 e0       	ldi	r25, 0x00	; 0
    4dac:	02 2e       	mov	r0, r18
    4dae:	02 c0       	rjmp	.+4      	; 0x4db4 <MDIO_vSetPinVal+0x202>
    4db0:	88 0f       	add	r24, r24
    4db2:	99 1f       	adc	r25, r25
    4db4:	0a 94       	dec	r0
    4db6:	e2 f7       	brpl	.-8      	; 0x4db0 <MDIO_vSetPinVal+0x1fe>
    4db8:	80 95       	com	r24
    4dba:	84 23       	and	r24, r20
    4dbc:	8c 93       	st	X, r24
    4dbe:	13 c0       	rjmp	.+38     	; 0x4de6 <MDIO_vSetPinVal+0x234>
				break;
			case DIO_HIGH:
				SET_BIT(PORTD_REG,A_pinID);
    4dc0:	a2 e3       	ldi	r26, 0x32	; 50
    4dc2:	b0 e0       	ldi	r27, 0x00	; 0
    4dc4:	e2 e3       	ldi	r30, 0x32	; 50
    4dc6:	f0 e0       	ldi	r31, 0x00	; 0
    4dc8:	80 81       	ld	r24, Z
    4dca:	48 2f       	mov	r20, r24
    4dcc:	8a 81       	ldd	r24, Y+2	; 0x02
    4dce:	28 2f       	mov	r18, r24
    4dd0:	30 e0       	ldi	r19, 0x00	; 0
    4dd2:	81 e0       	ldi	r24, 0x01	; 1
    4dd4:	90 e0       	ldi	r25, 0x00	; 0
    4dd6:	02 2e       	mov	r0, r18
    4dd8:	02 c0       	rjmp	.+4      	; 0x4dde <MDIO_vSetPinVal+0x22c>
    4dda:	88 0f       	add	r24, r24
    4ddc:	99 1f       	adc	r25, r25
    4dde:	0a 94       	dec	r0
    4de0:	e2 f7       	brpl	.-8      	; 0x4dda <MDIO_vSetPinVal+0x228>
    4de2:	84 2b       	or	r24, r20
    4de4:	8c 93       	st	X, r24
	}
	else
	{
		// Do Nothing
	}
}
    4de6:	2d 96       	adiw	r28, 0x0d	; 13
    4de8:	0f b6       	in	r0, 0x3f	; 63
    4dea:	f8 94       	cli
    4dec:	de bf       	out	0x3e, r29	; 62
    4dee:	0f be       	out	0x3f, r0	; 63
    4df0:	cd bf       	out	0x3d, r28	; 61
    4df2:	cf 91       	pop	r28
    4df4:	df 91       	pop	r29
    4df6:	08 95       	ret

00004df8 <MDIO_GetPinVal>:




DIO_VALUE_e MDIO_GetPinVal(DIO_PORT_e A_portID, DIO_PIN_e A_pinID)
{
    4df8:	df 93       	push	r29
    4dfa:	cf 93       	push	r28
    4dfc:	00 d0       	rcall	.+0      	; 0x4dfe <MDIO_GetPinVal+0x6>
    4dfe:	00 d0       	rcall	.+0      	; 0x4e00 <MDIO_GetPinVal+0x8>
    4e00:	0f 92       	push	r0
    4e02:	cd b7       	in	r28, 0x3d	; 61
    4e04:	de b7       	in	r29, 0x3e	; 62
    4e06:	8a 83       	std	Y+2, r24	; 0x02
    4e08:	6b 83       	std	Y+3, r22	; 0x03
	DIO_VALUE_e local_PinValue;

	// Input Validation
	if ( (A_portID <= DIO_PORTD) && (A_pinID <= PIN7) )
    4e0a:	8a 81       	ldd	r24, Y+2	; 0x02
    4e0c:	84 30       	cpi	r24, 0x04	; 4
    4e0e:	08 f0       	brcs	.+2      	; 0x4e12 <MDIO_GetPinVal+0x1a>
    4e10:	6b c0       	rjmp	.+214    	; 0x4ee8 <MDIO_GetPinVal+0xf0>
    4e12:	8b 81       	ldd	r24, Y+3	; 0x03
    4e14:	88 30       	cpi	r24, 0x08	; 8
    4e16:	08 f0       	brcs	.+2      	; 0x4e1a <MDIO_GetPinVal+0x22>
    4e18:	67 c0       	rjmp	.+206    	; 0x4ee8 <MDIO_GetPinVal+0xf0>
	{
		switch (A_portID)
    4e1a:	8a 81       	ldd	r24, Y+2	; 0x02
    4e1c:	28 2f       	mov	r18, r24
    4e1e:	30 e0       	ldi	r19, 0x00	; 0
    4e20:	3d 83       	std	Y+5, r19	; 0x05
    4e22:	2c 83       	std	Y+4, r18	; 0x04
    4e24:	4c 81       	ldd	r20, Y+4	; 0x04
    4e26:	5d 81       	ldd	r21, Y+5	; 0x05
    4e28:	41 30       	cpi	r20, 0x01	; 1
    4e2a:	51 05       	cpc	r21, r1
    4e2c:	41 f1       	breq	.+80     	; 0x4e7e <MDIO_GetPinVal+0x86>
    4e2e:	8c 81       	ldd	r24, Y+4	; 0x04
    4e30:	9d 81       	ldd	r25, Y+5	; 0x05
    4e32:	82 30       	cpi	r24, 0x02	; 2
    4e34:	91 05       	cpc	r25, r1
    4e36:	34 f4       	brge	.+12     	; 0x4e44 <MDIO_GetPinVal+0x4c>
    4e38:	2c 81       	ldd	r18, Y+4	; 0x04
    4e3a:	3d 81       	ldd	r19, Y+5	; 0x05
    4e3c:	21 15       	cp	r18, r1
    4e3e:	31 05       	cpc	r19, r1
    4e40:	61 f0       	breq	.+24     	; 0x4e5a <MDIO_GetPinVal+0x62>
    4e42:	52 c0       	rjmp	.+164    	; 0x4ee8 <MDIO_GetPinVal+0xf0>
    4e44:	4c 81       	ldd	r20, Y+4	; 0x04
    4e46:	5d 81       	ldd	r21, Y+5	; 0x05
    4e48:	42 30       	cpi	r20, 0x02	; 2
    4e4a:	51 05       	cpc	r21, r1
    4e4c:	51 f1       	breq	.+84     	; 0x4ea2 <MDIO_GetPinVal+0xaa>
    4e4e:	8c 81       	ldd	r24, Y+4	; 0x04
    4e50:	9d 81       	ldd	r25, Y+5	; 0x05
    4e52:	83 30       	cpi	r24, 0x03	; 3
    4e54:	91 05       	cpc	r25, r1
    4e56:	b9 f1       	breq	.+110    	; 0x4ec6 <MDIO_GetPinVal+0xce>
    4e58:	47 c0       	rjmp	.+142    	; 0x4ee8 <MDIO_GetPinVal+0xf0>
		{
		case DIO_PORTA:
			local_PinValue = GET_BIT(PINA_REG,A_pinID);
    4e5a:	e9 e3       	ldi	r30, 0x39	; 57
    4e5c:	f0 e0       	ldi	r31, 0x00	; 0
    4e5e:	80 81       	ld	r24, Z
    4e60:	28 2f       	mov	r18, r24
    4e62:	30 e0       	ldi	r19, 0x00	; 0
    4e64:	8b 81       	ldd	r24, Y+3	; 0x03
    4e66:	88 2f       	mov	r24, r24
    4e68:	90 e0       	ldi	r25, 0x00	; 0
    4e6a:	a9 01       	movw	r20, r18
    4e6c:	02 c0       	rjmp	.+4      	; 0x4e72 <MDIO_GetPinVal+0x7a>
    4e6e:	55 95       	asr	r21
    4e70:	47 95       	ror	r20
    4e72:	8a 95       	dec	r24
    4e74:	e2 f7       	brpl	.-8      	; 0x4e6e <MDIO_GetPinVal+0x76>
    4e76:	ca 01       	movw	r24, r20
    4e78:	81 70       	andi	r24, 0x01	; 1
    4e7a:	89 83       	std	Y+1, r24	; 0x01
    4e7c:	35 c0       	rjmp	.+106    	; 0x4ee8 <MDIO_GetPinVal+0xf0>
			break;
		case DIO_PORTB:
			local_PinValue = GET_BIT(PINB_REG,A_pinID);
    4e7e:	e6 e3       	ldi	r30, 0x36	; 54
    4e80:	f0 e0       	ldi	r31, 0x00	; 0
    4e82:	80 81       	ld	r24, Z
    4e84:	28 2f       	mov	r18, r24
    4e86:	30 e0       	ldi	r19, 0x00	; 0
    4e88:	8b 81       	ldd	r24, Y+3	; 0x03
    4e8a:	88 2f       	mov	r24, r24
    4e8c:	90 e0       	ldi	r25, 0x00	; 0
    4e8e:	a9 01       	movw	r20, r18
    4e90:	02 c0       	rjmp	.+4      	; 0x4e96 <MDIO_GetPinVal+0x9e>
    4e92:	55 95       	asr	r21
    4e94:	47 95       	ror	r20
    4e96:	8a 95       	dec	r24
    4e98:	e2 f7       	brpl	.-8      	; 0x4e92 <MDIO_GetPinVal+0x9a>
    4e9a:	ca 01       	movw	r24, r20
    4e9c:	81 70       	andi	r24, 0x01	; 1
    4e9e:	89 83       	std	Y+1, r24	; 0x01
    4ea0:	23 c0       	rjmp	.+70     	; 0x4ee8 <MDIO_GetPinVal+0xf0>
			break;
		case DIO_PORTC:
			local_PinValue = GET_BIT(PINC_REG,A_pinID);
    4ea2:	e3 e3       	ldi	r30, 0x33	; 51
    4ea4:	f0 e0       	ldi	r31, 0x00	; 0
    4ea6:	80 81       	ld	r24, Z
    4ea8:	28 2f       	mov	r18, r24
    4eaa:	30 e0       	ldi	r19, 0x00	; 0
    4eac:	8b 81       	ldd	r24, Y+3	; 0x03
    4eae:	88 2f       	mov	r24, r24
    4eb0:	90 e0       	ldi	r25, 0x00	; 0
    4eb2:	a9 01       	movw	r20, r18
    4eb4:	02 c0       	rjmp	.+4      	; 0x4eba <MDIO_GetPinVal+0xc2>
    4eb6:	55 95       	asr	r21
    4eb8:	47 95       	ror	r20
    4eba:	8a 95       	dec	r24
    4ebc:	e2 f7       	brpl	.-8      	; 0x4eb6 <MDIO_GetPinVal+0xbe>
    4ebe:	ca 01       	movw	r24, r20
    4ec0:	81 70       	andi	r24, 0x01	; 1
    4ec2:	89 83       	std	Y+1, r24	; 0x01
    4ec4:	11 c0       	rjmp	.+34     	; 0x4ee8 <MDIO_GetPinVal+0xf0>
			break;
		case DIO_PORTD:
			local_PinValue = GET_BIT(PIND_REG,A_pinID);
    4ec6:	e0 e3       	ldi	r30, 0x30	; 48
    4ec8:	f0 e0       	ldi	r31, 0x00	; 0
    4eca:	80 81       	ld	r24, Z
    4ecc:	28 2f       	mov	r18, r24
    4ece:	30 e0       	ldi	r19, 0x00	; 0
    4ed0:	8b 81       	ldd	r24, Y+3	; 0x03
    4ed2:	88 2f       	mov	r24, r24
    4ed4:	90 e0       	ldi	r25, 0x00	; 0
    4ed6:	a9 01       	movw	r20, r18
    4ed8:	02 c0       	rjmp	.+4      	; 0x4ede <MDIO_GetPinVal+0xe6>
    4eda:	55 95       	asr	r21
    4edc:	47 95       	ror	r20
    4ede:	8a 95       	dec	r24
    4ee0:	e2 f7       	brpl	.-8      	; 0x4eda <MDIO_GetPinVal+0xe2>
    4ee2:	ca 01       	movw	r24, r20
    4ee4:	81 70       	andi	r24, 0x01	; 1
    4ee6:	89 83       	std	Y+1, r24	; 0x01
	{
		// Do Nothing
	}


	return local_PinValue;
    4ee8:	89 81       	ldd	r24, Y+1	; 0x01
}
    4eea:	0f 90       	pop	r0
    4eec:	0f 90       	pop	r0
    4eee:	0f 90       	pop	r0
    4ef0:	0f 90       	pop	r0
    4ef2:	0f 90       	pop	r0
    4ef4:	cf 91       	pop	r28
    4ef6:	df 91       	pop	r29
    4ef8:	08 95       	ret

00004efa <MDIO_vTogglePinVal>:

void MDIO_vTogglePinVal (DIO_PORT_e A_portID, DIO_PIN_e A_pinID)
{
    4efa:	df 93       	push	r29
    4efc:	cf 93       	push	r28
    4efe:	00 d0       	rcall	.+0      	; 0x4f00 <MDIO_vTogglePinVal+0x6>
    4f00:	00 d0       	rcall	.+0      	; 0x4f02 <MDIO_vTogglePinVal+0x8>
    4f02:	cd b7       	in	r28, 0x3d	; 61
    4f04:	de b7       	in	r29, 0x3e	; 62
    4f06:	89 83       	std	Y+1, r24	; 0x01
    4f08:	6a 83       	std	Y+2, r22	; 0x02
	// Input Validation
	if ( (A_portID <= DIO_PORTD) && (A_pinID <= PIN7) )
    4f0a:	89 81       	ldd	r24, Y+1	; 0x01
    4f0c:	84 30       	cpi	r24, 0x04	; 4
    4f0e:	08 f0       	brcs	.+2      	; 0x4f12 <MDIO_vTogglePinVal+0x18>
    4f10:	72 c0       	rjmp	.+228    	; 0x4ff6 <MDIO_vTogglePinVal+0xfc>
    4f12:	8a 81       	ldd	r24, Y+2	; 0x02
    4f14:	88 30       	cpi	r24, 0x08	; 8
    4f16:	08 f0       	brcs	.+2      	; 0x4f1a <MDIO_vTogglePinVal+0x20>
    4f18:	6e c0       	rjmp	.+220    	; 0x4ff6 <MDIO_vTogglePinVal+0xfc>
	{
		switch (A_portID)
    4f1a:	89 81       	ldd	r24, Y+1	; 0x01
    4f1c:	28 2f       	mov	r18, r24
    4f1e:	30 e0       	ldi	r19, 0x00	; 0
    4f20:	3c 83       	std	Y+4, r19	; 0x04
    4f22:	2b 83       	std	Y+3, r18	; 0x03
    4f24:	8b 81       	ldd	r24, Y+3	; 0x03
    4f26:	9c 81       	ldd	r25, Y+4	; 0x04
    4f28:	81 30       	cpi	r24, 0x01	; 1
    4f2a:	91 05       	cpc	r25, r1
    4f2c:	49 f1       	breq	.+82     	; 0x4f80 <MDIO_vTogglePinVal+0x86>
    4f2e:	2b 81       	ldd	r18, Y+3	; 0x03
    4f30:	3c 81       	ldd	r19, Y+4	; 0x04
    4f32:	22 30       	cpi	r18, 0x02	; 2
    4f34:	31 05       	cpc	r19, r1
    4f36:	2c f4       	brge	.+10     	; 0x4f42 <MDIO_vTogglePinVal+0x48>
    4f38:	8b 81       	ldd	r24, Y+3	; 0x03
    4f3a:	9c 81       	ldd	r25, Y+4	; 0x04
    4f3c:	00 97       	sbiw	r24, 0x00	; 0
    4f3e:	61 f0       	breq	.+24     	; 0x4f58 <MDIO_vTogglePinVal+0x5e>
    4f40:	5a c0       	rjmp	.+180    	; 0x4ff6 <MDIO_vTogglePinVal+0xfc>
    4f42:	2b 81       	ldd	r18, Y+3	; 0x03
    4f44:	3c 81       	ldd	r19, Y+4	; 0x04
    4f46:	22 30       	cpi	r18, 0x02	; 2
    4f48:	31 05       	cpc	r19, r1
    4f4a:	71 f1       	breq	.+92     	; 0x4fa8 <MDIO_vTogglePinVal+0xae>
    4f4c:	8b 81       	ldd	r24, Y+3	; 0x03
    4f4e:	9c 81       	ldd	r25, Y+4	; 0x04
    4f50:	83 30       	cpi	r24, 0x03	; 3
    4f52:	91 05       	cpc	r25, r1
    4f54:	e9 f1       	breq	.+122    	; 0x4fd0 <MDIO_vTogglePinVal+0xd6>
    4f56:	4f c0       	rjmp	.+158    	; 0x4ff6 <MDIO_vTogglePinVal+0xfc>
		{
		case DIO_PORTA:
			TOGGLE_BIT(PORTA_REG,A_pinID);
    4f58:	ab e3       	ldi	r26, 0x3B	; 59
    4f5a:	b0 e0       	ldi	r27, 0x00	; 0
    4f5c:	eb e3       	ldi	r30, 0x3B	; 59
    4f5e:	f0 e0       	ldi	r31, 0x00	; 0
    4f60:	80 81       	ld	r24, Z
    4f62:	48 2f       	mov	r20, r24
    4f64:	8a 81       	ldd	r24, Y+2	; 0x02
    4f66:	28 2f       	mov	r18, r24
    4f68:	30 e0       	ldi	r19, 0x00	; 0
    4f6a:	81 e0       	ldi	r24, 0x01	; 1
    4f6c:	90 e0       	ldi	r25, 0x00	; 0
    4f6e:	02 2e       	mov	r0, r18
    4f70:	02 c0       	rjmp	.+4      	; 0x4f76 <MDIO_vTogglePinVal+0x7c>
    4f72:	88 0f       	add	r24, r24
    4f74:	99 1f       	adc	r25, r25
    4f76:	0a 94       	dec	r0
    4f78:	e2 f7       	brpl	.-8      	; 0x4f72 <MDIO_vTogglePinVal+0x78>
    4f7a:	84 27       	eor	r24, r20
    4f7c:	8c 93       	st	X, r24
    4f7e:	3b c0       	rjmp	.+118    	; 0x4ff6 <MDIO_vTogglePinVal+0xfc>
			break;
		case DIO_PORTB:
			TOGGLE_BIT(PORTB_REG,A_pinID);
    4f80:	a8 e3       	ldi	r26, 0x38	; 56
    4f82:	b0 e0       	ldi	r27, 0x00	; 0
    4f84:	e8 e3       	ldi	r30, 0x38	; 56
    4f86:	f0 e0       	ldi	r31, 0x00	; 0
    4f88:	80 81       	ld	r24, Z
    4f8a:	48 2f       	mov	r20, r24
    4f8c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f8e:	28 2f       	mov	r18, r24
    4f90:	30 e0       	ldi	r19, 0x00	; 0
    4f92:	81 e0       	ldi	r24, 0x01	; 1
    4f94:	90 e0       	ldi	r25, 0x00	; 0
    4f96:	02 2e       	mov	r0, r18
    4f98:	02 c0       	rjmp	.+4      	; 0x4f9e <MDIO_vTogglePinVal+0xa4>
    4f9a:	88 0f       	add	r24, r24
    4f9c:	99 1f       	adc	r25, r25
    4f9e:	0a 94       	dec	r0
    4fa0:	e2 f7       	brpl	.-8      	; 0x4f9a <MDIO_vTogglePinVal+0xa0>
    4fa2:	84 27       	eor	r24, r20
    4fa4:	8c 93       	st	X, r24
    4fa6:	27 c0       	rjmp	.+78     	; 0x4ff6 <MDIO_vTogglePinVal+0xfc>
			break;
		case DIO_PORTC:
			TOGGLE_BIT(PORTC_REG,A_pinID);
    4fa8:	a5 e3       	ldi	r26, 0x35	; 53
    4faa:	b0 e0       	ldi	r27, 0x00	; 0
    4fac:	e5 e3       	ldi	r30, 0x35	; 53
    4fae:	f0 e0       	ldi	r31, 0x00	; 0
    4fb0:	80 81       	ld	r24, Z
    4fb2:	48 2f       	mov	r20, r24
    4fb4:	8a 81       	ldd	r24, Y+2	; 0x02
    4fb6:	28 2f       	mov	r18, r24
    4fb8:	30 e0       	ldi	r19, 0x00	; 0
    4fba:	81 e0       	ldi	r24, 0x01	; 1
    4fbc:	90 e0       	ldi	r25, 0x00	; 0
    4fbe:	02 2e       	mov	r0, r18
    4fc0:	02 c0       	rjmp	.+4      	; 0x4fc6 <MDIO_vTogglePinVal+0xcc>
    4fc2:	88 0f       	add	r24, r24
    4fc4:	99 1f       	adc	r25, r25
    4fc6:	0a 94       	dec	r0
    4fc8:	e2 f7       	brpl	.-8      	; 0x4fc2 <MDIO_vTogglePinVal+0xc8>
    4fca:	84 27       	eor	r24, r20
    4fcc:	8c 93       	st	X, r24
    4fce:	13 c0       	rjmp	.+38     	; 0x4ff6 <MDIO_vTogglePinVal+0xfc>
			break;
		case DIO_PORTD:
			TOGGLE_BIT(PORTD_REG,A_pinID);
    4fd0:	a2 e3       	ldi	r26, 0x32	; 50
    4fd2:	b0 e0       	ldi	r27, 0x00	; 0
    4fd4:	e2 e3       	ldi	r30, 0x32	; 50
    4fd6:	f0 e0       	ldi	r31, 0x00	; 0
    4fd8:	80 81       	ld	r24, Z
    4fda:	48 2f       	mov	r20, r24
    4fdc:	8a 81       	ldd	r24, Y+2	; 0x02
    4fde:	28 2f       	mov	r18, r24
    4fe0:	30 e0       	ldi	r19, 0x00	; 0
    4fe2:	81 e0       	ldi	r24, 0x01	; 1
    4fe4:	90 e0       	ldi	r25, 0x00	; 0
    4fe6:	02 2e       	mov	r0, r18
    4fe8:	02 c0       	rjmp	.+4      	; 0x4fee <MDIO_vTogglePinVal+0xf4>
    4fea:	88 0f       	add	r24, r24
    4fec:	99 1f       	adc	r25, r25
    4fee:	0a 94       	dec	r0
    4ff0:	e2 f7       	brpl	.-8      	; 0x4fea <MDIO_vTogglePinVal+0xf0>
    4ff2:	84 27       	eor	r24, r20
    4ff4:	8c 93       	st	X, r24
	}
	else
	{
		// Do Nothing
	}
}
    4ff6:	0f 90       	pop	r0
    4ff8:	0f 90       	pop	r0
    4ffa:	0f 90       	pop	r0
    4ffc:	0f 90       	pop	r0
    4ffe:	cf 91       	pop	r28
    5000:	df 91       	pop	r29
    5002:	08 95       	ret

00005004 <MDIO_vSetPortDir>:


void MDIO_vSetPortDir (DIO_PORT_e A_portID, u8 A_u8PortDirection)
{
    5004:	df 93       	push	r29
    5006:	cf 93       	push	r28
    5008:	00 d0       	rcall	.+0      	; 0x500a <MDIO_vSetPortDir+0x6>
    500a:	00 d0       	rcall	.+0      	; 0x500c <MDIO_vSetPortDir+0x8>
    500c:	cd b7       	in	r28, 0x3d	; 61
    500e:	de b7       	in	r29, 0x3e	; 62
    5010:	89 83       	std	Y+1, r24	; 0x01
    5012:	6a 83       	std	Y+2, r22	; 0x02
	// Input Validation
	if ( (A_portID <= DIO_PORTD) )
    5014:	89 81       	ldd	r24, Y+1	; 0x01
    5016:	84 30       	cpi	r24, 0x04	; 4
    5018:	90 f5       	brcc	.+100    	; 0x507e <MDIO_vSetPortDir+0x7a>
	{
		switch (A_portID)
    501a:	89 81       	ldd	r24, Y+1	; 0x01
    501c:	28 2f       	mov	r18, r24
    501e:	30 e0       	ldi	r19, 0x00	; 0
    5020:	3c 83       	std	Y+4, r19	; 0x04
    5022:	2b 83       	std	Y+3, r18	; 0x03
    5024:	8b 81       	ldd	r24, Y+3	; 0x03
    5026:	9c 81       	ldd	r25, Y+4	; 0x04
    5028:	81 30       	cpi	r24, 0x01	; 1
    502a:	91 05       	cpc	r25, r1
    502c:	d1 f0       	breq	.+52     	; 0x5062 <MDIO_vSetPortDir+0x5e>
    502e:	2b 81       	ldd	r18, Y+3	; 0x03
    5030:	3c 81       	ldd	r19, Y+4	; 0x04
    5032:	22 30       	cpi	r18, 0x02	; 2
    5034:	31 05       	cpc	r19, r1
    5036:	2c f4       	brge	.+10     	; 0x5042 <MDIO_vSetPortDir+0x3e>
    5038:	8b 81       	ldd	r24, Y+3	; 0x03
    503a:	9c 81       	ldd	r25, Y+4	; 0x04
    503c:	00 97       	sbiw	r24, 0x00	; 0
    503e:	61 f0       	breq	.+24     	; 0x5058 <MDIO_vSetPortDir+0x54>
    5040:	1e c0       	rjmp	.+60     	; 0x507e <MDIO_vSetPortDir+0x7a>
    5042:	2b 81       	ldd	r18, Y+3	; 0x03
    5044:	3c 81       	ldd	r19, Y+4	; 0x04
    5046:	22 30       	cpi	r18, 0x02	; 2
    5048:	31 05       	cpc	r19, r1
    504a:	81 f0       	breq	.+32     	; 0x506c <MDIO_vSetPortDir+0x68>
    504c:	8b 81       	ldd	r24, Y+3	; 0x03
    504e:	9c 81       	ldd	r25, Y+4	; 0x04
    5050:	83 30       	cpi	r24, 0x03	; 3
    5052:	91 05       	cpc	r25, r1
    5054:	81 f0       	breq	.+32     	; 0x5076 <MDIO_vSetPortDir+0x72>
    5056:	13 c0       	rjmp	.+38     	; 0x507e <MDIO_vSetPortDir+0x7a>
		{
		case DIO_PORTA:
			DDRA_REG = A_u8PortDirection;
    5058:	ea e3       	ldi	r30, 0x3A	; 58
    505a:	f0 e0       	ldi	r31, 0x00	; 0
    505c:	8a 81       	ldd	r24, Y+2	; 0x02
    505e:	80 83       	st	Z, r24
    5060:	0e c0       	rjmp	.+28     	; 0x507e <MDIO_vSetPortDir+0x7a>
			break;
		case DIO_PORTB:
			DDRB_REG = A_u8PortDirection;
    5062:	e7 e3       	ldi	r30, 0x37	; 55
    5064:	f0 e0       	ldi	r31, 0x00	; 0
    5066:	8a 81       	ldd	r24, Y+2	; 0x02
    5068:	80 83       	st	Z, r24
    506a:	09 c0       	rjmp	.+18     	; 0x507e <MDIO_vSetPortDir+0x7a>
			break;
		case DIO_PORTC:
			DDRC_REG = A_u8PortDirection;
    506c:	e4 e3       	ldi	r30, 0x34	; 52
    506e:	f0 e0       	ldi	r31, 0x00	; 0
    5070:	8a 81       	ldd	r24, Y+2	; 0x02
    5072:	80 83       	st	Z, r24
    5074:	04 c0       	rjmp	.+8      	; 0x507e <MDIO_vSetPortDir+0x7a>
			break;
		case DIO_PORTD:
			DDRD_REG = A_u8PortDirection;
    5076:	e1 e3       	ldi	r30, 0x31	; 49
    5078:	f0 e0       	ldi	r31, 0x00	; 0
    507a:	8a 81       	ldd	r24, Y+2	; 0x02
    507c:	80 83       	st	Z, r24
	}
	else
	{
		// Do Nothing
	}
}
    507e:	0f 90       	pop	r0
    5080:	0f 90       	pop	r0
    5082:	0f 90       	pop	r0
    5084:	0f 90       	pop	r0
    5086:	cf 91       	pop	r28
    5088:	df 91       	pop	r29
    508a:	08 95       	ret

0000508c <MDIO_vSetPortVal>:

void MDIO_vSetPortVal (DIO_PORT_e A_portID, u8 A_u8PortValue)
{
    508c:	df 93       	push	r29
    508e:	cf 93       	push	r28
    5090:	00 d0       	rcall	.+0      	; 0x5092 <MDIO_vSetPortVal+0x6>
    5092:	00 d0       	rcall	.+0      	; 0x5094 <MDIO_vSetPortVal+0x8>
    5094:	cd b7       	in	r28, 0x3d	; 61
    5096:	de b7       	in	r29, 0x3e	; 62
    5098:	89 83       	std	Y+1, r24	; 0x01
    509a:	6a 83       	std	Y+2, r22	; 0x02
	// Input Validation
	if ( (A_portID <= DIO_PORTD) )
    509c:	89 81       	ldd	r24, Y+1	; 0x01
    509e:	84 30       	cpi	r24, 0x04	; 4
    50a0:	90 f5       	brcc	.+100    	; 0x5106 <MDIO_vSetPortVal+0x7a>
	{
		switch (A_portID)
    50a2:	89 81       	ldd	r24, Y+1	; 0x01
    50a4:	28 2f       	mov	r18, r24
    50a6:	30 e0       	ldi	r19, 0x00	; 0
    50a8:	3c 83       	std	Y+4, r19	; 0x04
    50aa:	2b 83       	std	Y+3, r18	; 0x03
    50ac:	8b 81       	ldd	r24, Y+3	; 0x03
    50ae:	9c 81       	ldd	r25, Y+4	; 0x04
    50b0:	81 30       	cpi	r24, 0x01	; 1
    50b2:	91 05       	cpc	r25, r1
    50b4:	d1 f0       	breq	.+52     	; 0x50ea <MDIO_vSetPortVal+0x5e>
    50b6:	2b 81       	ldd	r18, Y+3	; 0x03
    50b8:	3c 81       	ldd	r19, Y+4	; 0x04
    50ba:	22 30       	cpi	r18, 0x02	; 2
    50bc:	31 05       	cpc	r19, r1
    50be:	2c f4       	brge	.+10     	; 0x50ca <MDIO_vSetPortVal+0x3e>
    50c0:	8b 81       	ldd	r24, Y+3	; 0x03
    50c2:	9c 81       	ldd	r25, Y+4	; 0x04
    50c4:	00 97       	sbiw	r24, 0x00	; 0
    50c6:	61 f0       	breq	.+24     	; 0x50e0 <MDIO_vSetPortVal+0x54>
    50c8:	1e c0       	rjmp	.+60     	; 0x5106 <MDIO_vSetPortVal+0x7a>
    50ca:	2b 81       	ldd	r18, Y+3	; 0x03
    50cc:	3c 81       	ldd	r19, Y+4	; 0x04
    50ce:	22 30       	cpi	r18, 0x02	; 2
    50d0:	31 05       	cpc	r19, r1
    50d2:	81 f0       	breq	.+32     	; 0x50f4 <MDIO_vSetPortVal+0x68>
    50d4:	8b 81       	ldd	r24, Y+3	; 0x03
    50d6:	9c 81       	ldd	r25, Y+4	; 0x04
    50d8:	83 30       	cpi	r24, 0x03	; 3
    50da:	91 05       	cpc	r25, r1
    50dc:	81 f0       	breq	.+32     	; 0x50fe <MDIO_vSetPortVal+0x72>
    50de:	13 c0       	rjmp	.+38     	; 0x5106 <MDIO_vSetPortVal+0x7a>
		{
		case DIO_PORTA:
			PORTA_REG = A_u8PortValue;
    50e0:	eb e3       	ldi	r30, 0x3B	; 59
    50e2:	f0 e0       	ldi	r31, 0x00	; 0
    50e4:	8a 81       	ldd	r24, Y+2	; 0x02
    50e6:	80 83       	st	Z, r24
    50e8:	0e c0       	rjmp	.+28     	; 0x5106 <MDIO_vSetPortVal+0x7a>
			break;
		case DIO_PORTB:
			PORTB_REG = A_u8PortValue;
    50ea:	e8 e3       	ldi	r30, 0x38	; 56
    50ec:	f0 e0       	ldi	r31, 0x00	; 0
    50ee:	8a 81       	ldd	r24, Y+2	; 0x02
    50f0:	80 83       	st	Z, r24
    50f2:	09 c0       	rjmp	.+18     	; 0x5106 <MDIO_vSetPortVal+0x7a>
			break;
		case DIO_PORTC:
			PORTC_REG = A_u8PortValue;
    50f4:	e5 e3       	ldi	r30, 0x35	; 53
    50f6:	f0 e0       	ldi	r31, 0x00	; 0
    50f8:	8a 81       	ldd	r24, Y+2	; 0x02
    50fa:	80 83       	st	Z, r24
    50fc:	04 c0       	rjmp	.+8      	; 0x5106 <MDIO_vSetPortVal+0x7a>
			break;
		case DIO_PORTD:
			PORTD_REG = A_u8PortValue;
    50fe:	e2 e3       	ldi	r30, 0x32	; 50
    5100:	f0 e0       	ldi	r31, 0x00	; 0
    5102:	8a 81       	ldd	r24, Y+2	; 0x02
    5104:	80 83       	st	Z, r24
	}
	else
	{
		// Do Nothing
	}
}
    5106:	0f 90       	pop	r0
    5108:	0f 90       	pop	r0
    510a:	0f 90       	pop	r0
    510c:	0f 90       	pop	r0
    510e:	cf 91       	pop	r28
    5110:	df 91       	pop	r29
    5112:	08 95       	ret

00005114 <MDIO_vInit>:


void MDIO_vInit()
{
    5114:	df 93       	push	r29
    5116:	cf 93       	push	r28
    5118:	cd b7       	in	r28, 0x3d	; 61
    511a:	de b7       	in	r29, 0x3e	; 62

	DDRA_REG = CONC_BIT(PA7_INITIAL_DIRECTION,PA6_INITIAL_DIRECTION,
    511c:	ea e3       	ldi	r30, 0x3A	; 58
    511e:	f0 e0       	ldi	r31, 0x00	; 0
    5120:	10 82       	st	Z, r1
						PA5_INITIAL_DIRECTION,PA4_INITIAL_DIRECTION,
						PA3_INITIAL_DIRECTION,PA2_INITIAL_DIRECTION,
						PA1_INITIAL_DIRECTION,PA0_INITIAL_DIRECTION);

	DDRB_REG = CONC_BIT(PB7_INITIAL_DIRECTION,PB6_INITIAL_DIRECTION,
    5122:	e7 e3       	ldi	r30, 0x37	; 55
    5124:	f0 e0       	ldi	r31, 0x00	; 0
    5126:	10 82       	st	Z, r1
						PB5_INITIAL_DIRECTION,PB4_INITIAL_DIRECTION,
						PB3_INITIAL_DIRECTION,PB2_INITIAL_DIRECTION,
						PB1_INITIAL_DIRECTION,PB0_INITIAL_DIRECTION);

	DDRC_REG = CONC_BIT(PC7_INITIAL_DIRECTION,PC6_INITIAL_DIRECTION,
    5128:	e4 e3       	ldi	r30, 0x34	; 52
    512a:	f0 e0       	ldi	r31, 0x00	; 0
    512c:	87 e0       	ldi	r24, 0x07	; 7
    512e:	80 83       	st	Z, r24
						PC5_INITIAL_DIRECTION,PC4_INITIAL_DIRECTION,
						PC3_INITIAL_DIRECTION,PC2_INITIAL_DIRECTION,
						PC1_INITIAL_DIRECTION,PC0_INITIAL_DIRECTION);

	DDRD_REG = CONC_BIT(PD7_INITIAL_DIRECTION,PD6_INITIAL_DIRECTION,
    5130:	e1 e3       	ldi	r30, 0x31	; 49
    5132:	f0 e0       	ldi	r31, 0x00	; 0
    5134:	8f ef       	ldi	r24, 0xFF	; 255
    5136:	80 83       	st	Z, r24
						PD3_INITIAL_DIRECTION,PD2_INITIAL_DIRECTION,
						PD1_INITIAL_DIRECTION,PD0_INITIAL_DIRECTION);

	/**********************************************************************/

	PORTA_REG = CONC_BIT(PA7_INITIAL_VALUE,PA6_INITIAL_VALUE,
    5138:	eb e3       	ldi	r30, 0x3B	; 59
    513a:	f0 e0       	ldi	r31, 0x00	; 0
    513c:	10 82       	st	Z, r1
						 PA5_INITIAL_VALUE,PA4_INITIAL_VALUE,
						 PA3_INITIAL_VALUE,PA2_INITIAL_VALUE,
						 PA1_INITIAL_VALUE,PA0_INITIAL_VALUE);

	PORTB_REG = CONC_BIT(PB7_INITIAL_VALUE,PB6_INITIAL_VALUE,
    513e:	e8 e3       	ldi	r30, 0x38	; 56
    5140:	f0 e0       	ldi	r31, 0x00	; 0
    5142:	84 e0       	ldi	r24, 0x04	; 4
    5144:	80 83       	st	Z, r24
						 PB5_INITIAL_VALUE,PB4_INITIAL_VALUE,
						 PB3_INITIAL_VALUE,PB2_INITIAL_VALUE,
						 PB1_INITIAL_VALUE,PB0_INITIAL_VALUE);

	PORTC_REG = CONC_BIT(PC7_INITIAL_VALUE,PC6_INITIAL_VALUE,
    5146:	e5 e3       	ldi	r30, 0x35	; 53
    5148:	f0 e0       	ldi	r31, 0x00	; 0
    514a:	10 82       	st	Z, r1
						 PC5_INITIAL_VALUE,PC4_INITIAL_VALUE,
						 PC3_INITIAL_VALUE,PC2_INITIAL_VALUE,
						 PC1_INITIAL_VALUE,PC0_INITIAL_VALUE);

	PORTD_REG = CONC_BIT(PD7_INITIAL_VALUE,PD6_INITIAL_VALUE,
    514c:	e2 e3       	ldi	r30, 0x32	; 50
    514e:	f0 e0       	ldi	r31, 0x00	; 0
    5150:	10 82       	st	Z, r1
						 PD5_INITIAL_VALUE,PD4_INITIAL_VALUE,
						 PD3_INITIAL_VALUE,PD2_INITIAL_VALUE,
						 PD1_INITIAL_VALUE,PD0_INITIAL_VALUE);
}
    5152:	cf 91       	pop	r28
    5154:	df 91       	pop	r29
    5156:	08 95       	ret

00005158 <LCD_InitPortDir>:

#include <util/delay.h>


void LCD_InitPortDir()
{
    5158:	df 93       	push	r29
    515a:	cf 93       	push	r28
    515c:	cd b7       	in	r28, 0x3d	; 61
    515e:	de b7       	in	r29, 0x3e	; 62
	MDIO_vSetPinDir(LCD_CTRL_PORT , LCD_RS_PIN , DIO_OUTPUT);
    5160:	82 e0       	ldi	r24, 0x02	; 2
    5162:	60 e0       	ldi	r22, 0x00	; 0
    5164:	41 e0       	ldi	r20, 0x01	; 1
    5166:	0e 94 b6 24 	call	0x496c	; 0x496c <MDIO_vSetPinDir>
	MDIO_vSetPinDir(LCD_CTRL_PORT , LCD_RW_PIN , DIO_OUTPUT);
    516a:	82 e0       	ldi	r24, 0x02	; 2
    516c:	61 e0       	ldi	r22, 0x01	; 1
    516e:	41 e0       	ldi	r20, 0x01	; 1
    5170:	0e 94 b6 24 	call	0x496c	; 0x496c <MDIO_vSetPinDir>
	MDIO_vSetPinDir(LCD_CTRL_PORT , LCD_E_PIN , DIO_OUTPUT);
    5174:	82 e0       	ldi	r24, 0x02	; 2
    5176:	62 e0       	ldi	r22, 0x02	; 2
    5178:	41 e0       	ldi	r20, 0x01	; 1
    517a:	0e 94 b6 24 	call	0x496c	; 0x496c <MDIO_vSetPinDir>


	MDIO_vSetPortDir(LCD_DATA_PORT,0xFF);
    517e:	83 e0       	ldi	r24, 0x03	; 3
    5180:	6f ef       	ldi	r22, 0xFF	; 255
    5182:	0e 94 02 28 	call	0x5004	; 0x5004 <MDIO_vSetPortDir>
}
    5186:	cf 91       	pop	r28
    5188:	df 91       	pop	r29
    518a:	08 95       	ret

0000518c <LCD_SendCommand>:

void LCD_SendCommand(u8 Command)
{
    518c:	df 93       	push	r29
    518e:	cf 93       	push	r28
    5190:	cd b7       	in	r28, 0x3d	; 61
    5192:	de b7       	in	r29, 0x3e	; 62
    5194:	2f 97       	sbiw	r28, 0x0f	; 15
    5196:	0f b6       	in	r0, 0x3f	; 63
    5198:	f8 94       	cli
    519a:	de bf       	out	0x3e, r29	; 62
    519c:	0f be       	out	0x3f, r0	; 63
    519e:	cd bf       	out	0x3d, r28	; 61
    51a0:	8f 87       	std	Y+15, r24	; 0x0f
	// Set RS -> 0
	MDIO_vSetPinVal(LCD_CTRL_PORT , LCD_RS_PIN , DIO_LOW);
    51a2:	82 e0       	ldi	r24, 0x02	; 2
    51a4:	60 e0       	ldi	r22, 0x00	; 0
    51a6:	40 e0       	ldi	r20, 0x00	; 0
    51a8:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <MDIO_vSetPinVal>
	// Set RW -> 0
	MDIO_vSetPinVal(LCD_CTRL_PORT , LCD_RW_PIN , DIO_LOW);
    51ac:	82 e0       	ldi	r24, 0x02	; 2
    51ae:	61 e0       	ldi	r22, 0x01	; 1
    51b0:	40 e0       	ldi	r20, 0x00	; 0
    51b2:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <MDIO_vSetPinVal>

	MDIO_vSetPortVal(LCD_DATA_PORT,Command);
    51b6:	83 e0       	ldi	r24, 0x03	; 3
    51b8:	6f 85       	ldd	r22, Y+15	; 0x0f
    51ba:	0e 94 46 28 	call	0x508c	; 0x508c <MDIO_vSetPortVal>

	MDIO_vSetPinVal(LCD_CTRL_PORT ,LCD_E_PIN , DIO_HIGH);
    51be:	82 e0       	ldi	r24, 0x02	; 2
    51c0:	62 e0       	ldi	r22, 0x02	; 2
    51c2:	41 e0       	ldi	r20, 0x01	; 1
    51c4:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <MDIO_vSetPinVal>
    51c8:	80 e0       	ldi	r24, 0x00	; 0
    51ca:	90 e0       	ldi	r25, 0x00	; 0
    51cc:	a0 e8       	ldi	r26, 0x80	; 128
    51ce:	bf e3       	ldi	r27, 0x3F	; 63
    51d0:	8b 87       	std	Y+11, r24	; 0x0b
    51d2:	9c 87       	std	Y+12, r25	; 0x0c
    51d4:	ad 87       	std	Y+13, r26	; 0x0d
    51d6:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    51d8:	6b 85       	ldd	r22, Y+11	; 0x0b
    51da:	7c 85       	ldd	r23, Y+12	; 0x0c
    51dc:	8d 85       	ldd	r24, Y+13	; 0x0d
    51de:	9e 85       	ldd	r25, Y+14	; 0x0e
    51e0:	20 e0       	ldi	r18, 0x00	; 0
    51e2:	30 e0       	ldi	r19, 0x00	; 0
    51e4:	4a ef       	ldi	r20, 0xFA	; 250
    51e6:	54 e4       	ldi	r21, 0x44	; 68
    51e8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    51ec:	dc 01       	movw	r26, r24
    51ee:	cb 01       	movw	r24, r22
    51f0:	8f 83       	std	Y+7, r24	; 0x07
    51f2:	98 87       	std	Y+8, r25	; 0x08
    51f4:	a9 87       	std	Y+9, r26	; 0x09
    51f6:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    51f8:	6f 81       	ldd	r22, Y+7	; 0x07
    51fa:	78 85       	ldd	r23, Y+8	; 0x08
    51fc:	89 85       	ldd	r24, Y+9	; 0x09
    51fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    5200:	20 e0       	ldi	r18, 0x00	; 0
    5202:	30 e0       	ldi	r19, 0x00	; 0
    5204:	40 e8       	ldi	r20, 0x80	; 128
    5206:	5f e3       	ldi	r21, 0x3F	; 63
    5208:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    520c:	88 23       	and	r24, r24
    520e:	2c f4       	brge	.+10     	; 0x521a <LCD_SendCommand+0x8e>
		__ticks = 1;
    5210:	81 e0       	ldi	r24, 0x01	; 1
    5212:	90 e0       	ldi	r25, 0x00	; 0
    5214:	9e 83       	std	Y+6, r25	; 0x06
    5216:	8d 83       	std	Y+5, r24	; 0x05
    5218:	3f c0       	rjmp	.+126    	; 0x5298 <LCD_SendCommand+0x10c>
	else if (__tmp > 65535)
    521a:	6f 81       	ldd	r22, Y+7	; 0x07
    521c:	78 85       	ldd	r23, Y+8	; 0x08
    521e:	89 85       	ldd	r24, Y+9	; 0x09
    5220:	9a 85       	ldd	r25, Y+10	; 0x0a
    5222:	20 e0       	ldi	r18, 0x00	; 0
    5224:	3f ef       	ldi	r19, 0xFF	; 255
    5226:	4f e7       	ldi	r20, 0x7F	; 127
    5228:	57 e4       	ldi	r21, 0x47	; 71
    522a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    522e:	18 16       	cp	r1, r24
    5230:	4c f5       	brge	.+82     	; 0x5284 <LCD_SendCommand+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5232:	6b 85       	ldd	r22, Y+11	; 0x0b
    5234:	7c 85       	ldd	r23, Y+12	; 0x0c
    5236:	8d 85       	ldd	r24, Y+13	; 0x0d
    5238:	9e 85       	ldd	r25, Y+14	; 0x0e
    523a:	20 e0       	ldi	r18, 0x00	; 0
    523c:	30 e0       	ldi	r19, 0x00	; 0
    523e:	40 e2       	ldi	r20, 0x20	; 32
    5240:	51 e4       	ldi	r21, 0x41	; 65
    5242:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5246:	dc 01       	movw	r26, r24
    5248:	cb 01       	movw	r24, r22
    524a:	bc 01       	movw	r22, r24
    524c:	cd 01       	movw	r24, r26
    524e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5252:	dc 01       	movw	r26, r24
    5254:	cb 01       	movw	r24, r22
    5256:	9e 83       	std	Y+6, r25	; 0x06
    5258:	8d 83       	std	Y+5, r24	; 0x05
    525a:	0f c0       	rjmp	.+30     	; 0x527a <LCD_SendCommand+0xee>
    525c:	88 ec       	ldi	r24, 0xC8	; 200
    525e:	90 e0       	ldi	r25, 0x00	; 0
    5260:	9c 83       	std	Y+4, r25	; 0x04
    5262:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5264:	8b 81       	ldd	r24, Y+3	; 0x03
    5266:	9c 81       	ldd	r25, Y+4	; 0x04
    5268:	01 97       	sbiw	r24, 0x01	; 1
    526a:	f1 f7       	brne	.-4      	; 0x5268 <LCD_SendCommand+0xdc>
    526c:	9c 83       	std	Y+4, r25	; 0x04
    526e:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5270:	8d 81       	ldd	r24, Y+5	; 0x05
    5272:	9e 81       	ldd	r25, Y+6	; 0x06
    5274:	01 97       	sbiw	r24, 0x01	; 1
    5276:	9e 83       	std	Y+6, r25	; 0x06
    5278:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    527a:	8d 81       	ldd	r24, Y+5	; 0x05
    527c:	9e 81       	ldd	r25, Y+6	; 0x06
    527e:	00 97       	sbiw	r24, 0x00	; 0
    5280:	69 f7       	brne	.-38     	; 0x525c <LCD_SendCommand+0xd0>
    5282:	14 c0       	rjmp	.+40     	; 0x52ac <LCD_SendCommand+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5284:	6f 81       	ldd	r22, Y+7	; 0x07
    5286:	78 85       	ldd	r23, Y+8	; 0x08
    5288:	89 85       	ldd	r24, Y+9	; 0x09
    528a:	9a 85       	ldd	r25, Y+10	; 0x0a
    528c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5290:	dc 01       	movw	r26, r24
    5292:	cb 01       	movw	r24, r22
    5294:	9e 83       	std	Y+6, r25	; 0x06
    5296:	8d 83       	std	Y+5, r24	; 0x05
    5298:	8d 81       	ldd	r24, Y+5	; 0x05
    529a:	9e 81       	ldd	r25, Y+6	; 0x06
    529c:	9a 83       	std	Y+2, r25	; 0x02
    529e:	89 83       	std	Y+1, r24	; 0x01
    52a0:	89 81       	ldd	r24, Y+1	; 0x01
    52a2:	9a 81       	ldd	r25, Y+2	; 0x02
    52a4:	01 97       	sbiw	r24, 0x01	; 1
    52a6:	f1 f7       	brne	.-4      	; 0x52a4 <LCD_SendCommand+0x118>
    52a8:	9a 83       	std	Y+2, r25	; 0x02
    52aa:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
	MDIO_vSetPinVal(LCD_CTRL_PORT ,LCD_E_PIN , DIO_LOW);
    52ac:	82 e0       	ldi	r24, 0x02	; 2
    52ae:	62 e0       	ldi	r22, 0x02	; 2
    52b0:	40 e0       	ldi	r20, 0x00	; 0
    52b2:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <MDIO_vSetPinVal>

}
    52b6:	2f 96       	adiw	r28, 0x0f	; 15
    52b8:	0f b6       	in	r0, 0x3f	; 63
    52ba:	f8 94       	cli
    52bc:	de bf       	out	0x3e, r29	; 62
    52be:	0f be       	out	0x3f, r0	; 63
    52c0:	cd bf       	out	0x3d, r28	; 61
    52c2:	cf 91       	pop	r28
    52c4:	df 91       	pop	r29
    52c6:	08 95       	ret

000052c8 <LCD_SendData>:
void LCD_SendData(u8 Data)
{
    52c8:	df 93       	push	r29
    52ca:	cf 93       	push	r28
    52cc:	cd b7       	in	r28, 0x3d	; 61
    52ce:	de b7       	in	r29, 0x3e	; 62
    52d0:	2f 97       	sbiw	r28, 0x0f	; 15
    52d2:	0f b6       	in	r0, 0x3f	; 63
    52d4:	f8 94       	cli
    52d6:	de bf       	out	0x3e, r29	; 62
    52d8:	0f be       	out	0x3f, r0	; 63
    52da:	cd bf       	out	0x3d, r28	; 61
    52dc:	8f 87       	std	Y+15, r24	; 0x0f
	// Set RS -> 1
	MDIO_vSetPinVal(LCD_CTRL_PORT , LCD_RS_PIN , DIO_HIGH);
    52de:	82 e0       	ldi	r24, 0x02	; 2
    52e0:	60 e0       	ldi	r22, 0x00	; 0
    52e2:	41 e0       	ldi	r20, 0x01	; 1
    52e4:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <MDIO_vSetPinVal>

	// Set RW -> 0
	MDIO_vSetPinVal(LCD_CTRL_PORT , LCD_RW_PIN , DIO_LOW);
    52e8:	82 e0       	ldi	r24, 0x02	; 2
    52ea:	61 e0       	ldi	r22, 0x01	; 1
    52ec:	40 e0       	ldi	r20, 0x00	; 0
    52ee:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <MDIO_vSetPinVal>

	MDIO_vSetPortVal(LCD_DATA_PORT,Data);
    52f2:	83 e0       	ldi	r24, 0x03	; 3
    52f4:	6f 85       	ldd	r22, Y+15	; 0x0f
    52f6:	0e 94 46 28 	call	0x508c	; 0x508c <MDIO_vSetPortVal>

	MDIO_vSetPinVal(LCD_CTRL_PORT ,LCD_E_PIN , DIO_HIGH);
    52fa:	82 e0       	ldi	r24, 0x02	; 2
    52fc:	62 e0       	ldi	r22, 0x02	; 2
    52fe:	41 e0       	ldi	r20, 0x01	; 1
    5300:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <MDIO_vSetPinVal>
    5304:	80 e0       	ldi	r24, 0x00	; 0
    5306:	90 e0       	ldi	r25, 0x00	; 0
    5308:	a0 e8       	ldi	r26, 0x80	; 128
    530a:	bf e3       	ldi	r27, 0x3F	; 63
    530c:	8b 87       	std	Y+11, r24	; 0x0b
    530e:	9c 87       	std	Y+12, r25	; 0x0c
    5310:	ad 87       	std	Y+13, r26	; 0x0d
    5312:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5314:	6b 85       	ldd	r22, Y+11	; 0x0b
    5316:	7c 85       	ldd	r23, Y+12	; 0x0c
    5318:	8d 85       	ldd	r24, Y+13	; 0x0d
    531a:	9e 85       	ldd	r25, Y+14	; 0x0e
    531c:	20 e0       	ldi	r18, 0x00	; 0
    531e:	30 e0       	ldi	r19, 0x00	; 0
    5320:	4a ef       	ldi	r20, 0xFA	; 250
    5322:	54 e4       	ldi	r21, 0x44	; 68
    5324:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5328:	dc 01       	movw	r26, r24
    532a:	cb 01       	movw	r24, r22
    532c:	8f 83       	std	Y+7, r24	; 0x07
    532e:	98 87       	std	Y+8, r25	; 0x08
    5330:	a9 87       	std	Y+9, r26	; 0x09
    5332:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5334:	6f 81       	ldd	r22, Y+7	; 0x07
    5336:	78 85       	ldd	r23, Y+8	; 0x08
    5338:	89 85       	ldd	r24, Y+9	; 0x09
    533a:	9a 85       	ldd	r25, Y+10	; 0x0a
    533c:	20 e0       	ldi	r18, 0x00	; 0
    533e:	30 e0       	ldi	r19, 0x00	; 0
    5340:	40 e8       	ldi	r20, 0x80	; 128
    5342:	5f e3       	ldi	r21, 0x3F	; 63
    5344:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5348:	88 23       	and	r24, r24
    534a:	2c f4       	brge	.+10     	; 0x5356 <LCD_SendData+0x8e>
		__ticks = 1;
    534c:	81 e0       	ldi	r24, 0x01	; 1
    534e:	90 e0       	ldi	r25, 0x00	; 0
    5350:	9e 83       	std	Y+6, r25	; 0x06
    5352:	8d 83       	std	Y+5, r24	; 0x05
    5354:	3f c0       	rjmp	.+126    	; 0x53d4 <LCD_SendData+0x10c>
	else if (__tmp > 65535)
    5356:	6f 81       	ldd	r22, Y+7	; 0x07
    5358:	78 85       	ldd	r23, Y+8	; 0x08
    535a:	89 85       	ldd	r24, Y+9	; 0x09
    535c:	9a 85       	ldd	r25, Y+10	; 0x0a
    535e:	20 e0       	ldi	r18, 0x00	; 0
    5360:	3f ef       	ldi	r19, 0xFF	; 255
    5362:	4f e7       	ldi	r20, 0x7F	; 127
    5364:	57 e4       	ldi	r21, 0x47	; 71
    5366:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    536a:	18 16       	cp	r1, r24
    536c:	4c f5       	brge	.+82     	; 0x53c0 <LCD_SendData+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    536e:	6b 85       	ldd	r22, Y+11	; 0x0b
    5370:	7c 85       	ldd	r23, Y+12	; 0x0c
    5372:	8d 85       	ldd	r24, Y+13	; 0x0d
    5374:	9e 85       	ldd	r25, Y+14	; 0x0e
    5376:	20 e0       	ldi	r18, 0x00	; 0
    5378:	30 e0       	ldi	r19, 0x00	; 0
    537a:	40 e2       	ldi	r20, 0x20	; 32
    537c:	51 e4       	ldi	r21, 0x41	; 65
    537e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5382:	dc 01       	movw	r26, r24
    5384:	cb 01       	movw	r24, r22
    5386:	bc 01       	movw	r22, r24
    5388:	cd 01       	movw	r24, r26
    538a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    538e:	dc 01       	movw	r26, r24
    5390:	cb 01       	movw	r24, r22
    5392:	9e 83       	std	Y+6, r25	; 0x06
    5394:	8d 83       	std	Y+5, r24	; 0x05
    5396:	0f c0       	rjmp	.+30     	; 0x53b6 <LCD_SendData+0xee>
    5398:	88 ec       	ldi	r24, 0xC8	; 200
    539a:	90 e0       	ldi	r25, 0x00	; 0
    539c:	9c 83       	std	Y+4, r25	; 0x04
    539e:	8b 83       	std	Y+3, r24	; 0x03
    53a0:	8b 81       	ldd	r24, Y+3	; 0x03
    53a2:	9c 81       	ldd	r25, Y+4	; 0x04
    53a4:	01 97       	sbiw	r24, 0x01	; 1
    53a6:	f1 f7       	brne	.-4      	; 0x53a4 <LCD_SendData+0xdc>
    53a8:	9c 83       	std	Y+4, r25	; 0x04
    53aa:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    53ac:	8d 81       	ldd	r24, Y+5	; 0x05
    53ae:	9e 81       	ldd	r25, Y+6	; 0x06
    53b0:	01 97       	sbiw	r24, 0x01	; 1
    53b2:	9e 83       	std	Y+6, r25	; 0x06
    53b4:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    53b6:	8d 81       	ldd	r24, Y+5	; 0x05
    53b8:	9e 81       	ldd	r25, Y+6	; 0x06
    53ba:	00 97       	sbiw	r24, 0x00	; 0
    53bc:	69 f7       	brne	.-38     	; 0x5398 <LCD_SendData+0xd0>
    53be:	14 c0       	rjmp	.+40     	; 0x53e8 <LCD_SendData+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    53c0:	6f 81       	ldd	r22, Y+7	; 0x07
    53c2:	78 85       	ldd	r23, Y+8	; 0x08
    53c4:	89 85       	ldd	r24, Y+9	; 0x09
    53c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    53c8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    53cc:	dc 01       	movw	r26, r24
    53ce:	cb 01       	movw	r24, r22
    53d0:	9e 83       	std	Y+6, r25	; 0x06
    53d2:	8d 83       	std	Y+5, r24	; 0x05
    53d4:	8d 81       	ldd	r24, Y+5	; 0x05
    53d6:	9e 81       	ldd	r25, Y+6	; 0x06
    53d8:	9a 83       	std	Y+2, r25	; 0x02
    53da:	89 83       	std	Y+1, r24	; 0x01
    53dc:	89 81       	ldd	r24, Y+1	; 0x01
    53de:	9a 81       	ldd	r25, Y+2	; 0x02
    53e0:	01 97       	sbiw	r24, 0x01	; 1
    53e2:	f1 f7       	brne	.-4      	; 0x53e0 <LCD_SendData+0x118>
    53e4:	9a 83       	std	Y+2, r25	; 0x02
    53e6:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
	MDIO_vSetPinVal(LCD_CTRL_PORT ,LCD_E_PIN , DIO_LOW);
    53e8:	82 e0       	ldi	r24, 0x02	; 2
    53ea:	62 e0       	ldi	r22, 0x02	; 2
    53ec:	40 e0       	ldi	r20, 0x00	; 0
    53ee:	0e 94 d9 25 	call	0x4bb2	; 0x4bb2 <MDIO_vSetPinVal>
}
    53f2:	2f 96       	adiw	r28, 0x0f	; 15
    53f4:	0f b6       	in	r0, 0x3f	; 63
    53f6:	f8 94       	cli
    53f8:	de bf       	out	0x3e, r29	; 62
    53fa:	0f be       	out	0x3f, r0	; 63
    53fc:	cd bf       	out	0x3d, r28	; 61
    53fe:	cf 91       	pop	r28
    5400:	df 91       	pop	r29
    5402:	08 95       	ret

00005404 <LCD_Init>:

void LCD_Init(void)
{
    5404:	0f 93       	push	r16
    5406:	1f 93       	push	r17
    5408:	df 93       	push	r29
    540a:	cf 93       	push	r28
    540c:	cd b7       	in	r28, 0x3d	; 61
    540e:	de b7       	in	r29, 0x3e	; 62
    5410:	c6 54       	subi	r28, 0x46	; 70
    5412:	d0 40       	sbci	r29, 0x00	; 0
    5414:	0f b6       	in	r0, 0x3f	; 63
    5416:	f8 94       	cli
    5418:	de bf       	out	0x3e, r29	; 62
    541a:	0f be       	out	0x3f, r0	; 63
    541c:	cd bf       	out	0x3d, r28	; 61
    541e:	fe 01       	movw	r30, r28
    5420:	ed 5b       	subi	r30, 0xBD	; 189
    5422:	ff 4f       	sbci	r31, 0xFF	; 255
    5424:	80 e0       	ldi	r24, 0x00	; 0
    5426:	90 e0       	ldi	r25, 0x00	; 0
    5428:	a0 e2       	ldi	r26, 0x20	; 32
    542a:	b2 e4       	ldi	r27, 0x42	; 66
    542c:	80 83       	st	Z, r24
    542e:	91 83       	std	Z+1, r25	; 0x01
    5430:	a2 83       	std	Z+2, r26	; 0x02
    5432:	b3 83       	std	Z+3, r27	; 0x03
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5434:	8e 01       	movw	r16, r28
    5436:	01 5c       	subi	r16, 0xC1	; 193
    5438:	1f 4f       	sbci	r17, 0xFF	; 255
    543a:	fe 01       	movw	r30, r28
    543c:	ed 5b       	subi	r30, 0xBD	; 189
    543e:	ff 4f       	sbci	r31, 0xFF	; 255
    5440:	60 81       	ld	r22, Z
    5442:	71 81       	ldd	r23, Z+1	; 0x01
    5444:	82 81       	ldd	r24, Z+2	; 0x02
    5446:	93 81       	ldd	r25, Z+3	; 0x03
    5448:	20 e0       	ldi	r18, 0x00	; 0
    544a:	30 e0       	ldi	r19, 0x00	; 0
    544c:	4a ef       	ldi	r20, 0xFA	; 250
    544e:	54 e4       	ldi	r21, 0x44	; 68
    5450:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5454:	dc 01       	movw	r26, r24
    5456:	cb 01       	movw	r24, r22
    5458:	f8 01       	movw	r30, r16
    545a:	80 83       	st	Z, r24
    545c:	91 83       	std	Z+1, r25	; 0x01
    545e:	a2 83       	std	Z+2, r26	; 0x02
    5460:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    5462:	fe 01       	movw	r30, r28
    5464:	ff 96       	adiw	r30, 0x3f	; 63
    5466:	60 81       	ld	r22, Z
    5468:	71 81       	ldd	r23, Z+1	; 0x01
    546a:	82 81       	ldd	r24, Z+2	; 0x02
    546c:	93 81       	ldd	r25, Z+3	; 0x03
    546e:	20 e0       	ldi	r18, 0x00	; 0
    5470:	30 e0       	ldi	r19, 0x00	; 0
    5472:	40 e8       	ldi	r20, 0x80	; 128
    5474:	5f e3       	ldi	r21, 0x3F	; 63
    5476:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    547a:	88 23       	and	r24, r24
    547c:	2c f4       	brge	.+10     	; 0x5488 <LCD_Init+0x84>
		__ticks = 1;
    547e:	81 e0       	ldi	r24, 0x01	; 1
    5480:	90 e0       	ldi	r25, 0x00	; 0
    5482:	9e af       	std	Y+62, r25	; 0x3e
    5484:	8d af       	std	Y+61, r24	; 0x3d
    5486:	46 c0       	rjmp	.+140    	; 0x5514 <LCD_Init+0x110>
	else if (__tmp > 65535)
    5488:	fe 01       	movw	r30, r28
    548a:	ff 96       	adiw	r30, 0x3f	; 63
    548c:	60 81       	ld	r22, Z
    548e:	71 81       	ldd	r23, Z+1	; 0x01
    5490:	82 81       	ldd	r24, Z+2	; 0x02
    5492:	93 81       	ldd	r25, Z+3	; 0x03
    5494:	20 e0       	ldi	r18, 0x00	; 0
    5496:	3f ef       	ldi	r19, 0xFF	; 255
    5498:	4f e7       	ldi	r20, 0x7F	; 127
    549a:	57 e4       	ldi	r21, 0x47	; 71
    549c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    54a0:	18 16       	cp	r1, r24
    54a2:	64 f5       	brge	.+88     	; 0x54fc <LCD_Init+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    54a4:	fe 01       	movw	r30, r28
    54a6:	ed 5b       	subi	r30, 0xBD	; 189
    54a8:	ff 4f       	sbci	r31, 0xFF	; 255
    54aa:	60 81       	ld	r22, Z
    54ac:	71 81       	ldd	r23, Z+1	; 0x01
    54ae:	82 81       	ldd	r24, Z+2	; 0x02
    54b0:	93 81       	ldd	r25, Z+3	; 0x03
    54b2:	20 e0       	ldi	r18, 0x00	; 0
    54b4:	30 e0       	ldi	r19, 0x00	; 0
    54b6:	40 e2       	ldi	r20, 0x20	; 32
    54b8:	51 e4       	ldi	r21, 0x41	; 65
    54ba:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    54be:	dc 01       	movw	r26, r24
    54c0:	cb 01       	movw	r24, r22
    54c2:	bc 01       	movw	r22, r24
    54c4:	cd 01       	movw	r24, r26
    54c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    54ca:	dc 01       	movw	r26, r24
    54cc:	cb 01       	movw	r24, r22
    54ce:	9e af       	std	Y+62, r25	; 0x3e
    54d0:	8d af       	std	Y+61, r24	; 0x3d
    54d2:	0f c0       	rjmp	.+30     	; 0x54f2 <LCD_Init+0xee>
    54d4:	88 ec       	ldi	r24, 0xC8	; 200
    54d6:	90 e0       	ldi	r25, 0x00	; 0
    54d8:	9c af       	std	Y+60, r25	; 0x3c
    54da:	8b af       	std	Y+59, r24	; 0x3b
    54dc:	8b ad       	ldd	r24, Y+59	; 0x3b
    54de:	9c ad       	ldd	r25, Y+60	; 0x3c
    54e0:	01 97       	sbiw	r24, 0x01	; 1
    54e2:	f1 f7       	brne	.-4      	; 0x54e0 <LCD_Init+0xdc>
    54e4:	9c af       	std	Y+60, r25	; 0x3c
    54e6:	8b af       	std	Y+59, r24	; 0x3b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    54e8:	8d ad       	ldd	r24, Y+61	; 0x3d
    54ea:	9e ad       	ldd	r25, Y+62	; 0x3e
    54ec:	01 97       	sbiw	r24, 0x01	; 1
    54ee:	9e af       	std	Y+62, r25	; 0x3e
    54f0:	8d af       	std	Y+61, r24	; 0x3d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    54f2:	8d ad       	ldd	r24, Y+61	; 0x3d
    54f4:	9e ad       	ldd	r25, Y+62	; 0x3e
    54f6:	00 97       	sbiw	r24, 0x00	; 0
    54f8:	69 f7       	brne	.-38     	; 0x54d4 <LCD_Init+0xd0>
    54fa:	16 c0       	rjmp	.+44     	; 0x5528 <LCD_Init+0x124>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    54fc:	fe 01       	movw	r30, r28
    54fe:	ff 96       	adiw	r30, 0x3f	; 63
    5500:	60 81       	ld	r22, Z
    5502:	71 81       	ldd	r23, Z+1	; 0x01
    5504:	82 81       	ldd	r24, Z+2	; 0x02
    5506:	93 81       	ldd	r25, Z+3	; 0x03
    5508:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    550c:	dc 01       	movw	r26, r24
    550e:	cb 01       	movw	r24, r22
    5510:	9e af       	std	Y+62, r25	; 0x3e
    5512:	8d af       	std	Y+61, r24	; 0x3d
    5514:	8d ad       	ldd	r24, Y+61	; 0x3d
    5516:	9e ad       	ldd	r25, Y+62	; 0x3e
    5518:	9a af       	std	Y+58, r25	; 0x3a
    551a:	89 af       	std	Y+57, r24	; 0x39
    551c:	89 ad       	ldd	r24, Y+57	; 0x39
    551e:	9a ad       	ldd	r25, Y+58	; 0x3a
    5520:	01 97       	sbiw	r24, 0x01	; 1
    5522:	f1 f7       	brne	.-4      	; 0x5520 <LCD_Init+0x11c>
    5524:	9a af       	std	Y+58, r25	; 0x3a
    5526:	89 af       	std	Y+57, r24	; 0x39
	_delay_ms(40);

	LCD_SendCommand(0b00111000);
    5528:	88 e3       	ldi	r24, 0x38	; 56
    552a:	0e 94 c6 28 	call	0x518c	; 0x518c <LCD_SendCommand>
    552e:	80 e0       	ldi	r24, 0x00	; 0
    5530:	90 e0       	ldi	r25, 0x00	; 0
    5532:	a0 e8       	ldi	r26, 0x80	; 128
    5534:	bf e3       	ldi	r27, 0x3F	; 63
    5536:	8d ab       	std	Y+53, r24	; 0x35
    5538:	9e ab       	std	Y+54, r25	; 0x36
    553a:	af ab       	std	Y+55, r26	; 0x37
    553c:	b8 af       	std	Y+56, r27	; 0x38
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    553e:	6d a9       	ldd	r22, Y+53	; 0x35
    5540:	7e a9       	ldd	r23, Y+54	; 0x36
    5542:	8f a9       	ldd	r24, Y+55	; 0x37
    5544:	98 ad       	ldd	r25, Y+56	; 0x38
    5546:	20 e0       	ldi	r18, 0x00	; 0
    5548:	30 e0       	ldi	r19, 0x00	; 0
    554a:	4a ef       	ldi	r20, 0xFA	; 250
    554c:	54 e4       	ldi	r21, 0x44	; 68
    554e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5552:	dc 01       	movw	r26, r24
    5554:	cb 01       	movw	r24, r22
    5556:	89 ab       	std	Y+49, r24	; 0x31
    5558:	9a ab       	std	Y+50, r25	; 0x32
    555a:	ab ab       	std	Y+51, r26	; 0x33
    555c:	bc ab       	std	Y+52, r27	; 0x34
	if (__tmp < 1.0)
    555e:	69 a9       	ldd	r22, Y+49	; 0x31
    5560:	7a a9       	ldd	r23, Y+50	; 0x32
    5562:	8b a9       	ldd	r24, Y+51	; 0x33
    5564:	9c a9       	ldd	r25, Y+52	; 0x34
    5566:	20 e0       	ldi	r18, 0x00	; 0
    5568:	30 e0       	ldi	r19, 0x00	; 0
    556a:	40 e8       	ldi	r20, 0x80	; 128
    556c:	5f e3       	ldi	r21, 0x3F	; 63
    556e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5572:	88 23       	and	r24, r24
    5574:	2c f4       	brge	.+10     	; 0x5580 <LCD_Init+0x17c>
		__ticks = 1;
    5576:	81 e0       	ldi	r24, 0x01	; 1
    5578:	90 e0       	ldi	r25, 0x00	; 0
    557a:	98 ab       	std	Y+48, r25	; 0x30
    557c:	8f a7       	std	Y+47, r24	; 0x2f
    557e:	3f c0       	rjmp	.+126    	; 0x55fe <LCD_Init+0x1fa>
	else if (__tmp > 65535)
    5580:	69 a9       	ldd	r22, Y+49	; 0x31
    5582:	7a a9       	ldd	r23, Y+50	; 0x32
    5584:	8b a9       	ldd	r24, Y+51	; 0x33
    5586:	9c a9       	ldd	r25, Y+52	; 0x34
    5588:	20 e0       	ldi	r18, 0x00	; 0
    558a:	3f ef       	ldi	r19, 0xFF	; 255
    558c:	4f e7       	ldi	r20, 0x7F	; 127
    558e:	57 e4       	ldi	r21, 0x47	; 71
    5590:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    5594:	18 16       	cp	r1, r24
    5596:	4c f5       	brge	.+82     	; 0x55ea <LCD_Init+0x1e6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5598:	6d a9       	ldd	r22, Y+53	; 0x35
    559a:	7e a9       	ldd	r23, Y+54	; 0x36
    559c:	8f a9       	ldd	r24, Y+55	; 0x37
    559e:	98 ad       	ldd	r25, Y+56	; 0x38
    55a0:	20 e0       	ldi	r18, 0x00	; 0
    55a2:	30 e0       	ldi	r19, 0x00	; 0
    55a4:	40 e2       	ldi	r20, 0x20	; 32
    55a6:	51 e4       	ldi	r21, 0x41	; 65
    55a8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    55ac:	dc 01       	movw	r26, r24
    55ae:	cb 01       	movw	r24, r22
    55b0:	bc 01       	movw	r22, r24
    55b2:	cd 01       	movw	r24, r26
    55b4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    55b8:	dc 01       	movw	r26, r24
    55ba:	cb 01       	movw	r24, r22
    55bc:	98 ab       	std	Y+48, r25	; 0x30
    55be:	8f a7       	std	Y+47, r24	; 0x2f
    55c0:	0f c0       	rjmp	.+30     	; 0x55e0 <LCD_Init+0x1dc>
    55c2:	88 ec       	ldi	r24, 0xC8	; 200
    55c4:	90 e0       	ldi	r25, 0x00	; 0
    55c6:	9e a7       	std	Y+46, r25	; 0x2e
    55c8:	8d a7       	std	Y+45, r24	; 0x2d
    55ca:	8d a5       	ldd	r24, Y+45	; 0x2d
    55cc:	9e a5       	ldd	r25, Y+46	; 0x2e
    55ce:	01 97       	sbiw	r24, 0x01	; 1
    55d0:	f1 f7       	brne	.-4      	; 0x55ce <LCD_Init+0x1ca>
    55d2:	9e a7       	std	Y+46, r25	; 0x2e
    55d4:	8d a7       	std	Y+45, r24	; 0x2d
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    55d6:	8f a5       	ldd	r24, Y+47	; 0x2f
    55d8:	98 a9       	ldd	r25, Y+48	; 0x30
    55da:	01 97       	sbiw	r24, 0x01	; 1
    55dc:	98 ab       	std	Y+48, r25	; 0x30
    55de:	8f a7       	std	Y+47, r24	; 0x2f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    55e0:	8f a5       	ldd	r24, Y+47	; 0x2f
    55e2:	98 a9       	ldd	r25, Y+48	; 0x30
    55e4:	00 97       	sbiw	r24, 0x00	; 0
    55e6:	69 f7       	brne	.-38     	; 0x55c2 <LCD_Init+0x1be>
    55e8:	14 c0       	rjmp	.+40     	; 0x5612 <LCD_Init+0x20e>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    55ea:	69 a9       	ldd	r22, Y+49	; 0x31
    55ec:	7a a9       	ldd	r23, Y+50	; 0x32
    55ee:	8b a9       	ldd	r24, Y+51	; 0x33
    55f0:	9c a9       	ldd	r25, Y+52	; 0x34
    55f2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    55f6:	dc 01       	movw	r26, r24
    55f8:	cb 01       	movw	r24, r22
    55fa:	98 ab       	std	Y+48, r25	; 0x30
    55fc:	8f a7       	std	Y+47, r24	; 0x2f
    55fe:	8f a5       	ldd	r24, Y+47	; 0x2f
    5600:	98 a9       	ldd	r25, Y+48	; 0x30
    5602:	9c a7       	std	Y+44, r25	; 0x2c
    5604:	8b a7       	std	Y+43, r24	; 0x2b
    5606:	8b a5       	ldd	r24, Y+43	; 0x2b
    5608:	9c a5       	ldd	r25, Y+44	; 0x2c
    560a:	01 97       	sbiw	r24, 0x01	; 1
    560c:	f1 f7       	brne	.-4      	; 0x560a <LCD_Init+0x206>
    560e:	9c a7       	std	Y+44, r25	; 0x2c
    5610:	8b a7       	std	Y+43, r24	; 0x2b
	_delay_ms(1);

	LCD_SendCommand(0b00001100);
    5612:	8c e0       	ldi	r24, 0x0C	; 12
    5614:	0e 94 c6 28 	call	0x518c	; 0x518c <LCD_SendCommand>
    5618:	80 e0       	ldi	r24, 0x00	; 0
    561a:	90 e0       	ldi	r25, 0x00	; 0
    561c:	a0 e8       	ldi	r26, 0x80	; 128
    561e:	bf e3       	ldi	r27, 0x3F	; 63
    5620:	8f a3       	std	Y+39, r24	; 0x27
    5622:	98 a7       	std	Y+40, r25	; 0x28
    5624:	a9 a7       	std	Y+41, r26	; 0x29
    5626:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5628:	6f a1       	ldd	r22, Y+39	; 0x27
    562a:	78 a5       	ldd	r23, Y+40	; 0x28
    562c:	89 a5       	ldd	r24, Y+41	; 0x29
    562e:	9a a5       	ldd	r25, Y+42	; 0x2a
    5630:	20 e0       	ldi	r18, 0x00	; 0
    5632:	30 e0       	ldi	r19, 0x00	; 0
    5634:	4a ef       	ldi	r20, 0xFA	; 250
    5636:	54 e4       	ldi	r21, 0x44	; 68
    5638:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    563c:	dc 01       	movw	r26, r24
    563e:	cb 01       	movw	r24, r22
    5640:	8b a3       	std	Y+35, r24	; 0x23
    5642:	9c a3       	std	Y+36, r25	; 0x24
    5644:	ad a3       	std	Y+37, r26	; 0x25
    5646:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    5648:	6b a1       	ldd	r22, Y+35	; 0x23
    564a:	7c a1       	ldd	r23, Y+36	; 0x24
    564c:	8d a1       	ldd	r24, Y+37	; 0x25
    564e:	9e a1       	ldd	r25, Y+38	; 0x26
    5650:	20 e0       	ldi	r18, 0x00	; 0
    5652:	30 e0       	ldi	r19, 0x00	; 0
    5654:	40 e8       	ldi	r20, 0x80	; 128
    5656:	5f e3       	ldi	r21, 0x3F	; 63
    5658:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    565c:	88 23       	and	r24, r24
    565e:	2c f4       	brge	.+10     	; 0x566a <LCD_Init+0x266>
		__ticks = 1;
    5660:	81 e0       	ldi	r24, 0x01	; 1
    5662:	90 e0       	ldi	r25, 0x00	; 0
    5664:	9a a3       	std	Y+34, r25	; 0x22
    5666:	89 a3       	std	Y+33, r24	; 0x21
    5668:	3f c0       	rjmp	.+126    	; 0x56e8 <LCD_Init+0x2e4>
	else if (__tmp > 65535)
    566a:	6b a1       	ldd	r22, Y+35	; 0x23
    566c:	7c a1       	ldd	r23, Y+36	; 0x24
    566e:	8d a1       	ldd	r24, Y+37	; 0x25
    5670:	9e a1       	ldd	r25, Y+38	; 0x26
    5672:	20 e0       	ldi	r18, 0x00	; 0
    5674:	3f ef       	ldi	r19, 0xFF	; 255
    5676:	4f e7       	ldi	r20, 0x7F	; 127
    5678:	57 e4       	ldi	r21, 0x47	; 71
    567a:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    567e:	18 16       	cp	r1, r24
    5680:	4c f5       	brge	.+82     	; 0x56d4 <LCD_Init+0x2d0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5682:	6f a1       	ldd	r22, Y+39	; 0x27
    5684:	78 a5       	ldd	r23, Y+40	; 0x28
    5686:	89 a5       	ldd	r24, Y+41	; 0x29
    5688:	9a a5       	ldd	r25, Y+42	; 0x2a
    568a:	20 e0       	ldi	r18, 0x00	; 0
    568c:	30 e0       	ldi	r19, 0x00	; 0
    568e:	40 e2       	ldi	r20, 0x20	; 32
    5690:	51 e4       	ldi	r21, 0x41	; 65
    5692:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5696:	dc 01       	movw	r26, r24
    5698:	cb 01       	movw	r24, r22
    569a:	bc 01       	movw	r22, r24
    569c:	cd 01       	movw	r24, r26
    569e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    56a2:	dc 01       	movw	r26, r24
    56a4:	cb 01       	movw	r24, r22
    56a6:	9a a3       	std	Y+34, r25	; 0x22
    56a8:	89 a3       	std	Y+33, r24	; 0x21
    56aa:	0f c0       	rjmp	.+30     	; 0x56ca <LCD_Init+0x2c6>
    56ac:	88 ec       	ldi	r24, 0xC8	; 200
    56ae:	90 e0       	ldi	r25, 0x00	; 0
    56b0:	98 a3       	std	Y+32, r25	; 0x20
    56b2:	8f 8f       	std	Y+31, r24	; 0x1f
    56b4:	8f 8d       	ldd	r24, Y+31	; 0x1f
    56b6:	98 a1       	ldd	r25, Y+32	; 0x20
    56b8:	01 97       	sbiw	r24, 0x01	; 1
    56ba:	f1 f7       	brne	.-4      	; 0x56b8 <LCD_Init+0x2b4>
    56bc:	98 a3       	std	Y+32, r25	; 0x20
    56be:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    56c0:	89 a1       	ldd	r24, Y+33	; 0x21
    56c2:	9a a1       	ldd	r25, Y+34	; 0x22
    56c4:	01 97       	sbiw	r24, 0x01	; 1
    56c6:	9a a3       	std	Y+34, r25	; 0x22
    56c8:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    56ca:	89 a1       	ldd	r24, Y+33	; 0x21
    56cc:	9a a1       	ldd	r25, Y+34	; 0x22
    56ce:	00 97       	sbiw	r24, 0x00	; 0
    56d0:	69 f7       	brne	.-38     	; 0x56ac <LCD_Init+0x2a8>
    56d2:	14 c0       	rjmp	.+40     	; 0x56fc <LCD_Init+0x2f8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    56d4:	6b a1       	ldd	r22, Y+35	; 0x23
    56d6:	7c a1       	ldd	r23, Y+36	; 0x24
    56d8:	8d a1       	ldd	r24, Y+37	; 0x25
    56da:	9e a1       	ldd	r25, Y+38	; 0x26
    56dc:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    56e0:	dc 01       	movw	r26, r24
    56e2:	cb 01       	movw	r24, r22
    56e4:	9a a3       	std	Y+34, r25	; 0x22
    56e6:	89 a3       	std	Y+33, r24	; 0x21
    56e8:	89 a1       	ldd	r24, Y+33	; 0x21
    56ea:	9a a1       	ldd	r25, Y+34	; 0x22
    56ec:	9e 8f       	std	Y+30, r25	; 0x1e
    56ee:	8d 8f       	std	Y+29, r24	; 0x1d
    56f0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    56f2:	9e 8d       	ldd	r25, Y+30	; 0x1e
    56f4:	01 97       	sbiw	r24, 0x01	; 1
    56f6:	f1 f7       	brne	.-4      	; 0x56f4 <LCD_Init+0x2f0>
    56f8:	9e 8f       	std	Y+30, r25	; 0x1e
    56fa:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(1);

	LCD_SendCommand(0b00000001);
    56fc:	81 e0       	ldi	r24, 0x01	; 1
    56fe:	0e 94 c6 28 	call	0x518c	; 0x518c <LCD_SendCommand>
    5702:	80 e0       	ldi	r24, 0x00	; 0
    5704:	90 e0       	ldi	r25, 0x00	; 0
    5706:	a0 e0       	ldi	r26, 0x00	; 0
    5708:	b0 e4       	ldi	r27, 0x40	; 64
    570a:	89 8f       	std	Y+25, r24	; 0x19
    570c:	9a 8f       	std	Y+26, r25	; 0x1a
    570e:	ab 8f       	std	Y+27, r26	; 0x1b
    5710:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5712:	69 8d       	ldd	r22, Y+25	; 0x19
    5714:	7a 8d       	ldd	r23, Y+26	; 0x1a
    5716:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5718:	9c 8d       	ldd	r25, Y+28	; 0x1c
    571a:	20 e0       	ldi	r18, 0x00	; 0
    571c:	30 e0       	ldi	r19, 0x00	; 0
    571e:	4a ef       	ldi	r20, 0xFA	; 250
    5720:	54 e4       	ldi	r21, 0x44	; 68
    5722:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5726:	dc 01       	movw	r26, r24
    5728:	cb 01       	movw	r24, r22
    572a:	8d 8b       	std	Y+21, r24	; 0x15
    572c:	9e 8b       	std	Y+22, r25	; 0x16
    572e:	af 8b       	std	Y+23, r26	; 0x17
    5730:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    5732:	6d 89       	ldd	r22, Y+21	; 0x15
    5734:	7e 89       	ldd	r23, Y+22	; 0x16
    5736:	8f 89       	ldd	r24, Y+23	; 0x17
    5738:	98 8d       	ldd	r25, Y+24	; 0x18
    573a:	20 e0       	ldi	r18, 0x00	; 0
    573c:	30 e0       	ldi	r19, 0x00	; 0
    573e:	40 e8       	ldi	r20, 0x80	; 128
    5740:	5f e3       	ldi	r21, 0x3F	; 63
    5742:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5746:	88 23       	and	r24, r24
    5748:	2c f4       	brge	.+10     	; 0x5754 <LCD_Init+0x350>
		__ticks = 1;
    574a:	81 e0       	ldi	r24, 0x01	; 1
    574c:	90 e0       	ldi	r25, 0x00	; 0
    574e:	9c 8b       	std	Y+20, r25	; 0x14
    5750:	8b 8b       	std	Y+19, r24	; 0x13
    5752:	3f c0       	rjmp	.+126    	; 0x57d2 <LCD_Init+0x3ce>
	else if (__tmp > 65535)
    5754:	6d 89       	ldd	r22, Y+21	; 0x15
    5756:	7e 89       	ldd	r23, Y+22	; 0x16
    5758:	8f 89       	ldd	r24, Y+23	; 0x17
    575a:	98 8d       	ldd	r25, Y+24	; 0x18
    575c:	20 e0       	ldi	r18, 0x00	; 0
    575e:	3f ef       	ldi	r19, 0xFF	; 255
    5760:	4f e7       	ldi	r20, 0x7F	; 127
    5762:	57 e4       	ldi	r21, 0x47	; 71
    5764:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    5768:	18 16       	cp	r1, r24
    576a:	4c f5       	brge	.+82     	; 0x57be <LCD_Init+0x3ba>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    576c:	69 8d       	ldd	r22, Y+25	; 0x19
    576e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    5770:	8b 8d       	ldd	r24, Y+27	; 0x1b
    5772:	9c 8d       	ldd	r25, Y+28	; 0x1c
    5774:	20 e0       	ldi	r18, 0x00	; 0
    5776:	30 e0       	ldi	r19, 0x00	; 0
    5778:	40 e2       	ldi	r20, 0x20	; 32
    577a:	51 e4       	ldi	r21, 0x41	; 65
    577c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5780:	dc 01       	movw	r26, r24
    5782:	cb 01       	movw	r24, r22
    5784:	bc 01       	movw	r22, r24
    5786:	cd 01       	movw	r24, r26
    5788:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    578c:	dc 01       	movw	r26, r24
    578e:	cb 01       	movw	r24, r22
    5790:	9c 8b       	std	Y+20, r25	; 0x14
    5792:	8b 8b       	std	Y+19, r24	; 0x13
    5794:	0f c0       	rjmp	.+30     	; 0x57b4 <LCD_Init+0x3b0>
    5796:	88 ec       	ldi	r24, 0xC8	; 200
    5798:	90 e0       	ldi	r25, 0x00	; 0
    579a:	9a 8b       	std	Y+18, r25	; 0x12
    579c:	89 8b       	std	Y+17, r24	; 0x11
    579e:	89 89       	ldd	r24, Y+17	; 0x11
    57a0:	9a 89       	ldd	r25, Y+18	; 0x12
    57a2:	01 97       	sbiw	r24, 0x01	; 1
    57a4:	f1 f7       	brne	.-4      	; 0x57a2 <LCD_Init+0x39e>
    57a6:	9a 8b       	std	Y+18, r25	; 0x12
    57a8:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    57aa:	8b 89       	ldd	r24, Y+19	; 0x13
    57ac:	9c 89       	ldd	r25, Y+20	; 0x14
    57ae:	01 97       	sbiw	r24, 0x01	; 1
    57b0:	9c 8b       	std	Y+20, r25	; 0x14
    57b2:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    57b4:	8b 89       	ldd	r24, Y+19	; 0x13
    57b6:	9c 89       	ldd	r25, Y+20	; 0x14
    57b8:	00 97       	sbiw	r24, 0x00	; 0
    57ba:	69 f7       	brne	.-38     	; 0x5796 <LCD_Init+0x392>
    57bc:	14 c0       	rjmp	.+40     	; 0x57e6 <LCD_Init+0x3e2>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    57be:	6d 89       	ldd	r22, Y+21	; 0x15
    57c0:	7e 89       	ldd	r23, Y+22	; 0x16
    57c2:	8f 89       	ldd	r24, Y+23	; 0x17
    57c4:	98 8d       	ldd	r25, Y+24	; 0x18
    57c6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    57ca:	dc 01       	movw	r26, r24
    57cc:	cb 01       	movw	r24, r22
    57ce:	9c 8b       	std	Y+20, r25	; 0x14
    57d0:	8b 8b       	std	Y+19, r24	; 0x13
    57d2:	8b 89       	ldd	r24, Y+19	; 0x13
    57d4:	9c 89       	ldd	r25, Y+20	; 0x14
    57d6:	98 8b       	std	Y+16, r25	; 0x10
    57d8:	8f 87       	std	Y+15, r24	; 0x0f
    57da:	8f 85       	ldd	r24, Y+15	; 0x0f
    57dc:	98 89       	ldd	r25, Y+16	; 0x10
    57de:	01 97       	sbiw	r24, 0x01	; 1
    57e0:	f1 f7       	brne	.-4      	; 0x57de <LCD_Init+0x3da>
    57e2:	98 8b       	std	Y+16, r25	; 0x10
    57e4:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_ms(2);

	LCD_SendCommand(0b00000110);
    57e6:	86 e0       	ldi	r24, 0x06	; 6
    57e8:	0e 94 c6 28 	call	0x518c	; 0x518c <LCD_SendCommand>
    57ec:	80 e0       	ldi	r24, 0x00	; 0
    57ee:	90 e0       	ldi	r25, 0x00	; 0
    57f0:	a0 e8       	ldi	r26, 0x80	; 128
    57f2:	bf e3       	ldi	r27, 0x3F	; 63
    57f4:	8b 87       	std	Y+11, r24	; 0x0b
    57f6:	9c 87       	std	Y+12, r25	; 0x0c
    57f8:	ad 87       	std	Y+13, r26	; 0x0d
    57fa:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    57fc:	6b 85       	ldd	r22, Y+11	; 0x0b
    57fe:	7c 85       	ldd	r23, Y+12	; 0x0c
    5800:	8d 85       	ldd	r24, Y+13	; 0x0d
    5802:	9e 85       	ldd	r25, Y+14	; 0x0e
    5804:	20 e0       	ldi	r18, 0x00	; 0
    5806:	30 e0       	ldi	r19, 0x00	; 0
    5808:	4a ef       	ldi	r20, 0xFA	; 250
    580a:	54 e4       	ldi	r21, 0x44	; 68
    580c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5810:	dc 01       	movw	r26, r24
    5812:	cb 01       	movw	r24, r22
    5814:	8f 83       	std	Y+7, r24	; 0x07
    5816:	98 87       	std	Y+8, r25	; 0x08
    5818:	a9 87       	std	Y+9, r26	; 0x09
    581a:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    581c:	6f 81       	ldd	r22, Y+7	; 0x07
    581e:	78 85       	ldd	r23, Y+8	; 0x08
    5820:	89 85       	ldd	r24, Y+9	; 0x09
    5822:	9a 85       	ldd	r25, Y+10	; 0x0a
    5824:	20 e0       	ldi	r18, 0x00	; 0
    5826:	30 e0       	ldi	r19, 0x00	; 0
    5828:	40 e8       	ldi	r20, 0x80	; 128
    582a:	5f e3       	ldi	r21, 0x3F	; 63
    582c:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    5830:	88 23       	and	r24, r24
    5832:	2c f4       	brge	.+10     	; 0x583e <LCD_Init+0x43a>
		__ticks = 1;
    5834:	81 e0       	ldi	r24, 0x01	; 1
    5836:	90 e0       	ldi	r25, 0x00	; 0
    5838:	9e 83       	std	Y+6, r25	; 0x06
    583a:	8d 83       	std	Y+5, r24	; 0x05
    583c:	3f c0       	rjmp	.+126    	; 0x58bc <LCD_Init+0x4b8>
	else if (__tmp > 65535)
    583e:	6f 81       	ldd	r22, Y+7	; 0x07
    5840:	78 85       	ldd	r23, Y+8	; 0x08
    5842:	89 85       	ldd	r24, Y+9	; 0x09
    5844:	9a 85       	ldd	r25, Y+10	; 0x0a
    5846:	20 e0       	ldi	r18, 0x00	; 0
    5848:	3f ef       	ldi	r19, 0xFF	; 255
    584a:	4f e7       	ldi	r20, 0x7F	; 127
    584c:	57 e4       	ldi	r21, 0x47	; 71
    584e:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    5852:	18 16       	cp	r1, r24
    5854:	4c f5       	brge	.+82     	; 0x58a8 <LCD_Init+0x4a4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5856:	6b 85       	ldd	r22, Y+11	; 0x0b
    5858:	7c 85       	ldd	r23, Y+12	; 0x0c
    585a:	8d 85       	ldd	r24, Y+13	; 0x0d
    585c:	9e 85       	ldd	r25, Y+14	; 0x0e
    585e:	20 e0       	ldi	r18, 0x00	; 0
    5860:	30 e0       	ldi	r19, 0x00	; 0
    5862:	40 e2       	ldi	r20, 0x20	; 32
    5864:	51 e4       	ldi	r21, 0x41	; 65
    5866:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    586a:	dc 01       	movw	r26, r24
    586c:	cb 01       	movw	r24, r22
    586e:	bc 01       	movw	r22, r24
    5870:	cd 01       	movw	r24, r26
    5872:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5876:	dc 01       	movw	r26, r24
    5878:	cb 01       	movw	r24, r22
    587a:	9e 83       	std	Y+6, r25	; 0x06
    587c:	8d 83       	std	Y+5, r24	; 0x05
    587e:	0f c0       	rjmp	.+30     	; 0x589e <LCD_Init+0x49a>
    5880:	88 ec       	ldi	r24, 0xC8	; 200
    5882:	90 e0       	ldi	r25, 0x00	; 0
    5884:	9c 83       	std	Y+4, r25	; 0x04
    5886:	8b 83       	std	Y+3, r24	; 0x03
    5888:	8b 81       	ldd	r24, Y+3	; 0x03
    588a:	9c 81       	ldd	r25, Y+4	; 0x04
    588c:	01 97       	sbiw	r24, 0x01	; 1
    588e:	f1 f7       	brne	.-4      	; 0x588c <LCD_Init+0x488>
    5890:	9c 83       	std	Y+4, r25	; 0x04
    5892:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5894:	8d 81       	ldd	r24, Y+5	; 0x05
    5896:	9e 81       	ldd	r25, Y+6	; 0x06
    5898:	01 97       	sbiw	r24, 0x01	; 1
    589a:	9e 83       	std	Y+6, r25	; 0x06
    589c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    589e:	8d 81       	ldd	r24, Y+5	; 0x05
    58a0:	9e 81       	ldd	r25, Y+6	; 0x06
    58a2:	00 97       	sbiw	r24, 0x00	; 0
    58a4:	69 f7       	brne	.-38     	; 0x5880 <LCD_Init+0x47c>
    58a6:	14 c0       	rjmp	.+40     	; 0x58d0 <LCD_Init+0x4cc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    58a8:	6f 81       	ldd	r22, Y+7	; 0x07
    58aa:	78 85       	ldd	r23, Y+8	; 0x08
    58ac:	89 85       	ldd	r24, Y+9	; 0x09
    58ae:	9a 85       	ldd	r25, Y+10	; 0x0a
    58b0:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    58b4:	dc 01       	movw	r26, r24
    58b6:	cb 01       	movw	r24, r22
    58b8:	9e 83       	std	Y+6, r25	; 0x06
    58ba:	8d 83       	std	Y+5, r24	; 0x05
    58bc:	8d 81       	ldd	r24, Y+5	; 0x05
    58be:	9e 81       	ldd	r25, Y+6	; 0x06
    58c0:	9a 83       	std	Y+2, r25	; 0x02
    58c2:	89 83       	std	Y+1, r24	; 0x01
    58c4:	89 81       	ldd	r24, Y+1	; 0x01
    58c6:	9a 81       	ldd	r25, Y+2	; 0x02
    58c8:	01 97       	sbiw	r24, 0x01	; 1
    58ca:	f1 f7       	brne	.-4      	; 0x58c8 <LCD_Init+0x4c4>
    58cc:	9a 83       	std	Y+2, r25	; 0x02
    58ce:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1);
}
    58d0:	ca 5b       	subi	r28, 0xBA	; 186
    58d2:	df 4f       	sbci	r29, 0xFF	; 255
    58d4:	0f b6       	in	r0, 0x3f	; 63
    58d6:	f8 94       	cli
    58d8:	de bf       	out	0x3e, r29	; 62
    58da:	0f be       	out	0x3f, r0	; 63
    58dc:	cd bf       	out	0x3d, r28	; 61
    58de:	cf 91       	pop	r28
    58e0:	df 91       	pop	r29
    58e2:	1f 91       	pop	r17
    58e4:	0f 91       	pop	r16
    58e6:	08 95       	ret

000058e8 <LCD_SendString>:

void LCD_SendString(const u8 *String)
{
    58e8:	df 93       	push	r29
    58ea:	cf 93       	push	r28
    58ec:	00 d0       	rcall	.+0      	; 0x58ee <LCD_SendString+0x6>
    58ee:	0f 92       	push	r0
    58f0:	cd b7       	in	r28, 0x3d	; 61
    58f2:	de b7       	in	r29, 0x3e	; 62
    58f4:	9b 83       	std	Y+3, r25	; 0x03
    58f6:	8a 83       	std	Y+2, r24	; 0x02
	u8 Counter=0;
    58f8:	19 82       	std	Y+1, r1	; 0x01
    58fa:	0e c0       	rjmp	.+28     	; 0x5918 <LCD_SendString+0x30>
	while(String[Counter] != '\0')
	{
		LCD_SendData(String[Counter]);
    58fc:	89 81       	ldd	r24, Y+1	; 0x01
    58fe:	28 2f       	mov	r18, r24
    5900:	30 e0       	ldi	r19, 0x00	; 0
    5902:	8a 81       	ldd	r24, Y+2	; 0x02
    5904:	9b 81       	ldd	r25, Y+3	; 0x03
    5906:	fc 01       	movw	r30, r24
    5908:	e2 0f       	add	r30, r18
    590a:	f3 1f       	adc	r31, r19
    590c:	80 81       	ld	r24, Z
    590e:	0e 94 64 29 	call	0x52c8	; 0x52c8 <LCD_SendData>
		Counter++;
    5912:	89 81       	ldd	r24, Y+1	; 0x01
    5914:	8f 5f       	subi	r24, 0xFF	; 255
    5916:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_SendString(const u8 *String)
{
	u8 Counter=0;
	while(String[Counter] != '\0')
    5918:	89 81       	ldd	r24, Y+1	; 0x01
    591a:	28 2f       	mov	r18, r24
    591c:	30 e0       	ldi	r19, 0x00	; 0
    591e:	8a 81       	ldd	r24, Y+2	; 0x02
    5920:	9b 81       	ldd	r25, Y+3	; 0x03
    5922:	fc 01       	movw	r30, r24
    5924:	e2 0f       	add	r30, r18
    5926:	f3 1f       	adc	r31, r19
    5928:	80 81       	ld	r24, Z
    592a:	88 23       	and	r24, r24
    592c:	39 f7       	brne	.-50     	; 0x58fc <LCD_SendString+0x14>
	{
		LCD_SendData(String[Counter]);
		Counter++;
	}
}
    592e:	0f 90       	pop	r0
    5930:	0f 90       	pop	r0
    5932:	0f 90       	pop	r0
    5934:	cf 91       	pop	r28
    5936:	df 91       	pop	r29
    5938:	08 95       	ret

0000593a <LCD_GoToXY>:

void LCD_GoToXY(u8 Row , u8 Col)
{
    593a:	df 93       	push	r29
    593c:	cf 93       	push	r28
    593e:	00 d0       	rcall	.+0      	; 0x5940 <LCD_GoToXY+0x6>
    5940:	00 d0       	rcall	.+0      	; 0x5942 <LCD_GoToXY+0x8>
    5942:	0f 92       	push	r0
    5944:	cd b7       	in	r28, 0x3d	; 61
    5946:	de b7       	in	r29, 0x3e	; 62
    5948:	8a 83       	std	Y+2, r24	; 0x02
    594a:	6b 83       	std	Y+3, r22	; 0x03
	u8 Position;
	if(Row == 0 || Row == 1)
    594c:	8a 81       	ldd	r24, Y+2	; 0x02
    594e:	88 23       	and	r24, r24
    5950:	19 f0       	breq	.+6      	; 0x5958 <LCD_GoToXY+0x1e>
    5952:	8a 81       	ldd	r24, Y+2	; 0x02
    5954:	81 30       	cpi	r24, 0x01	; 1
    5956:	e1 f4       	brne	.+56     	; 0x5990 <LCD_GoToXY+0x56>
	{
		if(Col >= 0 && Col <= 15)
    5958:	8b 81       	ldd	r24, Y+3	; 0x03
    595a:	80 31       	cpi	r24, 0x10	; 16
    595c:	a8 f4       	brcc	.+42     	; 0x5988 <LCD_GoToXY+0x4e>
		{
			switch(Row)
    595e:	8a 81       	ldd	r24, Y+2	; 0x02
    5960:	28 2f       	mov	r18, r24
    5962:	30 e0       	ldi	r19, 0x00	; 0
    5964:	3d 83       	std	Y+5, r19	; 0x05
    5966:	2c 83       	std	Y+4, r18	; 0x04
    5968:	8c 81       	ldd	r24, Y+4	; 0x04
    596a:	9d 81       	ldd	r25, Y+5	; 0x05
    596c:	00 97       	sbiw	r24, 0x00	; 0
    596e:	31 f0       	breq	.+12     	; 0x597c <LCD_GoToXY+0x42>
    5970:	2c 81       	ldd	r18, Y+4	; 0x04
    5972:	3d 81       	ldd	r19, Y+5	; 0x05
    5974:	21 30       	cpi	r18, 0x01	; 1
    5976:	31 05       	cpc	r19, r1
    5978:	21 f0       	breq	.+8      	; 0x5982 <LCD_GoToXY+0x48>
    597a:	06 c0       	rjmp	.+12     	; 0x5988 <LCD_GoToXY+0x4e>
			{

			case 0:
				Position=0x00 + Col;
    597c:	8b 81       	ldd	r24, Y+3	; 0x03
    597e:	89 83       	std	Y+1, r24	; 0x01
    5980:	03 c0       	rjmp	.+6      	; 0x5988 <LCD_GoToXY+0x4e>
				break;
			case 1:
				Position=0x40 + Col;
    5982:	8b 81       	ldd	r24, Y+3	; 0x03
    5984:	80 5c       	subi	r24, 0xC0	; 192
    5986:	89 83       	std	Y+1, r24	; 0x01
				break;
			}
		}
		LCD_SendCommand(128+Position);
    5988:	89 81       	ldd	r24, Y+1	; 0x01
    598a:	80 58       	subi	r24, 0x80	; 128
    598c:	0e 94 c6 28 	call	0x518c	; 0x518c <LCD_SendCommand>
	}
}
    5990:	0f 90       	pop	r0
    5992:	0f 90       	pop	r0
    5994:	0f 90       	pop	r0
    5996:	0f 90       	pop	r0
    5998:	0f 90       	pop	r0
    599a:	cf 91       	pop	r28
    599c:	df 91       	pop	r29
    599e:	08 95       	ret

000059a0 <LCD_ClearDisplay>:

void LCD_ClearDisplay(void)
{
    59a0:	df 93       	push	r29
    59a2:	cf 93       	push	r28
    59a4:	cd b7       	in	r28, 0x3d	; 61
    59a6:	de b7       	in	r29, 0x3e	; 62
    59a8:	2e 97       	sbiw	r28, 0x0e	; 14
    59aa:	0f b6       	in	r0, 0x3f	; 63
    59ac:	f8 94       	cli
    59ae:	de bf       	out	0x3e, r29	; 62
    59b0:	0f be       	out	0x3f, r0	; 63
    59b2:	cd bf       	out	0x3d, r28	; 61
	LCD_SendCommand(1);
    59b4:	81 e0       	ldi	r24, 0x01	; 1
    59b6:	0e 94 c6 28 	call	0x518c	; 0x518c <LCD_SendCommand>
    59ba:	80 e0       	ldi	r24, 0x00	; 0
    59bc:	90 e0       	ldi	r25, 0x00	; 0
    59be:	a0 e0       	ldi	r26, 0x00	; 0
    59c0:	b0 e4       	ldi	r27, 0x40	; 64
    59c2:	8b 87       	std	Y+11, r24	; 0x0b
    59c4:	9c 87       	std	Y+12, r25	; 0x0c
    59c6:	ad 87       	std	Y+13, r26	; 0x0d
    59c8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    59ca:	6b 85       	ldd	r22, Y+11	; 0x0b
    59cc:	7c 85       	ldd	r23, Y+12	; 0x0c
    59ce:	8d 85       	ldd	r24, Y+13	; 0x0d
    59d0:	9e 85       	ldd	r25, Y+14	; 0x0e
    59d2:	20 e0       	ldi	r18, 0x00	; 0
    59d4:	30 e0       	ldi	r19, 0x00	; 0
    59d6:	4a ef       	ldi	r20, 0xFA	; 250
    59d8:	54 e4       	ldi	r21, 0x44	; 68
    59da:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    59de:	dc 01       	movw	r26, r24
    59e0:	cb 01       	movw	r24, r22
    59e2:	8f 83       	std	Y+7, r24	; 0x07
    59e4:	98 87       	std	Y+8, r25	; 0x08
    59e6:	a9 87       	std	Y+9, r26	; 0x09
    59e8:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    59ea:	6f 81       	ldd	r22, Y+7	; 0x07
    59ec:	78 85       	ldd	r23, Y+8	; 0x08
    59ee:	89 85       	ldd	r24, Y+9	; 0x09
    59f0:	9a 85       	ldd	r25, Y+10	; 0x0a
    59f2:	20 e0       	ldi	r18, 0x00	; 0
    59f4:	30 e0       	ldi	r19, 0x00	; 0
    59f6:	40 e8       	ldi	r20, 0x80	; 128
    59f8:	5f e3       	ldi	r21, 0x3F	; 63
    59fa:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    59fe:	88 23       	and	r24, r24
    5a00:	2c f4       	brge	.+10     	; 0x5a0c <LCD_ClearDisplay+0x6c>
		__ticks = 1;
    5a02:	81 e0       	ldi	r24, 0x01	; 1
    5a04:	90 e0       	ldi	r25, 0x00	; 0
    5a06:	9e 83       	std	Y+6, r25	; 0x06
    5a08:	8d 83       	std	Y+5, r24	; 0x05
    5a0a:	3f c0       	rjmp	.+126    	; 0x5a8a <LCD_ClearDisplay+0xea>
	else if (__tmp > 65535)
    5a0c:	6f 81       	ldd	r22, Y+7	; 0x07
    5a0e:	78 85       	ldd	r23, Y+8	; 0x08
    5a10:	89 85       	ldd	r24, Y+9	; 0x09
    5a12:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a14:	20 e0       	ldi	r18, 0x00	; 0
    5a16:	3f ef       	ldi	r19, 0xFF	; 255
    5a18:	4f e7       	ldi	r20, 0x7F	; 127
    5a1a:	57 e4       	ldi	r21, 0x47	; 71
    5a1c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    5a20:	18 16       	cp	r1, r24
    5a22:	4c f5       	brge	.+82     	; 0x5a76 <LCD_ClearDisplay+0xd6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5a24:	6b 85       	ldd	r22, Y+11	; 0x0b
    5a26:	7c 85       	ldd	r23, Y+12	; 0x0c
    5a28:	8d 85       	ldd	r24, Y+13	; 0x0d
    5a2a:	9e 85       	ldd	r25, Y+14	; 0x0e
    5a2c:	20 e0       	ldi	r18, 0x00	; 0
    5a2e:	30 e0       	ldi	r19, 0x00	; 0
    5a30:	40 e2       	ldi	r20, 0x20	; 32
    5a32:	51 e4       	ldi	r21, 0x41	; 65
    5a34:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5a38:	dc 01       	movw	r26, r24
    5a3a:	cb 01       	movw	r24, r22
    5a3c:	bc 01       	movw	r22, r24
    5a3e:	cd 01       	movw	r24, r26
    5a40:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5a44:	dc 01       	movw	r26, r24
    5a46:	cb 01       	movw	r24, r22
    5a48:	9e 83       	std	Y+6, r25	; 0x06
    5a4a:	8d 83       	std	Y+5, r24	; 0x05
    5a4c:	0f c0       	rjmp	.+30     	; 0x5a6c <LCD_ClearDisplay+0xcc>
    5a4e:	88 ec       	ldi	r24, 0xC8	; 200
    5a50:	90 e0       	ldi	r25, 0x00	; 0
    5a52:	9c 83       	std	Y+4, r25	; 0x04
    5a54:	8b 83       	std	Y+3, r24	; 0x03
    5a56:	8b 81       	ldd	r24, Y+3	; 0x03
    5a58:	9c 81       	ldd	r25, Y+4	; 0x04
    5a5a:	01 97       	sbiw	r24, 0x01	; 1
    5a5c:	f1 f7       	brne	.-4      	; 0x5a5a <LCD_ClearDisplay+0xba>
    5a5e:	9c 83       	std	Y+4, r25	; 0x04
    5a60:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5a62:	8d 81       	ldd	r24, Y+5	; 0x05
    5a64:	9e 81       	ldd	r25, Y+6	; 0x06
    5a66:	01 97       	sbiw	r24, 0x01	; 1
    5a68:	9e 83       	std	Y+6, r25	; 0x06
    5a6a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5a6c:	8d 81       	ldd	r24, Y+5	; 0x05
    5a6e:	9e 81       	ldd	r25, Y+6	; 0x06
    5a70:	00 97       	sbiw	r24, 0x00	; 0
    5a72:	69 f7       	brne	.-38     	; 0x5a4e <LCD_ClearDisplay+0xae>
    5a74:	14 c0       	rjmp	.+40     	; 0x5a9e <LCD_ClearDisplay+0xfe>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5a76:	6f 81       	ldd	r22, Y+7	; 0x07
    5a78:	78 85       	ldd	r23, Y+8	; 0x08
    5a7a:	89 85       	ldd	r24, Y+9	; 0x09
    5a7c:	9a 85       	ldd	r25, Y+10	; 0x0a
    5a7e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5a82:	dc 01       	movw	r26, r24
    5a84:	cb 01       	movw	r24, r22
    5a86:	9e 83       	std	Y+6, r25	; 0x06
    5a88:	8d 83       	std	Y+5, r24	; 0x05
    5a8a:	8d 81       	ldd	r24, Y+5	; 0x05
    5a8c:	9e 81       	ldd	r25, Y+6	; 0x06
    5a8e:	9a 83       	std	Y+2, r25	; 0x02
    5a90:	89 83       	std	Y+1, r24	; 0x01
    5a92:	89 81       	ldd	r24, Y+1	; 0x01
    5a94:	9a 81       	ldd	r25, Y+2	; 0x02
    5a96:	01 97       	sbiw	r24, 0x01	; 1
    5a98:	f1 f7       	brne	.-4      	; 0x5a96 <LCD_ClearDisplay+0xf6>
    5a9a:	9a 83       	std	Y+2, r25	; 0x02
    5a9c:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
}
    5a9e:	2e 96       	adiw	r28, 0x0e	; 14
    5aa0:	0f b6       	in	r0, 0x3f	; 63
    5aa2:	f8 94       	cli
    5aa4:	de bf       	out	0x3e, r29	; 62
    5aa6:	0f be       	out	0x3f, r0	; 63
    5aa8:	cd bf       	out	0x3d, r28	; 61
    5aaa:	cf 91       	pop	r28
    5aac:	df 91       	pop	r29
    5aae:	08 95       	ret

00005ab0 <LCD_DisplayNumber>:

void LCD_DisplayNumber(u32 Number)
{
    5ab0:	df 93       	push	r29
    5ab2:	cf 93       	push	r28
    5ab4:	00 d0       	rcall	.+0      	; 0x5ab6 <LCD_DisplayNumber+0x6>
    5ab6:	00 d0       	rcall	.+0      	; 0x5ab8 <LCD_DisplayNumber+0x8>
    5ab8:	cd b7       	in	r28, 0x3d	; 61
    5aba:	de b7       	in	r29, 0x3e	; 62
    5abc:	9c 83       	std	Y+4, r25	; 0x04
    5abe:	8b 83       	std	Y+3, r24	; 0x03
	u32 ReversedNum = 1;
    5ac0:	81 e0       	ldi	r24, 0x01	; 1
    5ac2:	90 e0       	ldi	r25, 0x00	; 0
    5ac4:	9a 83       	std	Y+2, r25	; 0x02
    5ac6:	89 83       	std	Y+1, r24	; 0x01
	if(Number == 0)
    5ac8:	8b 81       	ldd	r24, Y+3	; 0x03
    5aca:	9c 81       	ldd	r25, Y+4	; 0x04
    5acc:	00 97       	sbiw	r24, 0x00	; 0
    5ace:	31 f5       	brne	.+76     	; 0x5b1c <LCD_DisplayNumber+0x6c>
	{
		LCD_SendData('0');
    5ad0:	80 e3       	ldi	r24, 0x30	; 48
    5ad2:	0e 94 64 29 	call	0x52c8	; 0x52c8 <LCD_SendData>
    5ad6:	22 c0       	rjmp	.+68     	; 0x5b1c <LCD_DisplayNumber+0x6c>
	}

	while(Number != 0)
	{
		ReversedNum = (ReversedNum*10) + (Number %10);
    5ad8:	89 81       	ldd	r24, Y+1	; 0x01
    5ada:	9a 81       	ldd	r25, Y+2	; 0x02
    5adc:	9c 01       	movw	r18, r24
    5ade:	22 0f       	add	r18, r18
    5ae0:	33 1f       	adc	r19, r19
    5ae2:	c9 01       	movw	r24, r18
    5ae4:	88 0f       	add	r24, r24
    5ae6:	99 1f       	adc	r25, r25
    5ae8:	88 0f       	add	r24, r24
    5aea:	99 1f       	adc	r25, r25
    5aec:	f9 01       	movw	r30, r18
    5aee:	e8 0f       	add	r30, r24
    5af0:	f9 1f       	adc	r31, r25
    5af2:	8b 81       	ldd	r24, Y+3	; 0x03
    5af4:	9c 81       	ldd	r25, Y+4	; 0x04
    5af6:	2a e0       	ldi	r18, 0x0A	; 10
    5af8:	30 e0       	ldi	r19, 0x00	; 0
    5afa:	b9 01       	movw	r22, r18
    5afc:	0e 94 b3 2d 	call	0x5b66	; 0x5b66 <__udivmodhi4>
    5b00:	8e 0f       	add	r24, r30
    5b02:	9f 1f       	adc	r25, r31
    5b04:	9a 83       	std	Y+2, r25	; 0x02
    5b06:	89 83       	std	Y+1, r24	; 0x01
		Number = Number /10;
    5b08:	8b 81       	ldd	r24, Y+3	; 0x03
    5b0a:	9c 81       	ldd	r25, Y+4	; 0x04
    5b0c:	2a e0       	ldi	r18, 0x0A	; 10
    5b0e:	30 e0       	ldi	r19, 0x00	; 0
    5b10:	b9 01       	movw	r22, r18
    5b12:	0e 94 b3 2d 	call	0x5b66	; 0x5b66 <__udivmodhi4>
    5b16:	cb 01       	movw	r24, r22
    5b18:	9c 83       	std	Y+4, r25	; 0x04
    5b1a:	8b 83       	std	Y+3, r24	; 0x03
	if(Number == 0)
	{
		LCD_SendData('0');
	}

	while(Number != 0)
    5b1c:	8b 81       	ldd	r24, Y+3	; 0x03
    5b1e:	9c 81       	ldd	r25, Y+4	; 0x04
    5b20:	00 97       	sbiw	r24, 0x00	; 0
    5b22:	d1 f6       	brne	.-76     	; 0x5ad8 <LCD_DisplayNumber+0x28>
    5b24:	14 c0       	rjmp	.+40     	; 0x5b4e <LCD_DisplayNumber+0x9e>
		Number = Number /10;
	}

	while(ReversedNum != 1)
	{
		LCD_SendData( (ReversedNum%10) + 48);
    5b26:	89 81       	ldd	r24, Y+1	; 0x01
    5b28:	9a 81       	ldd	r25, Y+2	; 0x02
    5b2a:	2a e0       	ldi	r18, 0x0A	; 10
    5b2c:	30 e0       	ldi	r19, 0x00	; 0
    5b2e:	b9 01       	movw	r22, r18
    5b30:	0e 94 b3 2d 	call	0x5b66	; 0x5b66 <__udivmodhi4>
    5b34:	80 5d       	subi	r24, 0xD0	; 208
    5b36:	0e 94 64 29 	call	0x52c8	; 0x52c8 <LCD_SendData>
		ReversedNum= ReversedNum/10;
    5b3a:	89 81       	ldd	r24, Y+1	; 0x01
    5b3c:	9a 81       	ldd	r25, Y+2	; 0x02
    5b3e:	2a e0       	ldi	r18, 0x0A	; 10
    5b40:	30 e0       	ldi	r19, 0x00	; 0
    5b42:	b9 01       	movw	r22, r18
    5b44:	0e 94 b3 2d 	call	0x5b66	; 0x5b66 <__udivmodhi4>
    5b48:	cb 01       	movw	r24, r22
    5b4a:	9a 83       	std	Y+2, r25	; 0x02
    5b4c:	89 83       	std	Y+1, r24	; 0x01
	{
		ReversedNum = (ReversedNum*10) + (Number %10);
		Number = Number /10;
	}

	while(ReversedNum != 1)
    5b4e:	89 81       	ldd	r24, Y+1	; 0x01
    5b50:	9a 81       	ldd	r25, Y+2	; 0x02
    5b52:	81 30       	cpi	r24, 0x01	; 1
    5b54:	91 05       	cpc	r25, r1
    5b56:	39 f7       	brne	.-50     	; 0x5b26 <LCD_DisplayNumber+0x76>
	{
		LCD_SendData( (ReversedNum%10) + 48);
		ReversedNum= ReversedNum/10;
	}
}
    5b58:	0f 90       	pop	r0
    5b5a:	0f 90       	pop	r0
    5b5c:	0f 90       	pop	r0
    5b5e:	0f 90       	pop	r0
    5b60:	cf 91       	pop	r28
    5b62:	df 91       	pop	r29
    5b64:	08 95       	ret

00005b66 <__udivmodhi4>:
    5b66:	aa 1b       	sub	r26, r26
    5b68:	bb 1b       	sub	r27, r27
    5b6a:	51 e1       	ldi	r21, 0x11	; 17
    5b6c:	07 c0       	rjmp	.+14     	; 0x5b7c <__udivmodhi4_ep>

00005b6e <__udivmodhi4_loop>:
    5b6e:	aa 1f       	adc	r26, r26
    5b70:	bb 1f       	adc	r27, r27
    5b72:	a6 17       	cp	r26, r22
    5b74:	b7 07       	cpc	r27, r23
    5b76:	10 f0       	brcs	.+4      	; 0x5b7c <__udivmodhi4_ep>
    5b78:	a6 1b       	sub	r26, r22
    5b7a:	b7 0b       	sbc	r27, r23

00005b7c <__udivmodhi4_ep>:
    5b7c:	88 1f       	adc	r24, r24
    5b7e:	99 1f       	adc	r25, r25
    5b80:	5a 95       	dec	r21
    5b82:	a9 f7       	brne	.-22     	; 0x5b6e <__udivmodhi4_loop>
    5b84:	80 95       	com	r24
    5b86:	90 95       	com	r25
    5b88:	bc 01       	movw	r22, r24
    5b8a:	cd 01       	movw	r24, r26
    5b8c:	08 95       	ret

00005b8e <__prologue_saves__>:
    5b8e:	2f 92       	push	r2
    5b90:	3f 92       	push	r3
    5b92:	4f 92       	push	r4
    5b94:	5f 92       	push	r5
    5b96:	6f 92       	push	r6
    5b98:	7f 92       	push	r7
    5b9a:	8f 92       	push	r8
    5b9c:	9f 92       	push	r9
    5b9e:	af 92       	push	r10
    5ba0:	bf 92       	push	r11
    5ba2:	cf 92       	push	r12
    5ba4:	df 92       	push	r13
    5ba6:	ef 92       	push	r14
    5ba8:	ff 92       	push	r15
    5baa:	0f 93       	push	r16
    5bac:	1f 93       	push	r17
    5bae:	cf 93       	push	r28
    5bb0:	df 93       	push	r29
    5bb2:	cd b7       	in	r28, 0x3d	; 61
    5bb4:	de b7       	in	r29, 0x3e	; 62
    5bb6:	ca 1b       	sub	r28, r26
    5bb8:	db 0b       	sbc	r29, r27
    5bba:	0f b6       	in	r0, 0x3f	; 63
    5bbc:	f8 94       	cli
    5bbe:	de bf       	out	0x3e, r29	; 62
    5bc0:	0f be       	out	0x3f, r0	; 63
    5bc2:	cd bf       	out	0x3d, r28	; 61
    5bc4:	09 94       	ijmp

00005bc6 <__epilogue_restores__>:
    5bc6:	2a 88       	ldd	r2, Y+18	; 0x12
    5bc8:	39 88       	ldd	r3, Y+17	; 0x11
    5bca:	48 88       	ldd	r4, Y+16	; 0x10
    5bcc:	5f 84       	ldd	r5, Y+15	; 0x0f
    5bce:	6e 84       	ldd	r6, Y+14	; 0x0e
    5bd0:	7d 84       	ldd	r7, Y+13	; 0x0d
    5bd2:	8c 84       	ldd	r8, Y+12	; 0x0c
    5bd4:	9b 84       	ldd	r9, Y+11	; 0x0b
    5bd6:	aa 84       	ldd	r10, Y+10	; 0x0a
    5bd8:	b9 84       	ldd	r11, Y+9	; 0x09
    5bda:	c8 84       	ldd	r12, Y+8	; 0x08
    5bdc:	df 80       	ldd	r13, Y+7	; 0x07
    5bde:	ee 80       	ldd	r14, Y+6	; 0x06
    5be0:	fd 80       	ldd	r15, Y+5	; 0x05
    5be2:	0c 81       	ldd	r16, Y+4	; 0x04
    5be4:	1b 81       	ldd	r17, Y+3	; 0x03
    5be6:	aa 81       	ldd	r26, Y+2	; 0x02
    5be8:	b9 81       	ldd	r27, Y+1	; 0x01
    5bea:	ce 0f       	add	r28, r30
    5bec:	d1 1d       	adc	r29, r1
    5bee:	0f b6       	in	r0, 0x3f	; 63
    5bf0:	f8 94       	cli
    5bf2:	de bf       	out	0x3e, r29	; 62
    5bf4:	0f be       	out	0x3f, r0	; 63
    5bf6:	cd bf       	out	0x3d, r28	; 61
    5bf8:	ed 01       	movw	r28, r26
    5bfa:	08 95       	ret

00005bfc <memcpy>:
    5bfc:	fb 01       	movw	r30, r22
    5bfe:	dc 01       	movw	r26, r24
    5c00:	02 c0       	rjmp	.+4      	; 0x5c06 <memcpy+0xa>
    5c02:	01 90       	ld	r0, Z+
    5c04:	0d 92       	st	X+, r0
    5c06:	41 50       	subi	r20, 0x01	; 1
    5c08:	50 40       	sbci	r21, 0x00	; 0
    5c0a:	d8 f7       	brcc	.-10     	; 0x5c02 <memcpy+0x6>
    5c0c:	08 95       	ret

00005c0e <_exit>:
    5c0e:	f8 94       	cli

00005c10 <__stop_program>:
    5c10:	ff cf       	rjmp	.-2      	; 0x5c10 <__stop_program>

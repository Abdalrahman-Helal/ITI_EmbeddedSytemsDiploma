
ITI_Day16.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000fce  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          0000000a  00800060  00800060  00001042  2**0
                  ALLOC
  2 .stab         00001824  00000000  00000000  00001044  2**2
                  CONTENTS, READONLY, DEBUGGING
  3 .stabstr      000012ce  00000000  00000000  00002868  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   8:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
   c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  10:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  14:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  18:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  1c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  20:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  24:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  28:	0c 94 a2 00 	jmp	0x144	; 0x144 <__vector_10>
  2c:	0c 94 cf 00 	jmp	0x19e	; 0x19e <__vector_11>
  30:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  34:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  38:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  3c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  40:	0c 94 a5 07 	jmp	0xf4a	; 0xf4a <__vector_16>
  44:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  48:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  4c:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>
  50:	0c 94 3c 00 	jmp	0x78	; 0x78 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_clear_bss>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	01 c0       	rjmp	.+2      	; 0x6a <.do_clear_bss_start>

00000068 <.do_clear_bss_loop>:
  68:	1d 92       	st	X+, r1

0000006a <.do_clear_bss_start>:
  6a:	aa 36       	cpi	r26, 0x6A	; 106
  6c:	b1 07       	cpc	r27, r17
  6e:	e1 f7       	brne	.-8      	; 0x68 <.do_clear_bss_loop>
  70:	0e 94 4a 00 	call	0x94	; 0x94 <main>
  74:	0c 94 e5 07 	jmp	0xfca	; 0xfca <_exit>

00000078 <__bad_interrupt>:
  78:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000007c <ToggleLED>:
#include "MCAL/TIMER/TIMER_Interface.h"

#define F_CPU 8000000UL

void ToggleLED(void)
{
  7c:	df 93       	push	r29
  7e:	cf 93       	push	r28
  80:	cd b7       	in	r28, 0x3d	; 61
  82:	de b7       	in	r29, 0x3e	; 62
	static u8 counter=0;
	counter++;
  84:	80 91 60 00 	lds	r24, 0x0060
  88:	8f 5f       	subi	r24, 0xFF	; 255
  8a:	80 93 60 00 	sts	0x0060, r24
	if(counter == 3907)
	{
		counter =0;
		MDIO_vTogglePinVal(DIO_PORTA , PIN0);
	}
}
  8e:	cf 91       	pop	r28
  90:	df 91       	pop	r29
  92:	08 95       	ret

00000094 <main>:

void main(void)
{
  94:	df 93       	push	r29
  96:	cf 93       	push	r28
  98:	cd b7       	in	r28, 0x3d	; 61
  9a:	de b7       	in	r29, 0x3e	; 62
	MDIO_vSetPinDir(DIO_PORTA , PIN0 , DIO_OUTPUT);
  9c:	80 e0       	ldi	r24, 0x00	; 0
  9e:	60 e0       	ldi	r22, 0x00	; 0
  a0:	41 e0       	ldi	r20, 0x01	; 1
  a2:	0e 94 ee 02 	call	0x5dc	; 0x5dc <MDIO_vSetPinDir>
//	MDIO_vSetPinVal(DIO_PORTA , PIN0 , DIO_HIGH);
	TIMER0_u8SetOVFCallBack(ToggleLED);
  a6:	8e e3       	ldi	r24, 0x3E	; 62
  a8:	90 e0       	ldi	r25, 0x00	; 0
  aa:	0e 94 85 00 	call	0x10a	; 0x10a <TIMER0_u8SetOVFCallBack>
	TIMER0_vInit();
  ae:	0e 94 62 00 	call	0xc4	; 0xc4 <TIMER0_vInit>
	TIMER0_vSetTimerValue(0);
  b2:	80 e0       	ldi	r24, 0x00	; 0
  b4:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <TIMER0_vSetTimerValue>
	TIMER0_vOVFIntEnableDisable(TIMER0_INT_ENABLE);
  b8:	81 e0       	ldi	r24, 0x01	; 1
  ba:	0e 94 18 01 	call	0x230	; 0x230 <TIMER0_vOVFIntEnableDisable>
	GIE_Enable();
  be:	0e 94 6e 01 	call	0x2dc	; 0x2dc <GIE_Enable>
  c2:	ff cf       	rjmp	.-2      	; 0xc2 <main+0x2e>

000000c4 <TIMER0_vInit>:

static void(*Global_pvOVFIntFunc)(void)= NULL;
static void(*Global_pvCTCIntFunc)(void)= NULL;

void TIMER0_vInit(void)
{
  c4:	df 93       	push	r29
  c6:	cf 93       	push	r28
  c8:	cd b7       	in	r28, 0x3d	; 61
  ca:	de b7       	in	r29, 0x3e	; 62
#if TIMER0_MODE == NORMAL_MODE
	CLR_BIT(TCCR0 , TCCR0_WGM00);
  cc:	a3 e5       	ldi	r26, 0x53	; 83
  ce:	b0 e0       	ldi	r27, 0x00	; 0
  d0:	e3 e5       	ldi	r30, 0x53	; 83
  d2:	f0 e0       	ldi	r31, 0x00	; 0
  d4:	80 81       	ld	r24, Z
  d6:	8f 7b       	andi	r24, 0xBF	; 191
  d8:	8c 93       	st	X, r24
	CLR_BIT(TCCR0 , TCCR0_WGM01);
  da:	a3 e5       	ldi	r26, 0x53	; 83
  dc:	b0 e0       	ldi	r27, 0x00	; 0
  de:	e3 e5       	ldi	r30, 0x53	; 83
  e0:	f0 e0       	ldi	r31, 0x00	; 0
  e2:	80 81       	ld	r24, Z
  e4:	87 7f       	andi	r24, 0xF7	; 247
  e6:	8c 93       	st	X, r24

#error "Select The Timer Mode "

#endif
	// Set Prescaler
	TCCR0 &=0b11111000; //Bit Clearing
  e8:	a3 e5       	ldi	r26, 0x53	; 83
  ea:	b0 e0       	ldi	r27, 0x00	; 0
  ec:	e3 e5       	ldi	r30, 0x53	; 83
  ee:	f0 e0       	ldi	r31, 0x00	; 0
  f0:	80 81       	ld	r24, Z
  f2:	88 7f       	andi	r24, 0xF8	; 248
  f4:	8c 93       	st	X, r24
	TCCR0 |=TIMER0_PRESCALER;
  f6:	a3 e5       	ldi	r26, 0x53	; 83
  f8:	b0 e0       	ldi	r27, 0x00	; 0
  fa:	e3 e5       	ldi	r30, 0x53	; 83
  fc:	f0 e0       	ldi	r31, 0x00	; 0
  fe:	80 81       	ld	r24, Z
 100:	82 60       	ori	r24, 0x02	; 2
 102:	8c 93       	st	X, r24

}
 104:	cf 91       	pop	r28
 106:	df 91       	pop	r29
 108:	08 95       	ret

0000010a <TIMER0_u8SetOVFCallBack>:

u8 TIMER0_u8SetOVFCallBack(void (*pvCallBackFunc)(void))
{
 10a:	df 93       	push	r29
 10c:	cf 93       	push	r28
 10e:	00 d0       	rcall	.+0      	; 0x110 <TIMER0_u8SetOVFCallBack+0x6>
 110:	0f 92       	push	r0
 112:	cd b7       	in	r28, 0x3d	; 61
 114:	de b7       	in	r29, 0x3e	; 62
 116:	9b 83       	std	Y+3, r25	; 0x03
 118:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_Status = OK;
 11a:	19 82       	std	Y+1, r1	; 0x01
	if(pvCallBackFunc != NULL)
 11c:	8a 81       	ldd	r24, Y+2	; 0x02
 11e:	9b 81       	ldd	r25, Y+3	; 0x03
 120:	00 97       	sbiw	r24, 0x00	; 0
 122:	39 f0       	breq	.+14     	; 0x132 <TIMER0_u8SetOVFCallBack+0x28>
	{
		Global_pvOVFIntFunc=pvCallBackFunc;
 124:	8a 81       	ldd	r24, Y+2	; 0x02
 126:	9b 81       	ldd	r25, Y+3	; 0x03
 128:	90 93 62 00 	sts	0x0062, r25
 12c:	80 93 61 00 	sts	0x0061, r24
 130:	02 c0       	rjmp	.+4      	; 0x136 <TIMER0_u8SetOVFCallBack+0x2c>
	}
	else
	{
		Local_Status = NOK;
 132:	81 e0       	ldi	r24, 0x01	; 1
 134:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_Status;
 136:	89 81       	ldd	r24, Y+1	; 0x01
}
 138:	0f 90       	pop	r0
 13a:	0f 90       	pop	r0
 13c:	0f 90       	pop	r0
 13e:	cf 91       	pop	r28
 140:	df 91       	pop	r29
 142:	08 95       	ret

00000144 <__vector_10>:

void __vector_10(void) __attribute__((signal));
void __vector_10(void)
{
 144:	1f 92       	push	r1
 146:	0f 92       	push	r0
 148:	0f b6       	in	r0, 0x3f	; 63
 14a:	0f 92       	push	r0
 14c:	11 24       	eor	r1, r1
 14e:	2f 93       	push	r18
 150:	3f 93       	push	r19
 152:	4f 93       	push	r20
 154:	5f 93       	push	r21
 156:	6f 93       	push	r22
 158:	7f 93       	push	r23
 15a:	8f 93       	push	r24
 15c:	9f 93       	push	r25
 15e:	af 93       	push	r26
 160:	bf 93       	push	r27
 162:	ef 93       	push	r30
 164:	ff 93       	push	r31
 166:	df 93       	push	r29
 168:	cf 93       	push	r28
 16a:	cd b7       	in	r28, 0x3d	; 61
 16c:	de b7       	in	r29, 0x3e	; 62
	Global_pvCTCIntFunc();
 16e:	e0 91 63 00 	lds	r30, 0x0063
 172:	f0 91 64 00 	lds	r31, 0x0064
 176:	09 95       	icall
}
 178:	cf 91       	pop	r28
 17a:	df 91       	pop	r29
 17c:	ff 91       	pop	r31
 17e:	ef 91       	pop	r30
 180:	bf 91       	pop	r27
 182:	af 91       	pop	r26
 184:	9f 91       	pop	r25
 186:	8f 91       	pop	r24
 188:	7f 91       	pop	r23
 18a:	6f 91       	pop	r22
 18c:	5f 91       	pop	r21
 18e:	4f 91       	pop	r20
 190:	3f 91       	pop	r19
 192:	2f 91       	pop	r18
 194:	0f 90       	pop	r0
 196:	0f be       	out	0x3f, r0	; 63
 198:	0f 90       	pop	r0
 19a:	1f 90       	pop	r1
 19c:	18 95       	reti

0000019e <__vector_11>:

void __vector_11(void) __attribute__((signal));
void __vector_11(void)
{
 19e:	1f 92       	push	r1
 1a0:	0f 92       	push	r0
 1a2:	0f b6       	in	r0, 0x3f	; 63
 1a4:	0f 92       	push	r0
 1a6:	11 24       	eor	r1, r1
 1a8:	2f 93       	push	r18
 1aa:	3f 93       	push	r19
 1ac:	4f 93       	push	r20
 1ae:	5f 93       	push	r21
 1b0:	6f 93       	push	r22
 1b2:	7f 93       	push	r23
 1b4:	8f 93       	push	r24
 1b6:	9f 93       	push	r25
 1b8:	af 93       	push	r26
 1ba:	bf 93       	push	r27
 1bc:	ef 93       	push	r30
 1be:	ff 93       	push	r31
 1c0:	df 93       	push	r29
 1c2:	cf 93       	push	r28
 1c4:	cd b7       	in	r28, 0x3d	; 61
 1c6:	de b7       	in	r29, 0x3e	; 62
	Global_pvOVFIntFunc();
 1c8:	e0 91 61 00 	lds	r30, 0x0061
 1cc:	f0 91 62 00 	lds	r31, 0x0062
 1d0:	09 95       	icall
}
 1d2:	cf 91       	pop	r28
 1d4:	df 91       	pop	r29
 1d6:	ff 91       	pop	r31
 1d8:	ef 91       	pop	r30
 1da:	bf 91       	pop	r27
 1dc:	af 91       	pop	r26
 1de:	9f 91       	pop	r25
 1e0:	8f 91       	pop	r24
 1e2:	7f 91       	pop	r23
 1e4:	6f 91       	pop	r22
 1e6:	5f 91       	pop	r21
 1e8:	4f 91       	pop	r20
 1ea:	3f 91       	pop	r19
 1ec:	2f 91       	pop	r18
 1ee:	0f 90       	pop	r0
 1f0:	0f be       	out	0x3f, r0	; 63
 1f2:	0f 90       	pop	r0
 1f4:	1f 90       	pop	r1
 1f6:	18 95       	reti

000001f8 <TIMER0_vSetTimerValue>:

void TIMER0_vSetTimerValue(u8 Copy_u8Value)
{
 1f8:	df 93       	push	r29
 1fa:	cf 93       	push	r28
 1fc:	0f 92       	push	r0
 1fe:	cd b7       	in	r28, 0x3d	; 61
 200:	de b7       	in	r29, 0x3e	; 62
 202:	89 83       	std	Y+1, r24	; 0x01
	TCNT0 = Copy_u8Value;
 204:	e2 e5       	ldi	r30, 0x52	; 82
 206:	f0 e0       	ldi	r31, 0x00	; 0
 208:	89 81       	ldd	r24, Y+1	; 0x01
 20a:	80 83       	st	Z, r24
}
 20c:	0f 90       	pop	r0
 20e:	cf 91       	pop	r28
 210:	df 91       	pop	r29
 212:	08 95       	ret

00000214 <TIMER0_vCTCTimerValue>:


void TIMER0_vCTCTimerValue(u8 Copy_u8Value)
{
 214:	df 93       	push	r29
 216:	cf 93       	push	r28
 218:	0f 92       	push	r0
 21a:	cd b7       	in	r28, 0x3d	; 61
 21c:	de b7       	in	r29, 0x3e	; 62
 21e:	89 83       	std	Y+1, r24	; 0x01

	OCR0 = Copy_u8Value;
 220:	ec e5       	ldi	r30, 0x5C	; 92
 222:	f0 e0       	ldi	r31, 0x00	; 0
 224:	89 81       	ldd	r24, Y+1	; 0x01
 226:	80 83       	st	Z, r24
}
 228:	0f 90       	pop	r0
 22a:	cf 91       	pop	r28
 22c:	df 91       	pop	r29
 22e:	08 95       	ret

00000230 <TIMER0_vOVFIntEnableDisable>:

void TIMER0_vOVFIntEnableDisable(u8 Copy_u8TIMER0_INT_e )
{
 230:	df 93       	push	r29
 232:	cf 93       	push	r28
 234:	0f 92       	push	r0
 236:	cd b7       	in	r28, 0x3d	; 61
 238:	de b7       	in	r29, 0x3e	; 62
 23a:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8TIMER0_INT_e == ENABLE)
 23c:	89 81       	ldd	r24, Y+1	; 0x01
 23e:	81 30       	cpi	r24, 0x01	; 1
 240:	41 f4       	brne	.+16     	; 0x252 <TIMER0_vOVFIntEnableDisable+0x22>
	{
		SET_BIT(TIMSK , TIMSK_TOIE0);
 242:	a9 e5       	ldi	r26, 0x59	; 89
 244:	b0 e0       	ldi	r27, 0x00	; 0
 246:	e9 e5       	ldi	r30, 0x59	; 89
 248:	f0 e0       	ldi	r31, 0x00	; 0
 24a:	80 81       	ld	r24, Z
 24c:	81 60       	ori	r24, 0x01	; 1
 24e:	8c 93       	st	X, r24
 250:	07 c0       	rjmp	.+14     	; 0x260 <TIMER0_vOVFIntEnableDisable+0x30>
	}
	else
	{
		CLR_BIT(TIMSK , TIMSK_TOIE0);
 252:	a9 e5       	ldi	r26, 0x59	; 89
 254:	b0 e0       	ldi	r27, 0x00	; 0
 256:	e9 e5       	ldi	r30, 0x59	; 89
 258:	f0 e0       	ldi	r31, 0x00	; 0
 25a:	80 81       	ld	r24, Z
 25c:	8e 7f       	andi	r24, 0xFE	; 254
 25e:	8c 93       	st	X, r24
	}
}
 260:	0f 90       	pop	r0
 262:	cf 91       	pop	r28
 264:	df 91       	pop	r29
 266:	08 95       	ret

00000268 <TIMER0_vCTCIntEnableDisable>:
void TIMER0_vCTCIntEnableDisable(u8 Copy_u8TIMER0_INT_e )
{
 268:	df 93       	push	r29
 26a:	cf 93       	push	r28
 26c:	0f 92       	push	r0
 26e:	cd b7       	in	r28, 0x3d	; 61
 270:	de b7       	in	r29, 0x3e	; 62
 272:	89 83       	std	Y+1, r24	; 0x01
	if(Copy_u8TIMER0_INT_e == ENABLE)
 274:	89 81       	ldd	r24, Y+1	; 0x01
 276:	81 30       	cpi	r24, 0x01	; 1
 278:	41 f4       	brne	.+16     	; 0x28a <TIMER0_vCTCIntEnableDisable+0x22>
	{
		SET_BIT(TIMSK , TIMSK_OCIE0);
 27a:	a9 e5       	ldi	r26, 0x59	; 89
 27c:	b0 e0       	ldi	r27, 0x00	; 0
 27e:	e9 e5       	ldi	r30, 0x59	; 89
 280:	f0 e0       	ldi	r31, 0x00	; 0
 282:	80 81       	ld	r24, Z
 284:	82 60       	ori	r24, 0x02	; 2
 286:	8c 93       	st	X, r24
 288:	07 c0       	rjmp	.+14     	; 0x298 <TIMER0_vCTCIntEnableDisable+0x30>
	}
	else
	{
		CLR_BIT(TIMSK , TIMSK_OCIE0);
 28a:	a9 e5       	ldi	r26, 0x59	; 89
 28c:	b0 e0       	ldi	r27, 0x00	; 0
 28e:	e9 e5       	ldi	r30, 0x59	; 89
 290:	f0 e0       	ldi	r31, 0x00	; 0
 292:	80 81       	ld	r24, Z
 294:	8d 7f       	andi	r24, 0xFD	; 253
 296:	8c 93       	st	X, r24
	}
}
 298:	0f 90       	pop	r0
 29a:	cf 91       	pop	r28
 29c:	df 91       	pop	r29
 29e:	08 95       	ret

000002a0 <TIMER0_u8SetCTCCallBack>:
u8 TIMER0_u8SetCTCCallBack(void (*pvCallBackFunc)(void))
{
 2a0:	df 93       	push	r29
 2a2:	cf 93       	push	r28
 2a4:	00 d0       	rcall	.+0      	; 0x2a6 <TIMER0_u8SetCTCCallBack+0x6>
 2a6:	0f 92       	push	r0
 2a8:	cd b7       	in	r28, 0x3d	; 61
 2aa:	de b7       	in	r29, 0x3e	; 62
 2ac:	9b 83       	std	Y+3, r25	; 0x03
 2ae:	8a 83       	std	Y+2, r24	; 0x02
	u8 Local_Status=OK;
 2b0:	19 82       	std	Y+1, r1	; 0x01
	if(pvCallBackFunc != NULL)
 2b2:	8a 81       	ldd	r24, Y+2	; 0x02
 2b4:	9b 81       	ldd	r25, Y+3	; 0x03
 2b6:	00 97       	sbiw	r24, 0x00	; 0
 2b8:	41 f0       	breq	.+16     	; 0x2ca <TIMER0_u8SetCTCCallBack+0x2a>
	{
		Global_pvCTCIntFunc = pvCallBackFunc;
 2ba:	8a 81       	ldd	r24, Y+2	; 0x02
 2bc:	9b 81       	ldd	r25, Y+3	; 0x03
 2be:	90 93 64 00 	sts	0x0064, r25
 2c2:	80 93 63 00 	sts	0x0063, r24
		Local_Status=OK;
 2c6:	19 82       	std	Y+1, r1	; 0x01
 2c8:	02 c0       	rjmp	.+4      	; 0x2ce <TIMER0_u8SetCTCCallBack+0x2e>
	}
	else
	{
		Local_Status =NOK;
 2ca:	81 e0       	ldi	r24, 0x01	; 1
 2cc:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_Status;
 2ce:	89 81       	ldd	r24, Y+1	; 0x01
}
 2d0:	0f 90       	pop	r0
 2d2:	0f 90       	pop	r0
 2d4:	0f 90       	pop	r0
 2d6:	cf 91       	pop	r28
 2d8:	df 91       	pop	r29
 2da:	08 95       	ret

000002dc <GIE_Enable>:
#include "GIE_Private.h"
#include "GIE_Cfg.h"


void GIE_Enable(void)
{
 2dc:	df 93       	push	r29
 2de:	cf 93       	push	r28
 2e0:	cd b7       	in	r28, 0x3d	; 61
 2e2:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(SREG , SREG_I);
 2e4:	af e5       	ldi	r26, 0x5F	; 95
 2e6:	b0 e0       	ldi	r27, 0x00	; 0
 2e8:	ef e5       	ldi	r30, 0x5F	; 95
 2ea:	f0 e0       	ldi	r31, 0x00	; 0
 2ec:	80 81       	ld	r24, Z
 2ee:	80 68       	ori	r24, 0x80	; 128
 2f0:	8c 93       	st	X, r24
}
 2f2:	cf 91       	pop	r28
 2f4:	df 91       	pop	r29
 2f6:	08 95       	ret

000002f8 <GIE_Disable>:
void GIE_Disable(void)
{
 2f8:	df 93       	push	r29
 2fa:	cf 93       	push	r28
 2fc:	cd b7       	in	r28, 0x3d	; 61
 2fe:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG , SREG_I);
 300:	af e5       	ldi	r26, 0x5F	; 95
 302:	b0 e0       	ldi	r27, 0x00	; 0
 304:	ef e5       	ldi	r30, 0x5F	; 95
 306:	f0 e0       	ldi	r31, 0x00	; 0
 308:	80 81       	ld	r24, Z
 30a:	8f 77       	andi	r24, 0x7F	; 127
 30c:	8c 93       	st	X, r24
}
 30e:	cf 91       	pop	r28
 310:	df 91       	pop	r29
 312:	08 95       	ret

00000314 <EXTI_EnableDisable>:

#include "EXTI_Interface.h"
#include "EXTI_Private.h"

void EXTI_EnableDisable(u8 Copy_u8EXTI_INTNum_e , u8 Copy_u8EXTI_MODE_e)
{
 314:	df 93       	push	r29
 316:	cf 93       	push	r28
 318:	00 d0       	rcall	.+0      	; 0x31a <EXTI_EnableDisable+0x6>
 31a:	00 d0       	rcall	.+0      	; 0x31c <EXTI_EnableDisable+0x8>
 31c:	cd b7       	in	r28, 0x3d	; 61
 31e:	de b7       	in	r29, 0x3e	; 62
 320:	89 83       	std	Y+1, r24	; 0x01
 322:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8EXTI_INTNum_e)
 324:	89 81       	ldd	r24, Y+1	; 0x01
 326:	28 2f       	mov	r18, r24
 328:	30 e0       	ldi	r19, 0x00	; 0
 32a:	3c 83       	std	Y+4, r19	; 0x04
 32c:	2b 83       	std	Y+3, r18	; 0x03
 32e:	8b 81       	ldd	r24, Y+3	; 0x03
 330:	9c 81       	ldd	r25, Y+4	; 0x04
 332:	81 30       	cpi	r24, 0x01	; 1
 334:	91 05       	cpc	r25, r1
 336:	01 f1       	breq	.+64     	; 0x378 <EXTI_EnableDisable+0x64>
 338:	2b 81       	ldd	r18, Y+3	; 0x03
 33a:	3c 81       	ldd	r19, Y+4	; 0x04
 33c:	22 30       	cpi	r18, 0x02	; 2
 33e:	31 05       	cpc	r19, r1
 340:	89 f1       	breq	.+98     	; 0x3a4 <EXTI_EnableDisable+0x90>
 342:	8b 81       	ldd	r24, Y+3	; 0x03
 344:	9c 81       	ldd	r25, Y+4	; 0x04
 346:	00 97       	sbiw	r24, 0x00	; 0
 348:	09 f0       	breq	.+2      	; 0x34c <EXTI_EnableDisable+0x38>
 34a:	41 c0       	rjmp	.+130    	; 0x3ce <EXTI_EnableDisable+0xba>
	{
	case EXTI_INT_0:
		if(EXTI_ENABLE == Copy_u8EXTI_MODE_e)
 34c:	8a 81       	ldd	r24, Y+2	; 0x02
 34e:	81 30       	cpi	r24, 0x01	; 1
 350:	41 f4       	brne	.+16     	; 0x362 <EXTI_EnableDisable+0x4e>
		{
			SET_BIT(GICR , GICR_INT0);
 352:	ab e5       	ldi	r26, 0x5B	; 91
 354:	b0 e0       	ldi	r27, 0x00	; 0
 356:	eb e5       	ldi	r30, 0x5B	; 91
 358:	f0 e0       	ldi	r31, 0x00	; 0
 35a:	80 81       	ld	r24, Z
 35c:	80 64       	ori	r24, 0x40	; 64
 35e:	8c 93       	st	X, r24
 360:	36 c0       	rjmp	.+108    	; 0x3ce <EXTI_EnableDisable+0xba>
		}
		else if(EXTI_DISABLE == Copy_u8EXTI_MODE_e)
 362:	8a 81       	ldd	r24, Y+2	; 0x02
 364:	88 23       	and	r24, r24
 366:	99 f5       	brne	.+102    	; 0x3ce <EXTI_EnableDisable+0xba>
		{
			CLR_BIT(GICR , GICR_INT0);
 368:	ab e5       	ldi	r26, 0x5B	; 91
 36a:	b0 e0       	ldi	r27, 0x00	; 0
 36c:	eb e5       	ldi	r30, 0x5B	; 91
 36e:	f0 e0       	ldi	r31, 0x00	; 0
 370:	80 81       	ld	r24, Z
 372:	8f 7b       	andi	r24, 0xBF	; 191
 374:	8c 93       	st	X, r24
 376:	2b c0       	rjmp	.+86     	; 0x3ce <EXTI_EnableDisable+0xba>
		}
		break;


	case EXTI_INT_1:
		if(EXTI_ENABLE == Copy_u8EXTI_MODE_e)
 378:	8a 81       	ldd	r24, Y+2	; 0x02
 37a:	81 30       	cpi	r24, 0x01	; 1
 37c:	41 f4       	brne	.+16     	; 0x38e <EXTI_EnableDisable+0x7a>
		{
			SET_BIT(GICR , GICR_INT1);
 37e:	ab e5       	ldi	r26, 0x5B	; 91
 380:	b0 e0       	ldi	r27, 0x00	; 0
 382:	eb e5       	ldi	r30, 0x5B	; 91
 384:	f0 e0       	ldi	r31, 0x00	; 0
 386:	80 81       	ld	r24, Z
 388:	80 68       	ori	r24, 0x80	; 128
 38a:	8c 93       	st	X, r24
 38c:	20 c0       	rjmp	.+64     	; 0x3ce <EXTI_EnableDisable+0xba>
		}
		else if(EXTI_DISABLE == Copy_u8EXTI_MODE_e)
 38e:	8a 81       	ldd	r24, Y+2	; 0x02
 390:	88 23       	and	r24, r24
 392:	e9 f4       	brne	.+58     	; 0x3ce <EXTI_EnableDisable+0xba>
		{
			CLR_BIT(GICR , GICR_INT1);
 394:	ab e5       	ldi	r26, 0x5B	; 91
 396:	b0 e0       	ldi	r27, 0x00	; 0
 398:	eb e5       	ldi	r30, 0x5B	; 91
 39a:	f0 e0       	ldi	r31, 0x00	; 0
 39c:	80 81       	ld	r24, Z
 39e:	8f 77       	andi	r24, 0x7F	; 127
 3a0:	8c 93       	st	X, r24
 3a2:	15 c0       	rjmp	.+42     	; 0x3ce <EXTI_EnableDisable+0xba>
		break;



	case EXTI_INT_2:
		if(EXTI_ENABLE == Copy_u8EXTI_MODE_e)
 3a4:	8a 81       	ldd	r24, Y+2	; 0x02
 3a6:	81 30       	cpi	r24, 0x01	; 1
 3a8:	41 f4       	brne	.+16     	; 0x3ba <EXTI_EnableDisable+0xa6>
		{
			SET_BIT(GICR , GICR_INT2);
 3aa:	ab e5       	ldi	r26, 0x5B	; 91
 3ac:	b0 e0       	ldi	r27, 0x00	; 0
 3ae:	eb e5       	ldi	r30, 0x5B	; 91
 3b0:	f0 e0       	ldi	r31, 0x00	; 0
 3b2:	80 81       	ld	r24, Z
 3b4:	80 62       	ori	r24, 0x20	; 32
 3b6:	8c 93       	st	X, r24
 3b8:	0a c0       	rjmp	.+20     	; 0x3ce <EXTI_EnableDisable+0xba>
		}
		else if(EXTI_DISABLE == Copy_u8EXTI_MODE_e)
 3ba:	8a 81       	ldd	r24, Y+2	; 0x02
 3bc:	88 23       	and	r24, r24
 3be:	39 f4       	brne	.+14     	; 0x3ce <EXTI_EnableDisable+0xba>
		{
			CLR_BIT(GICR , GICR_INT2);
 3c0:	ab e5       	ldi	r26, 0x5B	; 91
 3c2:	b0 e0       	ldi	r27, 0x00	; 0
 3c4:	eb e5       	ldi	r30, 0x5B	; 91
 3c6:	f0 e0       	ldi	r31, 0x00	; 0
 3c8:	80 81       	ld	r24, Z
 3ca:	8f 7d       	andi	r24, 0xDF	; 223
 3cc:	8c 93       	st	X, r24
		}
		break;
	}
}
 3ce:	0f 90       	pop	r0
 3d0:	0f 90       	pop	r0
 3d2:	0f 90       	pop	r0
 3d4:	0f 90       	pop	r0
 3d6:	cf 91       	pop	r28
 3d8:	df 91       	pop	r29
 3da:	08 95       	ret

000003dc <EXTI_SetSenstivity>:

void EXTI_SetSenstivity(u8 Copy_u8EXTI_INTNum_e , u8 Copy_u8EXTI_SENSTIVITY_e)
{
 3dc:	df 93       	push	r29
 3de:	cf 93       	push	r28
 3e0:	cd b7       	in	r28, 0x3d	; 61
 3e2:	de b7       	in	r29, 0x3e	; 62
 3e4:	2a 97       	sbiw	r28, 0x0a	; 10
 3e6:	0f b6       	in	r0, 0x3f	; 63
 3e8:	f8 94       	cli
 3ea:	de bf       	out	0x3e, r29	; 62
 3ec:	0f be       	out	0x3f, r0	; 63
 3ee:	cd bf       	out	0x3d, r28	; 61
 3f0:	89 83       	std	Y+1, r24	; 0x01
 3f2:	6a 83       	std	Y+2, r22	; 0x02
	switch(Copy_u8EXTI_INTNum_e)
 3f4:	89 81       	ldd	r24, Y+1	; 0x01
 3f6:	28 2f       	mov	r18, r24
 3f8:	30 e0       	ldi	r19, 0x00	; 0
 3fa:	3a 87       	std	Y+10, r19	; 0x0a
 3fc:	29 87       	std	Y+9, r18	; 0x09
 3fe:	89 85       	ldd	r24, Y+9	; 0x09
 400:	9a 85       	ldd	r25, Y+10	; 0x0a
 402:	81 30       	cpi	r24, 0x01	; 1
 404:	91 05       	cpc	r25, r1
 406:	09 f4       	brne	.+2      	; 0x40a <EXTI_SetSenstivity+0x2e>
 408:	66 c0       	rjmp	.+204    	; 0x4d6 <EXTI_SetSenstivity+0xfa>
 40a:	29 85       	ldd	r18, Y+9	; 0x09
 40c:	3a 85       	ldd	r19, Y+10	; 0x0a
 40e:	22 30       	cpi	r18, 0x02	; 2
 410:	31 05       	cpc	r19, r1
 412:	09 f4       	brne	.+2      	; 0x416 <EXTI_SetSenstivity+0x3a>
 414:	bb c0       	rjmp	.+374    	; 0x58c <EXTI_SetSenstivity+0x1b0>
 416:	89 85       	ldd	r24, Y+9	; 0x09
 418:	9a 85       	ldd	r25, Y+10	; 0x0a
 41a:	00 97       	sbiw	r24, 0x00	; 0
 41c:	09 f0       	breq	.+2      	; 0x420 <EXTI_SetSenstivity+0x44>
 41e:	d5 c0       	rjmp	.+426    	; 0x5ca <EXTI_SetSenstivity+0x1ee>
	{
	case EXTI_INT_0:
		switch(Copy_u8EXTI_SENSTIVITY_e)
 420:	8a 81       	ldd	r24, Y+2	; 0x02
 422:	28 2f       	mov	r18, r24
 424:	30 e0       	ldi	r19, 0x00	; 0
 426:	38 87       	std	Y+8, r19	; 0x08
 428:	2f 83       	std	Y+7, r18	; 0x07
 42a:	8f 81       	ldd	r24, Y+7	; 0x07
 42c:	98 85       	ldd	r25, Y+8	; 0x08
 42e:	81 30       	cpi	r24, 0x01	; 1
 430:	91 05       	cpc	r25, r1
 432:	21 f1       	breq	.+72     	; 0x47c <EXTI_SetSenstivity+0xa0>
 434:	2f 81       	ldd	r18, Y+7	; 0x07
 436:	38 85       	ldd	r19, Y+8	; 0x08
 438:	22 30       	cpi	r18, 0x02	; 2
 43a:	31 05       	cpc	r19, r1
 43c:	2c f4       	brge	.+10     	; 0x448 <EXTI_SetSenstivity+0x6c>
 43e:	8f 81       	ldd	r24, Y+7	; 0x07
 440:	98 85       	ldd	r25, Y+8	; 0x08
 442:	00 97       	sbiw	r24, 0x00	; 0
 444:	61 f0       	breq	.+24     	; 0x45e <EXTI_SetSenstivity+0x82>
 446:	c1 c0       	rjmp	.+386    	; 0x5ca <EXTI_SetSenstivity+0x1ee>
 448:	2f 81       	ldd	r18, Y+7	; 0x07
 44a:	38 85       	ldd	r19, Y+8	; 0x08
 44c:	22 30       	cpi	r18, 0x02	; 2
 44e:	31 05       	cpc	r19, r1
 450:	21 f1       	breq	.+72     	; 0x49a <EXTI_SetSenstivity+0xbe>
 452:	8f 81       	ldd	r24, Y+7	; 0x07
 454:	98 85       	ldd	r25, Y+8	; 0x08
 456:	83 30       	cpi	r24, 0x03	; 3
 458:	91 05       	cpc	r25, r1
 45a:	71 f1       	breq	.+92     	; 0x4b8 <EXTI_SetSenstivity+0xdc>
 45c:	b6 c0       	rjmp	.+364    	; 0x5ca <EXTI_SetSenstivity+0x1ee>
		{
		case EXTI_LOW_LEVEL:
			CLR_BIT(MCUCR,MCUCR_ISC00);
 45e:	a5 e5       	ldi	r26, 0x55	; 85
 460:	b0 e0       	ldi	r27, 0x00	; 0
 462:	e5 e5       	ldi	r30, 0x55	; 85
 464:	f0 e0       	ldi	r31, 0x00	; 0
 466:	80 81       	ld	r24, Z
 468:	8e 7f       	andi	r24, 0xFE	; 254
 46a:	8c 93       	st	X, r24
			CLR_BIT(MCUCR,MCUCR_ISC01);
 46c:	a5 e5       	ldi	r26, 0x55	; 85
 46e:	b0 e0       	ldi	r27, 0x00	; 0
 470:	e5 e5       	ldi	r30, 0x55	; 85
 472:	f0 e0       	ldi	r31, 0x00	; 0
 474:	80 81       	ld	r24, Z
 476:	8d 7f       	andi	r24, 0xFD	; 253
 478:	8c 93       	st	X, r24
 47a:	a7 c0       	rjmp	.+334    	; 0x5ca <EXTI_SetSenstivity+0x1ee>
			break;

		case EXTI_ON_CHANGE:
			SET_BIT(MCUCR,MCUCR_ISC00);
 47c:	a5 e5       	ldi	r26, 0x55	; 85
 47e:	b0 e0       	ldi	r27, 0x00	; 0
 480:	e5 e5       	ldi	r30, 0x55	; 85
 482:	f0 e0       	ldi	r31, 0x00	; 0
 484:	80 81       	ld	r24, Z
 486:	81 60       	ori	r24, 0x01	; 1
 488:	8c 93       	st	X, r24
			CLR_BIT(MCUCR,MCUCR_ISC01);
 48a:	a5 e5       	ldi	r26, 0x55	; 85
 48c:	b0 e0       	ldi	r27, 0x00	; 0
 48e:	e5 e5       	ldi	r30, 0x55	; 85
 490:	f0 e0       	ldi	r31, 0x00	; 0
 492:	80 81       	ld	r24, Z
 494:	8d 7f       	andi	r24, 0xFD	; 253
 496:	8c 93       	st	X, r24
 498:	98 c0       	rjmp	.+304    	; 0x5ca <EXTI_SetSenstivity+0x1ee>
			break;

		case EXTI_FAILLING_EDGE:
			CLR_BIT(MCUCR,MCUCR_ISC00);
 49a:	a5 e5       	ldi	r26, 0x55	; 85
 49c:	b0 e0       	ldi	r27, 0x00	; 0
 49e:	e5 e5       	ldi	r30, 0x55	; 85
 4a0:	f0 e0       	ldi	r31, 0x00	; 0
 4a2:	80 81       	ld	r24, Z
 4a4:	8e 7f       	andi	r24, 0xFE	; 254
 4a6:	8c 93       	st	X, r24
			SET_BIT(MCUCR,MCUCR_ISC01);
 4a8:	a5 e5       	ldi	r26, 0x55	; 85
 4aa:	b0 e0       	ldi	r27, 0x00	; 0
 4ac:	e5 e5       	ldi	r30, 0x55	; 85
 4ae:	f0 e0       	ldi	r31, 0x00	; 0
 4b0:	80 81       	ld	r24, Z
 4b2:	82 60       	ori	r24, 0x02	; 2
 4b4:	8c 93       	st	X, r24
 4b6:	89 c0       	rjmp	.+274    	; 0x5ca <EXTI_SetSenstivity+0x1ee>
			break;

		case EXTI_RISING_EDGE:
			SET_BIT(MCUCR,MCUCR_ISC00);
 4b8:	a5 e5       	ldi	r26, 0x55	; 85
 4ba:	b0 e0       	ldi	r27, 0x00	; 0
 4bc:	e5 e5       	ldi	r30, 0x55	; 85
 4be:	f0 e0       	ldi	r31, 0x00	; 0
 4c0:	80 81       	ld	r24, Z
 4c2:	81 60       	ori	r24, 0x01	; 1
 4c4:	8c 93       	st	X, r24
			SET_BIT(MCUCR,MCUCR_ISC01);
 4c6:	a5 e5       	ldi	r26, 0x55	; 85
 4c8:	b0 e0       	ldi	r27, 0x00	; 0
 4ca:	e5 e5       	ldi	r30, 0x55	; 85
 4cc:	f0 e0       	ldi	r31, 0x00	; 0
 4ce:	80 81       	ld	r24, Z
 4d0:	82 60       	ori	r24, 0x02	; 2
 4d2:	8c 93       	st	X, r24
 4d4:	7a c0       	rjmp	.+244    	; 0x5ca <EXTI_SetSenstivity+0x1ee>
			break;
		}
		break;

		case EXTI_INT_1:
			switch(Copy_u8EXTI_SENSTIVITY_e)
 4d6:	8a 81       	ldd	r24, Y+2	; 0x02
 4d8:	28 2f       	mov	r18, r24
 4da:	30 e0       	ldi	r19, 0x00	; 0
 4dc:	3e 83       	std	Y+6, r19	; 0x06
 4de:	2d 83       	std	Y+5, r18	; 0x05
 4e0:	8d 81       	ldd	r24, Y+5	; 0x05
 4e2:	9e 81       	ldd	r25, Y+6	; 0x06
 4e4:	81 30       	cpi	r24, 0x01	; 1
 4e6:	91 05       	cpc	r25, r1
 4e8:	21 f1       	breq	.+72     	; 0x532 <EXTI_SetSenstivity+0x156>
 4ea:	2d 81       	ldd	r18, Y+5	; 0x05
 4ec:	3e 81       	ldd	r19, Y+6	; 0x06
 4ee:	22 30       	cpi	r18, 0x02	; 2
 4f0:	31 05       	cpc	r19, r1
 4f2:	2c f4       	brge	.+10     	; 0x4fe <EXTI_SetSenstivity+0x122>
 4f4:	8d 81       	ldd	r24, Y+5	; 0x05
 4f6:	9e 81       	ldd	r25, Y+6	; 0x06
 4f8:	00 97       	sbiw	r24, 0x00	; 0
 4fa:	61 f0       	breq	.+24     	; 0x514 <EXTI_SetSenstivity+0x138>
 4fc:	66 c0       	rjmp	.+204    	; 0x5ca <EXTI_SetSenstivity+0x1ee>
 4fe:	2d 81       	ldd	r18, Y+5	; 0x05
 500:	3e 81       	ldd	r19, Y+6	; 0x06
 502:	22 30       	cpi	r18, 0x02	; 2
 504:	31 05       	cpc	r19, r1
 506:	21 f1       	breq	.+72     	; 0x550 <EXTI_SetSenstivity+0x174>
 508:	8d 81       	ldd	r24, Y+5	; 0x05
 50a:	9e 81       	ldd	r25, Y+6	; 0x06
 50c:	83 30       	cpi	r24, 0x03	; 3
 50e:	91 05       	cpc	r25, r1
 510:	71 f1       	breq	.+92     	; 0x56e <EXTI_SetSenstivity+0x192>
 512:	5b c0       	rjmp	.+182    	; 0x5ca <EXTI_SetSenstivity+0x1ee>
			{
			case EXTI_LOW_LEVEL:
				CLR_BIT(MCUCR,MCUCR_ISC10);
 514:	a5 e5       	ldi	r26, 0x55	; 85
 516:	b0 e0       	ldi	r27, 0x00	; 0
 518:	e5 e5       	ldi	r30, 0x55	; 85
 51a:	f0 e0       	ldi	r31, 0x00	; 0
 51c:	80 81       	ld	r24, Z
 51e:	8b 7f       	andi	r24, 0xFB	; 251
 520:	8c 93       	st	X, r24
				CLR_BIT(MCUCR,MCUCR_ISC11);
 522:	a5 e5       	ldi	r26, 0x55	; 85
 524:	b0 e0       	ldi	r27, 0x00	; 0
 526:	e5 e5       	ldi	r30, 0x55	; 85
 528:	f0 e0       	ldi	r31, 0x00	; 0
 52a:	80 81       	ld	r24, Z
 52c:	87 7f       	andi	r24, 0xF7	; 247
 52e:	8c 93       	st	X, r24
 530:	4c c0       	rjmp	.+152    	; 0x5ca <EXTI_SetSenstivity+0x1ee>
				break;

			case EXTI_ON_CHANGE:
				SET_BIT(MCUCR,MCUCR_ISC10);
 532:	a5 e5       	ldi	r26, 0x55	; 85
 534:	b0 e0       	ldi	r27, 0x00	; 0
 536:	e5 e5       	ldi	r30, 0x55	; 85
 538:	f0 e0       	ldi	r31, 0x00	; 0
 53a:	80 81       	ld	r24, Z
 53c:	84 60       	ori	r24, 0x04	; 4
 53e:	8c 93       	st	X, r24
				CLR_BIT(MCUCR,MCUCR_ISC11);
 540:	a5 e5       	ldi	r26, 0x55	; 85
 542:	b0 e0       	ldi	r27, 0x00	; 0
 544:	e5 e5       	ldi	r30, 0x55	; 85
 546:	f0 e0       	ldi	r31, 0x00	; 0
 548:	80 81       	ld	r24, Z
 54a:	87 7f       	andi	r24, 0xF7	; 247
 54c:	8c 93       	st	X, r24
 54e:	3d c0       	rjmp	.+122    	; 0x5ca <EXTI_SetSenstivity+0x1ee>
				break;

			case EXTI_FAILLING_EDGE:
				CLR_BIT(MCUCR,MCUCR_ISC10);
 550:	a5 e5       	ldi	r26, 0x55	; 85
 552:	b0 e0       	ldi	r27, 0x00	; 0
 554:	e5 e5       	ldi	r30, 0x55	; 85
 556:	f0 e0       	ldi	r31, 0x00	; 0
 558:	80 81       	ld	r24, Z
 55a:	8b 7f       	andi	r24, 0xFB	; 251
 55c:	8c 93       	st	X, r24
				SET_BIT(MCUCR,MCUCR_ISC11);
 55e:	a5 e5       	ldi	r26, 0x55	; 85
 560:	b0 e0       	ldi	r27, 0x00	; 0
 562:	e5 e5       	ldi	r30, 0x55	; 85
 564:	f0 e0       	ldi	r31, 0x00	; 0
 566:	80 81       	ld	r24, Z
 568:	88 60       	ori	r24, 0x08	; 8
 56a:	8c 93       	st	X, r24
 56c:	2e c0       	rjmp	.+92     	; 0x5ca <EXTI_SetSenstivity+0x1ee>
				break;

			case EXTI_RISING_EDGE:
				SET_BIT(MCUCR,MCUCR_ISC10);
 56e:	a5 e5       	ldi	r26, 0x55	; 85
 570:	b0 e0       	ldi	r27, 0x00	; 0
 572:	e5 e5       	ldi	r30, 0x55	; 85
 574:	f0 e0       	ldi	r31, 0x00	; 0
 576:	80 81       	ld	r24, Z
 578:	84 60       	ori	r24, 0x04	; 4
 57a:	8c 93       	st	X, r24
				SET_BIT(MCUCR,MCUCR_ISC11);
 57c:	a5 e5       	ldi	r26, 0x55	; 85
 57e:	b0 e0       	ldi	r27, 0x00	; 0
 580:	e5 e5       	ldi	r30, 0x55	; 85
 582:	f0 e0       	ldi	r31, 0x00	; 0
 584:	80 81       	ld	r24, Z
 586:	88 60       	ori	r24, 0x08	; 8
 588:	8c 93       	st	X, r24
 58a:	1f c0       	rjmp	.+62     	; 0x5ca <EXTI_SetSenstivity+0x1ee>
				break;
			}
			break;

			case EXTI_INT_2:
				switch(Copy_u8EXTI_SENSTIVITY_e)
 58c:	8a 81       	ldd	r24, Y+2	; 0x02
 58e:	28 2f       	mov	r18, r24
 590:	30 e0       	ldi	r19, 0x00	; 0
 592:	3c 83       	std	Y+4, r19	; 0x04
 594:	2b 83       	std	Y+3, r18	; 0x03
 596:	8b 81       	ldd	r24, Y+3	; 0x03
 598:	9c 81       	ldd	r25, Y+4	; 0x04
 59a:	82 30       	cpi	r24, 0x02	; 2
 59c:	91 05       	cpc	r25, r1
 59e:	31 f0       	breq	.+12     	; 0x5ac <EXTI_SetSenstivity+0x1d0>
 5a0:	2b 81       	ldd	r18, Y+3	; 0x03
 5a2:	3c 81       	ldd	r19, Y+4	; 0x04
 5a4:	23 30       	cpi	r18, 0x03	; 3
 5a6:	31 05       	cpc	r19, r1
 5a8:	49 f0       	breq	.+18     	; 0x5bc <EXTI_SetSenstivity+0x1e0>
 5aa:	0f c0       	rjmp	.+30     	; 0x5ca <EXTI_SetSenstivity+0x1ee>
				{
				case
				EXTI_FAILLING_EDGE:
					SET_BIT(MCUCSR , MCUCSR_ISC2);
 5ac:	a4 e5       	ldi	r26, 0x54	; 84
 5ae:	b0 e0       	ldi	r27, 0x00	; 0
 5b0:	e4 e5       	ldi	r30, 0x54	; 84
 5b2:	f0 e0       	ldi	r31, 0x00	; 0
 5b4:	80 81       	ld	r24, Z
 5b6:	80 64       	ori	r24, 0x40	; 64
 5b8:	8c 93       	st	X, r24
 5ba:	07 c0       	rjmp	.+14     	; 0x5ca <EXTI_SetSenstivity+0x1ee>
					break;
				case EXTI_RISING_EDGE:
					CLR_BIT(MCUCSR , MCUCSR_ISC2);
 5bc:	a4 e5       	ldi	r26, 0x54	; 84
 5be:	b0 e0       	ldi	r27, 0x00	; 0
 5c0:	e4 e5       	ldi	r30, 0x54	; 84
 5c2:	f0 e0       	ldi	r31, 0x00	; 0
 5c4:	80 81       	ld	r24, Z
 5c6:	8f 7b       	andi	r24, 0xBF	; 191
 5c8:	8c 93       	st	X, r24
					break;
				}
				break;
	}
}
 5ca:	2a 96       	adiw	r28, 0x0a	; 10
 5cc:	0f b6       	in	r0, 0x3f	; 63
 5ce:	f8 94       	cli
 5d0:	de bf       	out	0x3e, r29	; 62
 5d2:	0f be       	out	0x3f, r0	; 63
 5d4:	cd bf       	out	0x3d, r28	; 61
 5d6:	cf 91       	pop	r28
 5d8:	df 91       	pop	r29
 5da:	08 95       	ret

000005dc <MDIO_vSetPinDir>:




void MDIO_vSetPinDir(DIO_PORT_e A_portID, DIO_PIN_e A_pinID, DIO_DIRECTION_e A_pinDirection)
{
 5dc:	df 93       	push	r29
 5de:	cf 93       	push	r28
 5e0:	cd b7       	in	r28, 0x3d	; 61
 5e2:	de b7       	in	r29, 0x3e	; 62
 5e4:	2d 97       	sbiw	r28, 0x0d	; 13
 5e6:	0f b6       	in	r0, 0x3f	; 63
 5e8:	f8 94       	cli
 5ea:	de bf       	out	0x3e, r29	; 62
 5ec:	0f be       	out	0x3f, r0	; 63
 5ee:	cd bf       	out	0x3d, r28	; 61
 5f0:	89 83       	std	Y+1, r24	; 0x01
 5f2:	6a 83       	std	Y+2, r22	; 0x02
 5f4:	4b 83       	std	Y+3, r20	; 0x03
	// Input Validation
	if ( (A_portID <= DIO_PORTD) && (A_pinID <= PIN7) && (A_pinDirection <= DIO_OUTPUT) )
 5f6:	89 81       	ldd	r24, Y+1	; 0x01
 5f8:	84 30       	cpi	r24, 0x04	; 4
 5fa:	08 f0       	brcs	.+2      	; 0x5fe <MDIO_vSetPinDir+0x22>
 5fc:	09 c1       	rjmp	.+530    	; 0x810 <MDIO_vSetPinDir+0x234>
 5fe:	8a 81       	ldd	r24, Y+2	; 0x02
 600:	88 30       	cpi	r24, 0x08	; 8
 602:	08 f0       	brcs	.+2      	; 0x606 <MDIO_vSetPinDir+0x2a>
 604:	05 c1       	rjmp	.+522    	; 0x810 <MDIO_vSetPinDir+0x234>
 606:	8b 81       	ldd	r24, Y+3	; 0x03
 608:	82 30       	cpi	r24, 0x02	; 2
 60a:	08 f0       	brcs	.+2      	; 0x60e <MDIO_vSetPinDir+0x32>
 60c:	01 c1       	rjmp	.+514    	; 0x810 <MDIO_vSetPinDir+0x234>
	{
		switch (A_portID)
 60e:	89 81       	ldd	r24, Y+1	; 0x01
 610:	28 2f       	mov	r18, r24
 612:	30 e0       	ldi	r19, 0x00	; 0
 614:	3d 87       	std	Y+13, r19	; 0x0d
 616:	2c 87       	std	Y+12, r18	; 0x0c
 618:	8c 85       	ldd	r24, Y+12	; 0x0c
 61a:	9d 85       	ldd	r25, Y+13	; 0x0d
 61c:	81 30       	cpi	r24, 0x01	; 1
 61e:	91 05       	cpc	r25, r1
 620:	09 f4       	brne	.+2      	; 0x624 <MDIO_vSetPinDir+0x48>
 622:	4f c0       	rjmp	.+158    	; 0x6c2 <MDIO_vSetPinDir+0xe6>
 624:	2c 85       	ldd	r18, Y+12	; 0x0c
 626:	3d 85       	ldd	r19, Y+13	; 0x0d
 628:	22 30       	cpi	r18, 0x02	; 2
 62a:	31 05       	cpc	r19, r1
 62c:	2c f4       	brge	.+10     	; 0x638 <MDIO_vSetPinDir+0x5c>
 62e:	8c 85       	ldd	r24, Y+12	; 0x0c
 630:	9d 85       	ldd	r25, Y+13	; 0x0d
 632:	00 97       	sbiw	r24, 0x00	; 0
 634:	71 f0       	breq	.+28     	; 0x652 <MDIO_vSetPinDir+0x76>
 636:	ec c0       	rjmp	.+472    	; 0x810 <MDIO_vSetPinDir+0x234>
 638:	2c 85       	ldd	r18, Y+12	; 0x0c
 63a:	3d 85       	ldd	r19, Y+13	; 0x0d
 63c:	22 30       	cpi	r18, 0x02	; 2
 63e:	31 05       	cpc	r19, r1
 640:	09 f4       	brne	.+2      	; 0x644 <MDIO_vSetPinDir+0x68>
 642:	77 c0       	rjmp	.+238    	; 0x732 <MDIO_vSetPinDir+0x156>
 644:	8c 85       	ldd	r24, Y+12	; 0x0c
 646:	9d 85       	ldd	r25, Y+13	; 0x0d
 648:	83 30       	cpi	r24, 0x03	; 3
 64a:	91 05       	cpc	r25, r1
 64c:	09 f4       	brne	.+2      	; 0x650 <MDIO_vSetPinDir+0x74>
 64e:	a9 c0       	rjmp	.+338    	; 0x7a2 <MDIO_vSetPinDir+0x1c6>
 650:	df c0       	rjmp	.+446    	; 0x810 <MDIO_vSetPinDir+0x234>
		{
		case DIO_PORTA:
			switch (A_pinDirection)
 652:	8b 81       	ldd	r24, Y+3	; 0x03
 654:	28 2f       	mov	r18, r24
 656:	30 e0       	ldi	r19, 0x00	; 0
 658:	3b 87       	std	Y+11, r19	; 0x0b
 65a:	2a 87       	std	Y+10, r18	; 0x0a
 65c:	8a 85       	ldd	r24, Y+10	; 0x0a
 65e:	9b 85       	ldd	r25, Y+11	; 0x0b
 660:	00 97       	sbiw	r24, 0x00	; 0
 662:	31 f0       	breq	.+12     	; 0x670 <MDIO_vSetPinDir+0x94>
 664:	2a 85       	ldd	r18, Y+10	; 0x0a
 666:	3b 85       	ldd	r19, Y+11	; 0x0b
 668:	21 30       	cpi	r18, 0x01	; 1
 66a:	31 05       	cpc	r19, r1
 66c:	b1 f0       	breq	.+44     	; 0x69a <MDIO_vSetPinDir+0xbe>
 66e:	d0 c0       	rjmp	.+416    	; 0x810 <MDIO_vSetPinDir+0x234>
			{
			case DIO_INPUT:
				CLR_BIT(DDRA_REG,A_pinID);
 670:	aa e3       	ldi	r26, 0x3A	; 58
 672:	b0 e0       	ldi	r27, 0x00	; 0
 674:	ea e3       	ldi	r30, 0x3A	; 58
 676:	f0 e0       	ldi	r31, 0x00	; 0
 678:	80 81       	ld	r24, Z
 67a:	48 2f       	mov	r20, r24
 67c:	8a 81       	ldd	r24, Y+2	; 0x02
 67e:	28 2f       	mov	r18, r24
 680:	30 e0       	ldi	r19, 0x00	; 0
 682:	81 e0       	ldi	r24, 0x01	; 1
 684:	90 e0       	ldi	r25, 0x00	; 0
 686:	02 2e       	mov	r0, r18
 688:	02 c0       	rjmp	.+4      	; 0x68e <MDIO_vSetPinDir+0xb2>
 68a:	88 0f       	add	r24, r24
 68c:	99 1f       	adc	r25, r25
 68e:	0a 94       	dec	r0
 690:	e2 f7       	brpl	.-8      	; 0x68a <MDIO_vSetPinDir+0xae>
 692:	80 95       	com	r24
 694:	84 23       	and	r24, r20
 696:	8c 93       	st	X, r24
 698:	bb c0       	rjmp	.+374    	; 0x810 <MDIO_vSetPinDir+0x234>
				break;
			case DIO_OUTPUT:
				SET_BIT(DDRA_REG,A_pinID);
 69a:	aa e3       	ldi	r26, 0x3A	; 58
 69c:	b0 e0       	ldi	r27, 0x00	; 0
 69e:	ea e3       	ldi	r30, 0x3A	; 58
 6a0:	f0 e0       	ldi	r31, 0x00	; 0
 6a2:	80 81       	ld	r24, Z
 6a4:	48 2f       	mov	r20, r24
 6a6:	8a 81       	ldd	r24, Y+2	; 0x02
 6a8:	28 2f       	mov	r18, r24
 6aa:	30 e0       	ldi	r19, 0x00	; 0
 6ac:	81 e0       	ldi	r24, 0x01	; 1
 6ae:	90 e0       	ldi	r25, 0x00	; 0
 6b0:	02 2e       	mov	r0, r18
 6b2:	02 c0       	rjmp	.+4      	; 0x6b8 <MDIO_vSetPinDir+0xdc>
 6b4:	88 0f       	add	r24, r24
 6b6:	99 1f       	adc	r25, r25
 6b8:	0a 94       	dec	r0
 6ba:	e2 f7       	brpl	.-8      	; 0x6b4 <MDIO_vSetPinDir+0xd8>
 6bc:	84 2b       	or	r24, r20
 6be:	8c 93       	st	X, r24
 6c0:	a7 c0       	rjmp	.+334    	; 0x810 <MDIO_vSetPinDir+0x234>
				break;
			}
			break;
		case DIO_PORTB:
			switch (A_pinDirection)
 6c2:	8b 81       	ldd	r24, Y+3	; 0x03
 6c4:	28 2f       	mov	r18, r24
 6c6:	30 e0       	ldi	r19, 0x00	; 0
 6c8:	39 87       	std	Y+9, r19	; 0x09
 6ca:	28 87       	std	Y+8, r18	; 0x08
 6cc:	88 85       	ldd	r24, Y+8	; 0x08
 6ce:	99 85       	ldd	r25, Y+9	; 0x09
 6d0:	00 97       	sbiw	r24, 0x00	; 0
 6d2:	31 f0       	breq	.+12     	; 0x6e0 <MDIO_vSetPinDir+0x104>
 6d4:	28 85       	ldd	r18, Y+8	; 0x08
 6d6:	39 85       	ldd	r19, Y+9	; 0x09
 6d8:	21 30       	cpi	r18, 0x01	; 1
 6da:	31 05       	cpc	r19, r1
 6dc:	b1 f0       	breq	.+44     	; 0x70a <MDIO_vSetPinDir+0x12e>
 6de:	98 c0       	rjmp	.+304    	; 0x810 <MDIO_vSetPinDir+0x234>
			{
			case DIO_INPUT:
				CLR_BIT(DDRB_REG,A_pinID);
 6e0:	a7 e3       	ldi	r26, 0x37	; 55
 6e2:	b0 e0       	ldi	r27, 0x00	; 0
 6e4:	e7 e3       	ldi	r30, 0x37	; 55
 6e6:	f0 e0       	ldi	r31, 0x00	; 0
 6e8:	80 81       	ld	r24, Z
 6ea:	48 2f       	mov	r20, r24
 6ec:	8a 81       	ldd	r24, Y+2	; 0x02
 6ee:	28 2f       	mov	r18, r24
 6f0:	30 e0       	ldi	r19, 0x00	; 0
 6f2:	81 e0       	ldi	r24, 0x01	; 1
 6f4:	90 e0       	ldi	r25, 0x00	; 0
 6f6:	02 2e       	mov	r0, r18
 6f8:	02 c0       	rjmp	.+4      	; 0x6fe <MDIO_vSetPinDir+0x122>
 6fa:	88 0f       	add	r24, r24
 6fc:	99 1f       	adc	r25, r25
 6fe:	0a 94       	dec	r0
 700:	e2 f7       	brpl	.-8      	; 0x6fa <MDIO_vSetPinDir+0x11e>
 702:	80 95       	com	r24
 704:	84 23       	and	r24, r20
 706:	8c 93       	st	X, r24
 708:	83 c0       	rjmp	.+262    	; 0x810 <MDIO_vSetPinDir+0x234>
				break;
			case DIO_OUTPUT:
				SET_BIT(DDRB_REG,A_pinID);
 70a:	a7 e3       	ldi	r26, 0x37	; 55
 70c:	b0 e0       	ldi	r27, 0x00	; 0
 70e:	e7 e3       	ldi	r30, 0x37	; 55
 710:	f0 e0       	ldi	r31, 0x00	; 0
 712:	80 81       	ld	r24, Z
 714:	48 2f       	mov	r20, r24
 716:	8a 81       	ldd	r24, Y+2	; 0x02
 718:	28 2f       	mov	r18, r24
 71a:	30 e0       	ldi	r19, 0x00	; 0
 71c:	81 e0       	ldi	r24, 0x01	; 1
 71e:	90 e0       	ldi	r25, 0x00	; 0
 720:	02 2e       	mov	r0, r18
 722:	02 c0       	rjmp	.+4      	; 0x728 <MDIO_vSetPinDir+0x14c>
 724:	88 0f       	add	r24, r24
 726:	99 1f       	adc	r25, r25
 728:	0a 94       	dec	r0
 72a:	e2 f7       	brpl	.-8      	; 0x724 <MDIO_vSetPinDir+0x148>
 72c:	84 2b       	or	r24, r20
 72e:	8c 93       	st	X, r24
 730:	6f c0       	rjmp	.+222    	; 0x810 <MDIO_vSetPinDir+0x234>
				break;
			}
			break;
		case DIO_PORTC:
			switch (A_pinDirection)
 732:	8b 81       	ldd	r24, Y+3	; 0x03
 734:	28 2f       	mov	r18, r24
 736:	30 e0       	ldi	r19, 0x00	; 0
 738:	3f 83       	std	Y+7, r19	; 0x07
 73a:	2e 83       	std	Y+6, r18	; 0x06
 73c:	8e 81       	ldd	r24, Y+6	; 0x06
 73e:	9f 81       	ldd	r25, Y+7	; 0x07
 740:	00 97       	sbiw	r24, 0x00	; 0
 742:	31 f0       	breq	.+12     	; 0x750 <MDIO_vSetPinDir+0x174>
 744:	2e 81       	ldd	r18, Y+6	; 0x06
 746:	3f 81       	ldd	r19, Y+7	; 0x07
 748:	21 30       	cpi	r18, 0x01	; 1
 74a:	31 05       	cpc	r19, r1
 74c:	b1 f0       	breq	.+44     	; 0x77a <MDIO_vSetPinDir+0x19e>
 74e:	60 c0       	rjmp	.+192    	; 0x810 <MDIO_vSetPinDir+0x234>
			{
			case DIO_INPUT:
				CLR_BIT(DDRC_REG,A_pinID);
 750:	a4 e3       	ldi	r26, 0x34	; 52
 752:	b0 e0       	ldi	r27, 0x00	; 0
 754:	e4 e3       	ldi	r30, 0x34	; 52
 756:	f0 e0       	ldi	r31, 0x00	; 0
 758:	80 81       	ld	r24, Z
 75a:	48 2f       	mov	r20, r24
 75c:	8a 81       	ldd	r24, Y+2	; 0x02
 75e:	28 2f       	mov	r18, r24
 760:	30 e0       	ldi	r19, 0x00	; 0
 762:	81 e0       	ldi	r24, 0x01	; 1
 764:	90 e0       	ldi	r25, 0x00	; 0
 766:	02 2e       	mov	r0, r18
 768:	02 c0       	rjmp	.+4      	; 0x76e <MDIO_vSetPinDir+0x192>
 76a:	88 0f       	add	r24, r24
 76c:	99 1f       	adc	r25, r25
 76e:	0a 94       	dec	r0
 770:	e2 f7       	brpl	.-8      	; 0x76a <MDIO_vSetPinDir+0x18e>
 772:	80 95       	com	r24
 774:	84 23       	and	r24, r20
 776:	8c 93       	st	X, r24
 778:	4b c0       	rjmp	.+150    	; 0x810 <MDIO_vSetPinDir+0x234>
				break;
			case DIO_OUTPUT:
				SET_BIT(DDRC_REG,A_pinID);
 77a:	a4 e3       	ldi	r26, 0x34	; 52
 77c:	b0 e0       	ldi	r27, 0x00	; 0
 77e:	e4 e3       	ldi	r30, 0x34	; 52
 780:	f0 e0       	ldi	r31, 0x00	; 0
 782:	80 81       	ld	r24, Z
 784:	48 2f       	mov	r20, r24
 786:	8a 81       	ldd	r24, Y+2	; 0x02
 788:	28 2f       	mov	r18, r24
 78a:	30 e0       	ldi	r19, 0x00	; 0
 78c:	81 e0       	ldi	r24, 0x01	; 1
 78e:	90 e0       	ldi	r25, 0x00	; 0
 790:	02 2e       	mov	r0, r18
 792:	02 c0       	rjmp	.+4      	; 0x798 <MDIO_vSetPinDir+0x1bc>
 794:	88 0f       	add	r24, r24
 796:	99 1f       	adc	r25, r25
 798:	0a 94       	dec	r0
 79a:	e2 f7       	brpl	.-8      	; 0x794 <MDIO_vSetPinDir+0x1b8>
 79c:	84 2b       	or	r24, r20
 79e:	8c 93       	st	X, r24
 7a0:	37 c0       	rjmp	.+110    	; 0x810 <MDIO_vSetPinDir+0x234>
				break;
			}
			break;
		case DIO_PORTD:
			switch (A_pinDirection)
 7a2:	8b 81       	ldd	r24, Y+3	; 0x03
 7a4:	28 2f       	mov	r18, r24
 7a6:	30 e0       	ldi	r19, 0x00	; 0
 7a8:	3d 83       	std	Y+5, r19	; 0x05
 7aa:	2c 83       	std	Y+4, r18	; 0x04
 7ac:	8c 81       	ldd	r24, Y+4	; 0x04
 7ae:	9d 81       	ldd	r25, Y+5	; 0x05
 7b0:	00 97       	sbiw	r24, 0x00	; 0
 7b2:	31 f0       	breq	.+12     	; 0x7c0 <MDIO_vSetPinDir+0x1e4>
 7b4:	2c 81       	ldd	r18, Y+4	; 0x04
 7b6:	3d 81       	ldd	r19, Y+5	; 0x05
 7b8:	21 30       	cpi	r18, 0x01	; 1
 7ba:	31 05       	cpc	r19, r1
 7bc:	b1 f0       	breq	.+44     	; 0x7ea <MDIO_vSetPinDir+0x20e>
 7be:	28 c0       	rjmp	.+80     	; 0x810 <MDIO_vSetPinDir+0x234>
			{
			case DIO_INPUT:
				CLR_BIT(DDRD_REG,A_pinID);
 7c0:	a1 e3       	ldi	r26, 0x31	; 49
 7c2:	b0 e0       	ldi	r27, 0x00	; 0
 7c4:	e1 e3       	ldi	r30, 0x31	; 49
 7c6:	f0 e0       	ldi	r31, 0x00	; 0
 7c8:	80 81       	ld	r24, Z
 7ca:	48 2f       	mov	r20, r24
 7cc:	8a 81       	ldd	r24, Y+2	; 0x02
 7ce:	28 2f       	mov	r18, r24
 7d0:	30 e0       	ldi	r19, 0x00	; 0
 7d2:	81 e0       	ldi	r24, 0x01	; 1
 7d4:	90 e0       	ldi	r25, 0x00	; 0
 7d6:	02 2e       	mov	r0, r18
 7d8:	02 c0       	rjmp	.+4      	; 0x7de <MDIO_vSetPinDir+0x202>
 7da:	88 0f       	add	r24, r24
 7dc:	99 1f       	adc	r25, r25
 7de:	0a 94       	dec	r0
 7e0:	e2 f7       	brpl	.-8      	; 0x7da <MDIO_vSetPinDir+0x1fe>
 7e2:	80 95       	com	r24
 7e4:	84 23       	and	r24, r20
 7e6:	8c 93       	st	X, r24
 7e8:	13 c0       	rjmp	.+38     	; 0x810 <MDIO_vSetPinDir+0x234>
				break;
			case DIO_OUTPUT:
				SET_BIT(DDRD_REG,A_pinID);
 7ea:	a1 e3       	ldi	r26, 0x31	; 49
 7ec:	b0 e0       	ldi	r27, 0x00	; 0
 7ee:	e1 e3       	ldi	r30, 0x31	; 49
 7f0:	f0 e0       	ldi	r31, 0x00	; 0
 7f2:	80 81       	ld	r24, Z
 7f4:	48 2f       	mov	r20, r24
 7f6:	8a 81       	ldd	r24, Y+2	; 0x02
 7f8:	28 2f       	mov	r18, r24
 7fa:	30 e0       	ldi	r19, 0x00	; 0
 7fc:	81 e0       	ldi	r24, 0x01	; 1
 7fe:	90 e0       	ldi	r25, 0x00	; 0
 800:	02 2e       	mov	r0, r18
 802:	02 c0       	rjmp	.+4      	; 0x808 <MDIO_vSetPinDir+0x22c>
 804:	88 0f       	add	r24, r24
 806:	99 1f       	adc	r25, r25
 808:	0a 94       	dec	r0
 80a:	e2 f7       	brpl	.-8      	; 0x804 <MDIO_vSetPinDir+0x228>
 80c:	84 2b       	or	r24, r20
 80e:	8c 93       	st	X, r24
	}
	else
	{
		// Do Nothing
	}
}
 810:	2d 96       	adiw	r28, 0x0d	; 13
 812:	0f b6       	in	r0, 0x3f	; 63
 814:	f8 94       	cli
 816:	de bf       	out	0x3e, r29	; 62
 818:	0f be       	out	0x3f, r0	; 63
 81a:	cd bf       	out	0x3d, r28	; 61
 81c:	cf 91       	pop	r28
 81e:	df 91       	pop	r29
 820:	08 95       	ret

00000822 <MDIO_vSetPinVal>:


void MDIO_vSetPinVal(DIO_PORT_e A_portID, DIO_PIN_e A_pinID, DIO_VALUE_e A_pinValue)
{
 822:	df 93       	push	r29
 824:	cf 93       	push	r28
 826:	cd b7       	in	r28, 0x3d	; 61
 828:	de b7       	in	r29, 0x3e	; 62
 82a:	2d 97       	sbiw	r28, 0x0d	; 13
 82c:	0f b6       	in	r0, 0x3f	; 63
 82e:	f8 94       	cli
 830:	de bf       	out	0x3e, r29	; 62
 832:	0f be       	out	0x3f, r0	; 63
 834:	cd bf       	out	0x3d, r28	; 61
 836:	89 83       	std	Y+1, r24	; 0x01
 838:	6a 83       	std	Y+2, r22	; 0x02
 83a:	4b 83       	std	Y+3, r20	; 0x03
	// Input Validation
	if ( (A_portID <= DIO_PORTD) && (A_pinID <= PIN7) && (A_pinValue <= DIO_HIGH) )
 83c:	89 81       	ldd	r24, Y+1	; 0x01
 83e:	84 30       	cpi	r24, 0x04	; 4
 840:	08 f0       	brcs	.+2      	; 0x844 <MDIO_vSetPinVal+0x22>
 842:	09 c1       	rjmp	.+530    	; 0xa56 <__stack+0x1f7>
 844:	8a 81       	ldd	r24, Y+2	; 0x02
 846:	88 30       	cpi	r24, 0x08	; 8
 848:	08 f0       	brcs	.+2      	; 0x84c <MDIO_vSetPinVal+0x2a>
 84a:	05 c1       	rjmp	.+522    	; 0xa56 <__stack+0x1f7>
 84c:	8b 81       	ldd	r24, Y+3	; 0x03
 84e:	82 30       	cpi	r24, 0x02	; 2
 850:	08 f0       	brcs	.+2      	; 0x854 <MDIO_vSetPinVal+0x32>
 852:	01 c1       	rjmp	.+514    	; 0xa56 <__stack+0x1f7>
	{
		switch (A_portID)
 854:	89 81       	ldd	r24, Y+1	; 0x01
 856:	28 2f       	mov	r18, r24
 858:	30 e0       	ldi	r19, 0x00	; 0
 85a:	3d 87       	std	Y+13, r19	; 0x0d
 85c:	2c 87       	std	Y+12, r18	; 0x0c
 85e:	8c 85       	ldd	r24, Y+12	; 0x0c
 860:	9d 85       	ldd	r25, Y+13	; 0x0d
 862:	81 30       	cpi	r24, 0x01	; 1
 864:	91 05       	cpc	r25, r1
 866:	09 f4       	brne	.+2      	; 0x86a <__stack+0xb>
 868:	4f c0       	rjmp	.+158    	; 0x908 <__stack+0xa9>
 86a:	2c 85       	ldd	r18, Y+12	; 0x0c
 86c:	3d 85       	ldd	r19, Y+13	; 0x0d
 86e:	22 30       	cpi	r18, 0x02	; 2
 870:	31 05       	cpc	r19, r1
 872:	2c f4       	brge	.+10     	; 0x87e <__stack+0x1f>
 874:	8c 85       	ldd	r24, Y+12	; 0x0c
 876:	9d 85       	ldd	r25, Y+13	; 0x0d
 878:	00 97       	sbiw	r24, 0x00	; 0
 87a:	71 f0       	breq	.+28     	; 0x898 <__stack+0x39>
 87c:	ec c0       	rjmp	.+472    	; 0xa56 <__stack+0x1f7>
 87e:	2c 85       	ldd	r18, Y+12	; 0x0c
 880:	3d 85       	ldd	r19, Y+13	; 0x0d
 882:	22 30       	cpi	r18, 0x02	; 2
 884:	31 05       	cpc	r19, r1
 886:	09 f4       	brne	.+2      	; 0x88a <__stack+0x2b>
 888:	77 c0       	rjmp	.+238    	; 0x978 <__stack+0x119>
 88a:	8c 85       	ldd	r24, Y+12	; 0x0c
 88c:	9d 85       	ldd	r25, Y+13	; 0x0d
 88e:	83 30       	cpi	r24, 0x03	; 3
 890:	91 05       	cpc	r25, r1
 892:	09 f4       	brne	.+2      	; 0x896 <__stack+0x37>
 894:	a9 c0       	rjmp	.+338    	; 0x9e8 <__stack+0x189>
 896:	df c0       	rjmp	.+446    	; 0xa56 <__stack+0x1f7>
		{
		case DIO_PORTA:
			switch (A_pinValue)
 898:	8b 81       	ldd	r24, Y+3	; 0x03
 89a:	28 2f       	mov	r18, r24
 89c:	30 e0       	ldi	r19, 0x00	; 0
 89e:	3b 87       	std	Y+11, r19	; 0x0b
 8a0:	2a 87       	std	Y+10, r18	; 0x0a
 8a2:	8a 85       	ldd	r24, Y+10	; 0x0a
 8a4:	9b 85       	ldd	r25, Y+11	; 0x0b
 8a6:	00 97       	sbiw	r24, 0x00	; 0
 8a8:	31 f0       	breq	.+12     	; 0x8b6 <__stack+0x57>
 8aa:	2a 85       	ldd	r18, Y+10	; 0x0a
 8ac:	3b 85       	ldd	r19, Y+11	; 0x0b
 8ae:	21 30       	cpi	r18, 0x01	; 1
 8b0:	31 05       	cpc	r19, r1
 8b2:	b1 f0       	breq	.+44     	; 0x8e0 <__stack+0x81>
 8b4:	d0 c0       	rjmp	.+416    	; 0xa56 <__stack+0x1f7>
			{
			case DIO_LOW:
				CLR_BIT(PORTA_REG,A_pinID);
 8b6:	ab e3       	ldi	r26, 0x3B	; 59
 8b8:	b0 e0       	ldi	r27, 0x00	; 0
 8ba:	eb e3       	ldi	r30, 0x3B	; 59
 8bc:	f0 e0       	ldi	r31, 0x00	; 0
 8be:	80 81       	ld	r24, Z
 8c0:	48 2f       	mov	r20, r24
 8c2:	8a 81       	ldd	r24, Y+2	; 0x02
 8c4:	28 2f       	mov	r18, r24
 8c6:	30 e0       	ldi	r19, 0x00	; 0
 8c8:	81 e0       	ldi	r24, 0x01	; 1
 8ca:	90 e0       	ldi	r25, 0x00	; 0
 8cc:	02 2e       	mov	r0, r18
 8ce:	02 c0       	rjmp	.+4      	; 0x8d4 <__stack+0x75>
 8d0:	88 0f       	add	r24, r24
 8d2:	99 1f       	adc	r25, r25
 8d4:	0a 94       	dec	r0
 8d6:	e2 f7       	brpl	.-8      	; 0x8d0 <__stack+0x71>
 8d8:	80 95       	com	r24
 8da:	84 23       	and	r24, r20
 8dc:	8c 93       	st	X, r24
 8de:	bb c0       	rjmp	.+374    	; 0xa56 <__stack+0x1f7>
				break;
			case DIO_HIGH:
				SET_BIT(PORTA_REG,A_pinID);
 8e0:	ab e3       	ldi	r26, 0x3B	; 59
 8e2:	b0 e0       	ldi	r27, 0x00	; 0
 8e4:	eb e3       	ldi	r30, 0x3B	; 59
 8e6:	f0 e0       	ldi	r31, 0x00	; 0
 8e8:	80 81       	ld	r24, Z
 8ea:	48 2f       	mov	r20, r24
 8ec:	8a 81       	ldd	r24, Y+2	; 0x02
 8ee:	28 2f       	mov	r18, r24
 8f0:	30 e0       	ldi	r19, 0x00	; 0
 8f2:	81 e0       	ldi	r24, 0x01	; 1
 8f4:	90 e0       	ldi	r25, 0x00	; 0
 8f6:	02 2e       	mov	r0, r18
 8f8:	02 c0       	rjmp	.+4      	; 0x8fe <__stack+0x9f>
 8fa:	88 0f       	add	r24, r24
 8fc:	99 1f       	adc	r25, r25
 8fe:	0a 94       	dec	r0
 900:	e2 f7       	brpl	.-8      	; 0x8fa <__stack+0x9b>
 902:	84 2b       	or	r24, r20
 904:	8c 93       	st	X, r24
 906:	a7 c0       	rjmp	.+334    	; 0xa56 <__stack+0x1f7>
				break;
			}
			break;
		case DIO_PORTB:
			switch (A_pinValue)
 908:	8b 81       	ldd	r24, Y+3	; 0x03
 90a:	28 2f       	mov	r18, r24
 90c:	30 e0       	ldi	r19, 0x00	; 0
 90e:	39 87       	std	Y+9, r19	; 0x09
 910:	28 87       	std	Y+8, r18	; 0x08
 912:	88 85       	ldd	r24, Y+8	; 0x08
 914:	99 85       	ldd	r25, Y+9	; 0x09
 916:	00 97       	sbiw	r24, 0x00	; 0
 918:	31 f0       	breq	.+12     	; 0x926 <__stack+0xc7>
 91a:	28 85       	ldd	r18, Y+8	; 0x08
 91c:	39 85       	ldd	r19, Y+9	; 0x09
 91e:	21 30       	cpi	r18, 0x01	; 1
 920:	31 05       	cpc	r19, r1
 922:	b1 f0       	breq	.+44     	; 0x950 <__stack+0xf1>
 924:	98 c0       	rjmp	.+304    	; 0xa56 <__stack+0x1f7>
			{
			case DIO_LOW:
				CLR_BIT(PORTB_REG,A_pinID);
 926:	a8 e3       	ldi	r26, 0x38	; 56
 928:	b0 e0       	ldi	r27, 0x00	; 0
 92a:	e8 e3       	ldi	r30, 0x38	; 56
 92c:	f0 e0       	ldi	r31, 0x00	; 0
 92e:	80 81       	ld	r24, Z
 930:	48 2f       	mov	r20, r24
 932:	8a 81       	ldd	r24, Y+2	; 0x02
 934:	28 2f       	mov	r18, r24
 936:	30 e0       	ldi	r19, 0x00	; 0
 938:	81 e0       	ldi	r24, 0x01	; 1
 93a:	90 e0       	ldi	r25, 0x00	; 0
 93c:	02 2e       	mov	r0, r18
 93e:	02 c0       	rjmp	.+4      	; 0x944 <__stack+0xe5>
 940:	88 0f       	add	r24, r24
 942:	99 1f       	adc	r25, r25
 944:	0a 94       	dec	r0
 946:	e2 f7       	brpl	.-8      	; 0x940 <__stack+0xe1>
 948:	80 95       	com	r24
 94a:	84 23       	and	r24, r20
 94c:	8c 93       	st	X, r24
 94e:	83 c0       	rjmp	.+262    	; 0xa56 <__stack+0x1f7>
				break;
			case DIO_HIGH:
				SET_BIT(PORTB_REG,A_pinID);
 950:	a8 e3       	ldi	r26, 0x38	; 56
 952:	b0 e0       	ldi	r27, 0x00	; 0
 954:	e8 e3       	ldi	r30, 0x38	; 56
 956:	f0 e0       	ldi	r31, 0x00	; 0
 958:	80 81       	ld	r24, Z
 95a:	48 2f       	mov	r20, r24
 95c:	8a 81       	ldd	r24, Y+2	; 0x02
 95e:	28 2f       	mov	r18, r24
 960:	30 e0       	ldi	r19, 0x00	; 0
 962:	81 e0       	ldi	r24, 0x01	; 1
 964:	90 e0       	ldi	r25, 0x00	; 0
 966:	02 2e       	mov	r0, r18
 968:	02 c0       	rjmp	.+4      	; 0x96e <__stack+0x10f>
 96a:	88 0f       	add	r24, r24
 96c:	99 1f       	adc	r25, r25
 96e:	0a 94       	dec	r0
 970:	e2 f7       	brpl	.-8      	; 0x96a <__stack+0x10b>
 972:	84 2b       	or	r24, r20
 974:	8c 93       	st	X, r24
 976:	6f c0       	rjmp	.+222    	; 0xa56 <__stack+0x1f7>
				break;
			}
			break;
		case DIO_PORTC:
			switch (A_pinValue)
 978:	8b 81       	ldd	r24, Y+3	; 0x03
 97a:	28 2f       	mov	r18, r24
 97c:	30 e0       	ldi	r19, 0x00	; 0
 97e:	3f 83       	std	Y+7, r19	; 0x07
 980:	2e 83       	std	Y+6, r18	; 0x06
 982:	8e 81       	ldd	r24, Y+6	; 0x06
 984:	9f 81       	ldd	r25, Y+7	; 0x07
 986:	00 97       	sbiw	r24, 0x00	; 0
 988:	31 f0       	breq	.+12     	; 0x996 <__stack+0x137>
 98a:	2e 81       	ldd	r18, Y+6	; 0x06
 98c:	3f 81       	ldd	r19, Y+7	; 0x07
 98e:	21 30       	cpi	r18, 0x01	; 1
 990:	31 05       	cpc	r19, r1
 992:	b1 f0       	breq	.+44     	; 0x9c0 <__stack+0x161>
 994:	60 c0       	rjmp	.+192    	; 0xa56 <__stack+0x1f7>
			{
			case DIO_LOW:
				CLR_BIT(PORTC_REG,A_pinID);
 996:	a5 e3       	ldi	r26, 0x35	; 53
 998:	b0 e0       	ldi	r27, 0x00	; 0
 99a:	e5 e3       	ldi	r30, 0x35	; 53
 99c:	f0 e0       	ldi	r31, 0x00	; 0
 99e:	80 81       	ld	r24, Z
 9a0:	48 2f       	mov	r20, r24
 9a2:	8a 81       	ldd	r24, Y+2	; 0x02
 9a4:	28 2f       	mov	r18, r24
 9a6:	30 e0       	ldi	r19, 0x00	; 0
 9a8:	81 e0       	ldi	r24, 0x01	; 1
 9aa:	90 e0       	ldi	r25, 0x00	; 0
 9ac:	02 2e       	mov	r0, r18
 9ae:	02 c0       	rjmp	.+4      	; 0x9b4 <__stack+0x155>
 9b0:	88 0f       	add	r24, r24
 9b2:	99 1f       	adc	r25, r25
 9b4:	0a 94       	dec	r0
 9b6:	e2 f7       	brpl	.-8      	; 0x9b0 <__stack+0x151>
 9b8:	80 95       	com	r24
 9ba:	84 23       	and	r24, r20
 9bc:	8c 93       	st	X, r24
 9be:	4b c0       	rjmp	.+150    	; 0xa56 <__stack+0x1f7>
				break;
			case DIO_HIGH:
				SET_BIT(PORTC_REG,A_pinID);
 9c0:	a5 e3       	ldi	r26, 0x35	; 53
 9c2:	b0 e0       	ldi	r27, 0x00	; 0
 9c4:	e5 e3       	ldi	r30, 0x35	; 53
 9c6:	f0 e0       	ldi	r31, 0x00	; 0
 9c8:	80 81       	ld	r24, Z
 9ca:	48 2f       	mov	r20, r24
 9cc:	8a 81       	ldd	r24, Y+2	; 0x02
 9ce:	28 2f       	mov	r18, r24
 9d0:	30 e0       	ldi	r19, 0x00	; 0
 9d2:	81 e0       	ldi	r24, 0x01	; 1
 9d4:	90 e0       	ldi	r25, 0x00	; 0
 9d6:	02 2e       	mov	r0, r18
 9d8:	02 c0       	rjmp	.+4      	; 0x9de <__stack+0x17f>
 9da:	88 0f       	add	r24, r24
 9dc:	99 1f       	adc	r25, r25
 9de:	0a 94       	dec	r0
 9e0:	e2 f7       	brpl	.-8      	; 0x9da <__stack+0x17b>
 9e2:	84 2b       	or	r24, r20
 9e4:	8c 93       	st	X, r24
 9e6:	37 c0       	rjmp	.+110    	; 0xa56 <__stack+0x1f7>
				break;
			}
			break;
		case DIO_PORTD:
			switch (A_pinValue)
 9e8:	8b 81       	ldd	r24, Y+3	; 0x03
 9ea:	28 2f       	mov	r18, r24
 9ec:	30 e0       	ldi	r19, 0x00	; 0
 9ee:	3d 83       	std	Y+5, r19	; 0x05
 9f0:	2c 83       	std	Y+4, r18	; 0x04
 9f2:	8c 81       	ldd	r24, Y+4	; 0x04
 9f4:	9d 81       	ldd	r25, Y+5	; 0x05
 9f6:	00 97       	sbiw	r24, 0x00	; 0
 9f8:	31 f0       	breq	.+12     	; 0xa06 <__stack+0x1a7>
 9fa:	2c 81       	ldd	r18, Y+4	; 0x04
 9fc:	3d 81       	ldd	r19, Y+5	; 0x05
 9fe:	21 30       	cpi	r18, 0x01	; 1
 a00:	31 05       	cpc	r19, r1
 a02:	b1 f0       	breq	.+44     	; 0xa30 <__stack+0x1d1>
 a04:	28 c0       	rjmp	.+80     	; 0xa56 <__stack+0x1f7>
			{
			case DIO_LOW:
				CLR_BIT(PORTD_REG,A_pinID);
 a06:	a2 e3       	ldi	r26, 0x32	; 50
 a08:	b0 e0       	ldi	r27, 0x00	; 0
 a0a:	e2 e3       	ldi	r30, 0x32	; 50
 a0c:	f0 e0       	ldi	r31, 0x00	; 0
 a0e:	80 81       	ld	r24, Z
 a10:	48 2f       	mov	r20, r24
 a12:	8a 81       	ldd	r24, Y+2	; 0x02
 a14:	28 2f       	mov	r18, r24
 a16:	30 e0       	ldi	r19, 0x00	; 0
 a18:	81 e0       	ldi	r24, 0x01	; 1
 a1a:	90 e0       	ldi	r25, 0x00	; 0
 a1c:	02 2e       	mov	r0, r18
 a1e:	02 c0       	rjmp	.+4      	; 0xa24 <__stack+0x1c5>
 a20:	88 0f       	add	r24, r24
 a22:	99 1f       	adc	r25, r25
 a24:	0a 94       	dec	r0
 a26:	e2 f7       	brpl	.-8      	; 0xa20 <__stack+0x1c1>
 a28:	80 95       	com	r24
 a2a:	84 23       	and	r24, r20
 a2c:	8c 93       	st	X, r24
 a2e:	13 c0       	rjmp	.+38     	; 0xa56 <__stack+0x1f7>
				break;
			case DIO_HIGH:
				SET_BIT(PORTD_REG,A_pinID);
 a30:	a2 e3       	ldi	r26, 0x32	; 50
 a32:	b0 e0       	ldi	r27, 0x00	; 0
 a34:	e2 e3       	ldi	r30, 0x32	; 50
 a36:	f0 e0       	ldi	r31, 0x00	; 0
 a38:	80 81       	ld	r24, Z
 a3a:	48 2f       	mov	r20, r24
 a3c:	8a 81       	ldd	r24, Y+2	; 0x02
 a3e:	28 2f       	mov	r18, r24
 a40:	30 e0       	ldi	r19, 0x00	; 0
 a42:	81 e0       	ldi	r24, 0x01	; 1
 a44:	90 e0       	ldi	r25, 0x00	; 0
 a46:	02 2e       	mov	r0, r18
 a48:	02 c0       	rjmp	.+4      	; 0xa4e <__stack+0x1ef>
 a4a:	88 0f       	add	r24, r24
 a4c:	99 1f       	adc	r25, r25
 a4e:	0a 94       	dec	r0
 a50:	e2 f7       	brpl	.-8      	; 0xa4a <__stack+0x1eb>
 a52:	84 2b       	or	r24, r20
 a54:	8c 93       	st	X, r24
	}
	else
	{
		// Do Nothing
	}
}
 a56:	2d 96       	adiw	r28, 0x0d	; 13
 a58:	0f b6       	in	r0, 0x3f	; 63
 a5a:	f8 94       	cli
 a5c:	de bf       	out	0x3e, r29	; 62
 a5e:	0f be       	out	0x3f, r0	; 63
 a60:	cd bf       	out	0x3d, r28	; 61
 a62:	cf 91       	pop	r28
 a64:	df 91       	pop	r29
 a66:	08 95       	ret

00000a68 <MDIO_GetPinVal>:




DIO_VALUE_e MDIO_GetPinVal(DIO_PORT_e A_portID, DIO_PIN_e A_pinID)
{
 a68:	df 93       	push	r29
 a6a:	cf 93       	push	r28
 a6c:	00 d0       	rcall	.+0      	; 0xa6e <MDIO_GetPinVal+0x6>
 a6e:	00 d0       	rcall	.+0      	; 0xa70 <MDIO_GetPinVal+0x8>
 a70:	0f 92       	push	r0
 a72:	cd b7       	in	r28, 0x3d	; 61
 a74:	de b7       	in	r29, 0x3e	; 62
 a76:	8a 83       	std	Y+2, r24	; 0x02
 a78:	6b 83       	std	Y+3, r22	; 0x03
	DIO_VALUE_e local_PinValue;

	// Input Validation
	if ( (A_portID <= DIO_PORTD) && (A_pinID <= PIN7) )
 a7a:	8a 81       	ldd	r24, Y+2	; 0x02
 a7c:	84 30       	cpi	r24, 0x04	; 4
 a7e:	08 f0       	brcs	.+2      	; 0xa82 <MDIO_GetPinVal+0x1a>
 a80:	6b c0       	rjmp	.+214    	; 0xb58 <MDIO_GetPinVal+0xf0>
 a82:	8b 81       	ldd	r24, Y+3	; 0x03
 a84:	88 30       	cpi	r24, 0x08	; 8
 a86:	08 f0       	brcs	.+2      	; 0xa8a <MDIO_GetPinVal+0x22>
 a88:	67 c0       	rjmp	.+206    	; 0xb58 <MDIO_GetPinVal+0xf0>
	{
		switch (A_portID)
 a8a:	8a 81       	ldd	r24, Y+2	; 0x02
 a8c:	28 2f       	mov	r18, r24
 a8e:	30 e0       	ldi	r19, 0x00	; 0
 a90:	3d 83       	std	Y+5, r19	; 0x05
 a92:	2c 83       	std	Y+4, r18	; 0x04
 a94:	4c 81       	ldd	r20, Y+4	; 0x04
 a96:	5d 81       	ldd	r21, Y+5	; 0x05
 a98:	41 30       	cpi	r20, 0x01	; 1
 a9a:	51 05       	cpc	r21, r1
 a9c:	41 f1       	breq	.+80     	; 0xaee <MDIO_GetPinVal+0x86>
 a9e:	8c 81       	ldd	r24, Y+4	; 0x04
 aa0:	9d 81       	ldd	r25, Y+5	; 0x05
 aa2:	82 30       	cpi	r24, 0x02	; 2
 aa4:	91 05       	cpc	r25, r1
 aa6:	34 f4       	brge	.+12     	; 0xab4 <MDIO_GetPinVal+0x4c>
 aa8:	2c 81       	ldd	r18, Y+4	; 0x04
 aaa:	3d 81       	ldd	r19, Y+5	; 0x05
 aac:	21 15       	cp	r18, r1
 aae:	31 05       	cpc	r19, r1
 ab0:	61 f0       	breq	.+24     	; 0xaca <MDIO_GetPinVal+0x62>
 ab2:	52 c0       	rjmp	.+164    	; 0xb58 <MDIO_GetPinVal+0xf0>
 ab4:	4c 81       	ldd	r20, Y+4	; 0x04
 ab6:	5d 81       	ldd	r21, Y+5	; 0x05
 ab8:	42 30       	cpi	r20, 0x02	; 2
 aba:	51 05       	cpc	r21, r1
 abc:	51 f1       	breq	.+84     	; 0xb12 <MDIO_GetPinVal+0xaa>
 abe:	8c 81       	ldd	r24, Y+4	; 0x04
 ac0:	9d 81       	ldd	r25, Y+5	; 0x05
 ac2:	83 30       	cpi	r24, 0x03	; 3
 ac4:	91 05       	cpc	r25, r1
 ac6:	b9 f1       	breq	.+110    	; 0xb36 <MDIO_GetPinVal+0xce>
 ac8:	47 c0       	rjmp	.+142    	; 0xb58 <MDIO_GetPinVal+0xf0>
		{
		case DIO_PORTA:
			local_PinValue = GET_BIT(PINA_REG,A_pinID);
 aca:	e9 e3       	ldi	r30, 0x39	; 57
 acc:	f0 e0       	ldi	r31, 0x00	; 0
 ace:	80 81       	ld	r24, Z
 ad0:	28 2f       	mov	r18, r24
 ad2:	30 e0       	ldi	r19, 0x00	; 0
 ad4:	8b 81       	ldd	r24, Y+3	; 0x03
 ad6:	88 2f       	mov	r24, r24
 ad8:	90 e0       	ldi	r25, 0x00	; 0
 ada:	a9 01       	movw	r20, r18
 adc:	02 c0       	rjmp	.+4      	; 0xae2 <MDIO_GetPinVal+0x7a>
 ade:	55 95       	asr	r21
 ae0:	47 95       	ror	r20
 ae2:	8a 95       	dec	r24
 ae4:	e2 f7       	brpl	.-8      	; 0xade <MDIO_GetPinVal+0x76>
 ae6:	ca 01       	movw	r24, r20
 ae8:	81 70       	andi	r24, 0x01	; 1
 aea:	89 83       	std	Y+1, r24	; 0x01
 aec:	35 c0       	rjmp	.+106    	; 0xb58 <MDIO_GetPinVal+0xf0>
			break;
		case DIO_PORTB:
			local_PinValue = GET_BIT(PINB_REG,A_pinID);
 aee:	e6 e3       	ldi	r30, 0x36	; 54
 af0:	f0 e0       	ldi	r31, 0x00	; 0
 af2:	80 81       	ld	r24, Z
 af4:	28 2f       	mov	r18, r24
 af6:	30 e0       	ldi	r19, 0x00	; 0
 af8:	8b 81       	ldd	r24, Y+3	; 0x03
 afa:	88 2f       	mov	r24, r24
 afc:	90 e0       	ldi	r25, 0x00	; 0
 afe:	a9 01       	movw	r20, r18
 b00:	02 c0       	rjmp	.+4      	; 0xb06 <MDIO_GetPinVal+0x9e>
 b02:	55 95       	asr	r21
 b04:	47 95       	ror	r20
 b06:	8a 95       	dec	r24
 b08:	e2 f7       	brpl	.-8      	; 0xb02 <MDIO_GetPinVal+0x9a>
 b0a:	ca 01       	movw	r24, r20
 b0c:	81 70       	andi	r24, 0x01	; 1
 b0e:	89 83       	std	Y+1, r24	; 0x01
 b10:	23 c0       	rjmp	.+70     	; 0xb58 <MDIO_GetPinVal+0xf0>
			break;
		case DIO_PORTC:
			local_PinValue = GET_BIT(PINC_REG,A_pinID);
 b12:	e3 e3       	ldi	r30, 0x33	; 51
 b14:	f0 e0       	ldi	r31, 0x00	; 0
 b16:	80 81       	ld	r24, Z
 b18:	28 2f       	mov	r18, r24
 b1a:	30 e0       	ldi	r19, 0x00	; 0
 b1c:	8b 81       	ldd	r24, Y+3	; 0x03
 b1e:	88 2f       	mov	r24, r24
 b20:	90 e0       	ldi	r25, 0x00	; 0
 b22:	a9 01       	movw	r20, r18
 b24:	02 c0       	rjmp	.+4      	; 0xb2a <MDIO_GetPinVal+0xc2>
 b26:	55 95       	asr	r21
 b28:	47 95       	ror	r20
 b2a:	8a 95       	dec	r24
 b2c:	e2 f7       	brpl	.-8      	; 0xb26 <MDIO_GetPinVal+0xbe>
 b2e:	ca 01       	movw	r24, r20
 b30:	81 70       	andi	r24, 0x01	; 1
 b32:	89 83       	std	Y+1, r24	; 0x01
 b34:	11 c0       	rjmp	.+34     	; 0xb58 <MDIO_GetPinVal+0xf0>
			break;
		case DIO_PORTD:
			local_PinValue = GET_BIT(PIND_REG,A_pinID);
 b36:	e0 e3       	ldi	r30, 0x30	; 48
 b38:	f0 e0       	ldi	r31, 0x00	; 0
 b3a:	80 81       	ld	r24, Z
 b3c:	28 2f       	mov	r18, r24
 b3e:	30 e0       	ldi	r19, 0x00	; 0
 b40:	8b 81       	ldd	r24, Y+3	; 0x03
 b42:	88 2f       	mov	r24, r24
 b44:	90 e0       	ldi	r25, 0x00	; 0
 b46:	a9 01       	movw	r20, r18
 b48:	02 c0       	rjmp	.+4      	; 0xb4e <MDIO_GetPinVal+0xe6>
 b4a:	55 95       	asr	r21
 b4c:	47 95       	ror	r20
 b4e:	8a 95       	dec	r24
 b50:	e2 f7       	brpl	.-8      	; 0xb4a <MDIO_GetPinVal+0xe2>
 b52:	ca 01       	movw	r24, r20
 b54:	81 70       	andi	r24, 0x01	; 1
 b56:	89 83       	std	Y+1, r24	; 0x01
	{
		// Do Nothing
	}


	return local_PinValue;
 b58:	89 81       	ldd	r24, Y+1	; 0x01
}
 b5a:	0f 90       	pop	r0
 b5c:	0f 90       	pop	r0
 b5e:	0f 90       	pop	r0
 b60:	0f 90       	pop	r0
 b62:	0f 90       	pop	r0
 b64:	cf 91       	pop	r28
 b66:	df 91       	pop	r29
 b68:	08 95       	ret

00000b6a <MDIO_vTogglePinVal>:

void MDIO_vTogglePinVal (DIO_PORT_e A_portID, DIO_PIN_e A_pinID)
{
 b6a:	df 93       	push	r29
 b6c:	cf 93       	push	r28
 b6e:	00 d0       	rcall	.+0      	; 0xb70 <MDIO_vTogglePinVal+0x6>
 b70:	00 d0       	rcall	.+0      	; 0xb72 <MDIO_vTogglePinVal+0x8>
 b72:	cd b7       	in	r28, 0x3d	; 61
 b74:	de b7       	in	r29, 0x3e	; 62
 b76:	89 83       	std	Y+1, r24	; 0x01
 b78:	6a 83       	std	Y+2, r22	; 0x02
	// Input Validation
	if ( (A_portID <= DIO_PORTD) && (A_pinID <= PIN7) )
 b7a:	89 81       	ldd	r24, Y+1	; 0x01
 b7c:	84 30       	cpi	r24, 0x04	; 4
 b7e:	08 f0       	brcs	.+2      	; 0xb82 <MDIO_vTogglePinVal+0x18>
 b80:	72 c0       	rjmp	.+228    	; 0xc66 <MDIO_vTogglePinVal+0xfc>
 b82:	8a 81       	ldd	r24, Y+2	; 0x02
 b84:	88 30       	cpi	r24, 0x08	; 8
 b86:	08 f0       	brcs	.+2      	; 0xb8a <MDIO_vTogglePinVal+0x20>
 b88:	6e c0       	rjmp	.+220    	; 0xc66 <MDIO_vTogglePinVal+0xfc>
	{
		switch (A_portID)
 b8a:	89 81       	ldd	r24, Y+1	; 0x01
 b8c:	28 2f       	mov	r18, r24
 b8e:	30 e0       	ldi	r19, 0x00	; 0
 b90:	3c 83       	std	Y+4, r19	; 0x04
 b92:	2b 83       	std	Y+3, r18	; 0x03
 b94:	8b 81       	ldd	r24, Y+3	; 0x03
 b96:	9c 81       	ldd	r25, Y+4	; 0x04
 b98:	81 30       	cpi	r24, 0x01	; 1
 b9a:	91 05       	cpc	r25, r1
 b9c:	49 f1       	breq	.+82     	; 0xbf0 <MDIO_vTogglePinVal+0x86>
 b9e:	2b 81       	ldd	r18, Y+3	; 0x03
 ba0:	3c 81       	ldd	r19, Y+4	; 0x04
 ba2:	22 30       	cpi	r18, 0x02	; 2
 ba4:	31 05       	cpc	r19, r1
 ba6:	2c f4       	brge	.+10     	; 0xbb2 <MDIO_vTogglePinVal+0x48>
 ba8:	8b 81       	ldd	r24, Y+3	; 0x03
 baa:	9c 81       	ldd	r25, Y+4	; 0x04
 bac:	00 97       	sbiw	r24, 0x00	; 0
 bae:	61 f0       	breq	.+24     	; 0xbc8 <MDIO_vTogglePinVal+0x5e>
 bb0:	5a c0       	rjmp	.+180    	; 0xc66 <MDIO_vTogglePinVal+0xfc>
 bb2:	2b 81       	ldd	r18, Y+3	; 0x03
 bb4:	3c 81       	ldd	r19, Y+4	; 0x04
 bb6:	22 30       	cpi	r18, 0x02	; 2
 bb8:	31 05       	cpc	r19, r1
 bba:	71 f1       	breq	.+92     	; 0xc18 <MDIO_vTogglePinVal+0xae>
 bbc:	8b 81       	ldd	r24, Y+3	; 0x03
 bbe:	9c 81       	ldd	r25, Y+4	; 0x04
 bc0:	83 30       	cpi	r24, 0x03	; 3
 bc2:	91 05       	cpc	r25, r1
 bc4:	e9 f1       	breq	.+122    	; 0xc40 <MDIO_vTogglePinVal+0xd6>
 bc6:	4f c0       	rjmp	.+158    	; 0xc66 <MDIO_vTogglePinVal+0xfc>
		{
		case DIO_PORTA:
			TOGGLE_BIT(PORTA_REG,A_pinID);
 bc8:	ab e3       	ldi	r26, 0x3B	; 59
 bca:	b0 e0       	ldi	r27, 0x00	; 0
 bcc:	eb e3       	ldi	r30, 0x3B	; 59
 bce:	f0 e0       	ldi	r31, 0x00	; 0
 bd0:	80 81       	ld	r24, Z
 bd2:	48 2f       	mov	r20, r24
 bd4:	8a 81       	ldd	r24, Y+2	; 0x02
 bd6:	28 2f       	mov	r18, r24
 bd8:	30 e0       	ldi	r19, 0x00	; 0
 bda:	81 e0       	ldi	r24, 0x01	; 1
 bdc:	90 e0       	ldi	r25, 0x00	; 0
 bde:	02 2e       	mov	r0, r18
 be0:	02 c0       	rjmp	.+4      	; 0xbe6 <MDIO_vTogglePinVal+0x7c>
 be2:	88 0f       	add	r24, r24
 be4:	99 1f       	adc	r25, r25
 be6:	0a 94       	dec	r0
 be8:	e2 f7       	brpl	.-8      	; 0xbe2 <MDIO_vTogglePinVal+0x78>
 bea:	84 27       	eor	r24, r20
 bec:	8c 93       	st	X, r24
 bee:	3b c0       	rjmp	.+118    	; 0xc66 <MDIO_vTogglePinVal+0xfc>
			break;
		case DIO_PORTB:
			TOGGLE_BIT(PORTB_REG,A_pinID);
 bf0:	a8 e3       	ldi	r26, 0x38	; 56
 bf2:	b0 e0       	ldi	r27, 0x00	; 0
 bf4:	e8 e3       	ldi	r30, 0x38	; 56
 bf6:	f0 e0       	ldi	r31, 0x00	; 0
 bf8:	80 81       	ld	r24, Z
 bfa:	48 2f       	mov	r20, r24
 bfc:	8a 81       	ldd	r24, Y+2	; 0x02
 bfe:	28 2f       	mov	r18, r24
 c00:	30 e0       	ldi	r19, 0x00	; 0
 c02:	81 e0       	ldi	r24, 0x01	; 1
 c04:	90 e0       	ldi	r25, 0x00	; 0
 c06:	02 2e       	mov	r0, r18
 c08:	02 c0       	rjmp	.+4      	; 0xc0e <MDIO_vTogglePinVal+0xa4>
 c0a:	88 0f       	add	r24, r24
 c0c:	99 1f       	adc	r25, r25
 c0e:	0a 94       	dec	r0
 c10:	e2 f7       	brpl	.-8      	; 0xc0a <MDIO_vTogglePinVal+0xa0>
 c12:	84 27       	eor	r24, r20
 c14:	8c 93       	st	X, r24
 c16:	27 c0       	rjmp	.+78     	; 0xc66 <MDIO_vTogglePinVal+0xfc>
			break;
		case DIO_PORTC:
			TOGGLE_BIT(PORTC_REG,A_pinID);
 c18:	a5 e3       	ldi	r26, 0x35	; 53
 c1a:	b0 e0       	ldi	r27, 0x00	; 0
 c1c:	e5 e3       	ldi	r30, 0x35	; 53
 c1e:	f0 e0       	ldi	r31, 0x00	; 0
 c20:	80 81       	ld	r24, Z
 c22:	48 2f       	mov	r20, r24
 c24:	8a 81       	ldd	r24, Y+2	; 0x02
 c26:	28 2f       	mov	r18, r24
 c28:	30 e0       	ldi	r19, 0x00	; 0
 c2a:	81 e0       	ldi	r24, 0x01	; 1
 c2c:	90 e0       	ldi	r25, 0x00	; 0
 c2e:	02 2e       	mov	r0, r18
 c30:	02 c0       	rjmp	.+4      	; 0xc36 <MDIO_vTogglePinVal+0xcc>
 c32:	88 0f       	add	r24, r24
 c34:	99 1f       	adc	r25, r25
 c36:	0a 94       	dec	r0
 c38:	e2 f7       	brpl	.-8      	; 0xc32 <MDIO_vTogglePinVal+0xc8>
 c3a:	84 27       	eor	r24, r20
 c3c:	8c 93       	st	X, r24
 c3e:	13 c0       	rjmp	.+38     	; 0xc66 <MDIO_vTogglePinVal+0xfc>
			break;
		case DIO_PORTD:
			TOGGLE_BIT(PORTD_REG,A_pinID);
 c40:	a2 e3       	ldi	r26, 0x32	; 50
 c42:	b0 e0       	ldi	r27, 0x00	; 0
 c44:	e2 e3       	ldi	r30, 0x32	; 50
 c46:	f0 e0       	ldi	r31, 0x00	; 0
 c48:	80 81       	ld	r24, Z
 c4a:	48 2f       	mov	r20, r24
 c4c:	8a 81       	ldd	r24, Y+2	; 0x02
 c4e:	28 2f       	mov	r18, r24
 c50:	30 e0       	ldi	r19, 0x00	; 0
 c52:	81 e0       	ldi	r24, 0x01	; 1
 c54:	90 e0       	ldi	r25, 0x00	; 0
 c56:	02 2e       	mov	r0, r18
 c58:	02 c0       	rjmp	.+4      	; 0xc5e <MDIO_vTogglePinVal+0xf4>
 c5a:	88 0f       	add	r24, r24
 c5c:	99 1f       	adc	r25, r25
 c5e:	0a 94       	dec	r0
 c60:	e2 f7       	brpl	.-8      	; 0xc5a <MDIO_vTogglePinVal+0xf0>
 c62:	84 27       	eor	r24, r20
 c64:	8c 93       	st	X, r24
	}
	else
	{
		// Do Nothing
	}
}
 c66:	0f 90       	pop	r0
 c68:	0f 90       	pop	r0
 c6a:	0f 90       	pop	r0
 c6c:	0f 90       	pop	r0
 c6e:	cf 91       	pop	r28
 c70:	df 91       	pop	r29
 c72:	08 95       	ret

00000c74 <MDIO_vSetPortDir>:


void MDIO_vSetPortDir (DIO_PORT_e A_portID, u8 A_u8PortDirection)
{
 c74:	df 93       	push	r29
 c76:	cf 93       	push	r28
 c78:	00 d0       	rcall	.+0      	; 0xc7a <MDIO_vSetPortDir+0x6>
 c7a:	00 d0       	rcall	.+0      	; 0xc7c <MDIO_vSetPortDir+0x8>
 c7c:	cd b7       	in	r28, 0x3d	; 61
 c7e:	de b7       	in	r29, 0x3e	; 62
 c80:	89 83       	std	Y+1, r24	; 0x01
 c82:	6a 83       	std	Y+2, r22	; 0x02
	// Input Validation
	if ( (A_portID <= DIO_PORTD) )
 c84:	89 81       	ldd	r24, Y+1	; 0x01
 c86:	84 30       	cpi	r24, 0x04	; 4
 c88:	90 f5       	brcc	.+100    	; 0xcee <MDIO_vSetPortDir+0x7a>
	{
		switch (A_portID)
 c8a:	89 81       	ldd	r24, Y+1	; 0x01
 c8c:	28 2f       	mov	r18, r24
 c8e:	30 e0       	ldi	r19, 0x00	; 0
 c90:	3c 83       	std	Y+4, r19	; 0x04
 c92:	2b 83       	std	Y+3, r18	; 0x03
 c94:	8b 81       	ldd	r24, Y+3	; 0x03
 c96:	9c 81       	ldd	r25, Y+4	; 0x04
 c98:	81 30       	cpi	r24, 0x01	; 1
 c9a:	91 05       	cpc	r25, r1
 c9c:	d1 f0       	breq	.+52     	; 0xcd2 <MDIO_vSetPortDir+0x5e>
 c9e:	2b 81       	ldd	r18, Y+3	; 0x03
 ca0:	3c 81       	ldd	r19, Y+4	; 0x04
 ca2:	22 30       	cpi	r18, 0x02	; 2
 ca4:	31 05       	cpc	r19, r1
 ca6:	2c f4       	brge	.+10     	; 0xcb2 <MDIO_vSetPortDir+0x3e>
 ca8:	8b 81       	ldd	r24, Y+3	; 0x03
 caa:	9c 81       	ldd	r25, Y+4	; 0x04
 cac:	00 97       	sbiw	r24, 0x00	; 0
 cae:	61 f0       	breq	.+24     	; 0xcc8 <MDIO_vSetPortDir+0x54>
 cb0:	1e c0       	rjmp	.+60     	; 0xcee <MDIO_vSetPortDir+0x7a>
 cb2:	2b 81       	ldd	r18, Y+3	; 0x03
 cb4:	3c 81       	ldd	r19, Y+4	; 0x04
 cb6:	22 30       	cpi	r18, 0x02	; 2
 cb8:	31 05       	cpc	r19, r1
 cba:	81 f0       	breq	.+32     	; 0xcdc <MDIO_vSetPortDir+0x68>
 cbc:	8b 81       	ldd	r24, Y+3	; 0x03
 cbe:	9c 81       	ldd	r25, Y+4	; 0x04
 cc0:	83 30       	cpi	r24, 0x03	; 3
 cc2:	91 05       	cpc	r25, r1
 cc4:	81 f0       	breq	.+32     	; 0xce6 <MDIO_vSetPortDir+0x72>
 cc6:	13 c0       	rjmp	.+38     	; 0xcee <MDIO_vSetPortDir+0x7a>
		{
		case DIO_PORTA:
			DDRA_REG = A_u8PortDirection;
 cc8:	ea e3       	ldi	r30, 0x3A	; 58
 cca:	f0 e0       	ldi	r31, 0x00	; 0
 ccc:	8a 81       	ldd	r24, Y+2	; 0x02
 cce:	80 83       	st	Z, r24
 cd0:	0e c0       	rjmp	.+28     	; 0xcee <MDIO_vSetPortDir+0x7a>
			break;
		case DIO_PORTB:
			DDRB_REG = A_u8PortDirection;
 cd2:	e7 e3       	ldi	r30, 0x37	; 55
 cd4:	f0 e0       	ldi	r31, 0x00	; 0
 cd6:	8a 81       	ldd	r24, Y+2	; 0x02
 cd8:	80 83       	st	Z, r24
 cda:	09 c0       	rjmp	.+18     	; 0xcee <MDIO_vSetPortDir+0x7a>
			break;
		case DIO_PORTC:
			DDRC_REG = A_u8PortDirection;
 cdc:	e4 e3       	ldi	r30, 0x34	; 52
 cde:	f0 e0       	ldi	r31, 0x00	; 0
 ce0:	8a 81       	ldd	r24, Y+2	; 0x02
 ce2:	80 83       	st	Z, r24
 ce4:	04 c0       	rjmp	.+8      	; 0xcee <MDIO_vSetPortDir+0x7a>
			break;
		case DIO_PORTD:
			DDRD_REG = A_u8PortDirection;
 ce6:	e1 e3       	ldi	r30, 0x31	; 49
 ce8:	f0 e0       	ldi	r31, 0x00	; 0
 cea:	8a 81       	ldd	r24, Y+2	; 0x02
 cec:	80 83       	st	Z, r24
	}
	else
	{
		// Do Nothing
	}
}
 cee:	0f 90       	pop	r0
 cf0:	0f 90       	pop	r0
 cf2:	0f 90       	pop	r0
 cf4:	0f 90       	pop	r0
 cf6:	cf 91       	pop	r28
 cf8:	df 91       	pop	r29
 cfa:	08 95       	ret

00000cfc <MDIO_vSetPortVal>:

void MDIO_vSetPortVal (DIO_PORT_e A_portID, u8 A_u8PortValue)
{
 cfc:	df 93       	push	r29
 cfe:	cf 93       	push	r28
 d00:	00 d0       	rcall	.+0      	; 0xd02 <MDIO_vSetPortVal+0x6>
 d02:	00 d0       	rcall	.+0      	; 0xd04 <MDIO_vSetPortVal+0x8>
 d04:	cd b7       	in	r28, 0x3d	; 61
 d06:	de b7       	in	r29, 0x3e	; 62
 d08:	89 83       	std	Y+1, r24	; 0x01
 d0a:	6a 83       	std	Y+2, r22	; 0x02
	// Input Validation
	if ( (A_portID <= DIO_PORTD) )
 d0c:	89 81       	ldd	r24, Y+1	; 0x01
 d0e:	84 30       	cpi	r24, 0x04	; 4
 d10:	90 f5       	brcc	.+100    	; 0xd76 <MDIO_vSetPortVal+0x7a>
	{
		switch (A_portID)
 d12:	89 81       	ldd	r24, Y+1	; 0x01
 d14:	28 2f       	mov	r18, r24
 d16:	30 e0       	ldi	r19, 0x00	; 0
 d18:	3c 83       	std	Y+4, r19	; 0x04
 d1a:	2b 83       	std	Y+3, r18	; 0x03
 d1c:	8b 81       	ldd	r24, Y+3	; 0x03
 d1e:	9c 81       	ldd	r25, Y+4	; 0x04
 d20:	81 30       	cpi	r24, 0x01	; 1
 d22:	91 05       	cpc	r25, r1
 d24:	d1 f0       	breq	.+52     	; 0xd5a <MDIO_vSetPortVal+0x5e>
 d26:	2b 81       	ldd	r18, Y+3	; 0x03
 d28:	3c 81       	ldd	r19, Y+4	; 0x04
 d2a:	22 30       	cpi	r18, 0x02	; 2
 d2c:	31 05       	cpc	r19, r1
 d2e:	2c f4       	brge	.+10     	; 0xd3a <MDIO_vSetPortVal+0x3e>
 d30:	8b 81       	ldd	r24, Y+3	; 0x03
 d32:	9c 81       	ldd	r25, Y+4	; 0x04
 d34:	00 97       	sbiw	r24, 0x00	; 0
 d36:	61 f0       	breq	.+24     	; 0xd50 <MDIO_vSetPortVal+0x54>
 d38:	1e c0       	rjmp	.+60     	; 0xd76 <MDIO_vSetPortVal+0x7a>
 d3a:	2b 81       	ldd	r18, Y+3	; 0x03
 d3c:	3c 81       	ldd	r19, Y+4	; 0x04
 d3e:	22 30       	cpi	r18, 0x02	; 2
 d40:	31 05       	cpc	r19, r1
 d42:	81 f0       	breq	.+32     	; 0xd64 <MDIO_vSetPortVal+0x68>
 d44:	8b 81       	ldd	r24, Y+3	; 0x03
 d46:	9c 81       	ldd	r25, Y+4	; 0x04
 d48:	83 30       	cpi	r24, 0x03	; 3
 d4a:	91 05       	cpc	r25, r1
 d4c:	81 f0       	breq	.+32     	; 0xd6e <MDIO_vSetPortVal+0x72>
 d4e:	13 c0       	rjmp	.+38     	; 0xd76 <MDIO_vSetPortVal+0x7a>
		{
		case DIO_PORTA:
			PORTA_REG = A_u8PortValue;
 d50:	eb e3       	ldi	r30, 0x3B	; 59
 d52:	f0 e0       	ldi	r31, 0x00	; 0
 d54:	8a 81       	ldd	r24, Y+2	; 0x02
 d56:	80 83       	st	Z, r24
 d58:	0e c0       	rjmp	.+28     	; 0xd76 <MDIO_vSetPortVal+0x7a>
			break;
		case DIO_PORTB:
			PORTB_REG = A_u8PortValue;
 d5a:	e8 e3       	ldi	r30, 0x38	; 56
 d5c:	f0 e0       	ldi	r31, 0x00	; 0
 d5e:	8a 81       	ldd	r24, Y+2	; 0x02
 d60:	80 83       	st	Z, r24
 d62:	09 c0       	rjmp	.+18     	; 0xd76 <MDIO_vSetPortVal+0x7a>
			break;
		case DIO_PORTC:
			PORTC_REG = A_u8PortValue;
 d64:	e5 e3       	ldi	r30, 0x35	; 53
 d66:	f0 e0       	ldi	r31, 0x00	; 0
 d68:	8a 81       	ldd	r24, Y+2	; 0x02
 d6a:	80 83       	st	Z, r24
 d6c:	04 c0       	rjmp	.+8      	; 0xd76 <MDIO_vSetPortVal+0x7a>
			break;
		case DIO_PORTD:
			PORTD_REG = A_u8PortValue;
 d6e:	e2 e3       	ldi	r30, 0x32	; 50
 d70:	f0 e0       	ldi	r31, 0x00	; 0
 d72:	8a 81       	ldd	r24, Y+2	; 0x02
 d74:	80 83       	st	Z, r24
	}
	else
	{
		// Do Nothing
	}
}
 d76:	0f 90       	pop	r0
 d78:	0f 90       	pop	r0
 d7a:	0f 90       	pop	r0
 d7c:	0f 90       	pop	r0
 d7e:	cf 91       	pop	r28
 d80:	df 91       	pop	r29
 d82:	08 95       	ret

00000d84 <MDIO_vInit>:


void MDIO_vInit()
{
 d84:	df 93       	push	r29
 d86:	cf 93       	push	r28
 d88:	cd b7       	in	r28, 0x3d	; 61
 d8a:	de b7       	in	r29, 0x3e	; 62

	DDRA_REG = CONC_BIT(PA7_INITIAL_DIRECTION,PA6_INITIAL_DIRECTION,
 d8c:	ea e3       	ldi	r30, 0x3A	; 58
 d8e:	f0 e0       	ldi	r31, 0x00	; 0
 d90:	10 82       	st	Z, r1
						PA5_INITIAL_DIRECTION,PA4_INITIAL_DIRECTION,
						PA3_INITIAL_DIRECTION,PA2_INITIAL_DIRECTION,
						PA1_INITIAL_DIRECTION,PA0_INITIAL_DIRECTION);

	DDRB_REG = CONC_BIT(PB7_INITIAL_DIRECTION,PB6_INITIAL_DIRECTION,
 d92:	e7 e3       	ldi	r30, 0x37	; 55
 d94:	f0 e0       	ldi	r31, 0x00	; 0
 d96:	10 82       	st	Z, r1
						PB5_INITIAL_DIRECTION,PB4_INITIAL_DIRECTION,
						PB3_INITIAL_DIRECTION,PB2_INITIAL_DIRECTION,
						PB1_INITIAL_DIRECTION,PB0_INITIAL_DIRECTION);

	DDRC_REG = CONC_BIT(PC7_INITIAL_DIRECTION,PC6_INITIAL_DIRECTION,
 d98:	e4 e3       	ldi	r30, 0x34	; 52
 d9a:	f0 e0       	ldi	r31, 0x00	; 0
 d9c:	87 e0       	ldi	r24, 0x07	; 7
 d9e:	80 83       	st	Z, r24
						PC5_INITIAL_DIRECTION,PC4_INITIAL_DIRECTION,
						PC3_INITIAL_DIRECTION,PC2_INITIAL_DIRECTION,
						PC1_INITIAL_DIRECTION,PC0_INITIAL_DIRECTION);

	DDRD_REG = CONC_BIT(PD7_INITIAL_DIRECTION,PD6_INITIAL_DIRECTION,
 da0:	e1 e3       	ldi	r30, 0x31	; 49
 da2:	f0 e0       	ldi	r31, 0x00	; 0
 da4:	8f ef       	ldi	r24, 0xFF	; 255
 da6:	80 83       	st	Z, r24
						PD3_INITIAL_DIRECTION,PD2_INITIAL_DIRECTION,
						PD1_INITIAL_DIRECTION,PD0_INITIAL_DIRECTION);

	/**********************************************************************/

	PORTA_REG = CONC_BIT(PA7_INITIAL_VALUE,PA6_INITIAL_VALUE,
 da8:	eb e3       	ldi	r30, 0x3B	; 59
 daa:	f0 e0       	ldi	r31, 0x00	; 0
 dac:	10 82       	st	Z, r1
						 PA5_INITIAL_VALUE,PA4_INITIAL_VALUE,
						 PA3_INITIAL_VALUE,PA2_INITIAL_VALUE,
						 PA1_INITIAL_VALUE,PA0_INITIAL_VALUE);

	PORTB_REG = CONC_BIT(PB7_INITIAL_VALUE,PB6_INITIAL_VALUE,
 dae:	e8 e3       	ldi	r30, 0x38	; 56
 db0:	f0 e0       	ldi	r31, 0x00	; 0
 db2:	84 e0       	ldi	r24, 0x04	; 4
 db4:	80 83       	st	Z, r24
						 PB5_INITIAL_VALUE,PB4_INITIAL_VALUE,
						 PB3_INITIAL_VALUE,PB2_INITIAL_VALUE,
						 PB1_INITIAL_VALUE,PB0_INITIAL_VALUE);

	PORTC_REG = CONC_BIT(PC7_INITIAL_VALUE,PC6_INITIAL_VALUE,
 db6:	e5 e3       	ldi	r30, 0x35	; 53
 db8:	f0 e0       	ldi	r31, 0x00	; 0
 dba:	10 82       	st	Z, r1
						 PC5_INITIAL_VALUE,PC4_INITIAL_VALUE,
						 PC3_INITIAL_VALUE,PC2_INITIAL_VALUE,
						 PC1_INITIAL_VALUE,PC0_INITIAL_VALUE);

	PORTD_REG = CONC_BIT(PD7_INITIAL_VALUE,PD6_INITIAL_VALUE,
 dbc:	e2 e3       	ldi	r30, 0x32	; 50
 dbe:	f0 e0       	ldi	r31, 0x00	; 0
 dc0:	10 82       	st	Z, r1
						 PD5_INITIAL_VALUE,PD4_INITIAL_VALUE,
						 PD3_INITIAL_VALUE,PD2_INITIAL_VALUE,
						 PD1_INITIAL_VALUE,PD0_INITIAL_VALUE);
}
 dc2:	cf 91       	pop	r28
 dc4:	df 91       	pop	r29
 dc6:	08 95       	ret

00000dc8 <ADC_Init>:
static u16 *Global_ptr =0;
static void (*GlobalPtrFunc)(void)=NULL;
static u8 ADC_STATE=IDLE;

void ADC_Init(void)
{
 dc8:	df 93       	push	r29
 dca:	cf 93       	push	r28
 dcc:	cd b7       	in	r28, 0x3d	; 61
 dce:	de b7       	in	r29, 0x3e	; 62
	 // No interrupt
	CLR_BIT(ADCSRA , ADIE);
 dd0:	a6 e2       	ldi	r26, 0x26	; 38
 dd2:	b0 e0       	ldi	r27, 0x00	; 0
 dd4:	e6 e2       	ldi	r30, 0x26	; 38
 dd6:	f0 e0       	ldi	r31, 0x00	; 0
 dd8:	80 81       	ld	r24, Z
 dda:	87 7f       	andi	r24, 0xF7	; 247
 ddc:	8c 93       	st	X, r24

	// REF -> AVCC
	SET_BIT(ADMUX , REFS0);
 dde:	a7 e2       	ldi	r26, 0x27	; 39
 de0:	b0 e0       	ldi	r27, 0x00	; 0
 de2:	e7 e2       	ldi	r30, 0x27	; 39
 de4:	f0 e0       	ldi	r31, 0x00	; 0
 de6:	80 81       	ld	r24, Z
 de8:	80 64       	ori	r24, 0x40	; 64
 dea:	8c 93       	st	X, r24
	CLR_BIT(ADMUX , REFS1);
 dec:	a7 e2       	ldi	r26, 0x27	; 39
 dee:	b0 e0       	ldi	r27, 0x00	; 0
 df0:	e7 e2       	ldi	r30, 0x27	; 39
 df2:	f0 e0       	ldi	r31, 0x00	; 0
 df4:	80 81       	ld	r24, Z
 df6:	8f 77       	andi	r24, 0x7F	; 127
 df8:	8c 93       	st	X, r24

	// Set Prescaler -> 128
	SET_BIT(ADCSRA , ADPS0);
 dfa:	a6 e2       	ldi	r26, 0x26	; 38
 dfc:	b0 e0       	ldi	r27, 0x00	; 0
 dfe:	e6 e2       	ldi	r30, 0x26	; 38
 e00:	f0 e0       	ldi	r31, 0x00	; 0
 e02:	80 81       	ld	r24, Z
 e04:	81 60       	ori	r24, 0x01	; 1
 e06:	8c 93       	st	X, r24
	SET_BIT(ADCSRA , ADPS1);
 e08:	a6 e2       	ldi	r26, 0x26	; 38
 e0a:	b0 e0       	ldi	r27, 0x00	; 0
 e0c:	e6 e2       	ldi	r30, 0x26	; 38
 e0e:	f0 e0       	ldi	r31, 0x00	; 0
 e10:	80 81       	ld	r24, Z
 e12:	82 60       	ori	r24, 0x02	; 2
 e14:	8c 93       	st	X, r24
	SET_BIT(ADCSRA , ADPS2);
 e16:	a6 e2       	ldi	r26, 0x26	; 38
 e18:	b0 e0       	ldi	r27, 0x00	; 0
 e1a:	e6 e2       	ldi	r30, 0x26	; 38
 e1c:	f0 e0       	ldi	r31, 0x00	; 0
 e1e:	80 81       	ld	r24, Z
 e20:	84 60       	ori	r24, 0x04	; 4
 e22:	8c 93       	st	X, r24

	// ADC Enable
	SET_BIT(ADCSRA , ADEN);
 e24:	a6 e2       	ldi	r26, 0x26	; 38
 e26:	b0 e0       	ldi	r27, 0x00	; 0
 e28:	e6 e2       	ldi	r30, 0x26	; 38
 e2a:	f0 e0       	ldi	r31, 0x00	; 0
 e2c:	80 81       	ld	r24, Z
 e2e:	80 68       	ori	r24, 0x80	; 128
 e30:	8c 93       	st	X, r24
}
 e32:	cf 91       	pop	r28
 e34:	df 91       	pop	r29
 e36:	08 95       	ret

00000e38 <ADC_StartConvertPolling>:

u16 ADC_StartConvertPolling(u8 Copy_u8Channel)
{
 e38:	df 93       	push	r29
 e3a:	cf 93       	push	r28
 e3c:	00 d0       	rcall	.+0      	; 0xe3e <ADC_StartConvertPolling+0x6>
 e3e:	0f 92       	push	r0
 e40:	cd b7       	in	r28, 0x3d	; 61
 e42:	de b7       	in	r29, 0x3e	; 62
 e44:	8b 83       	std	Y+3, r24	; 0x03
	u16 ADC_read=0;
 e46:	1a 82       	std	Y+2, r1	; 0x02
 e48:	19 82       	std	Y+1, r1	; 0x01

	ADMUX &=0b11100000;
 e4a:	a7 e2       	ldi	r26, 0x27	; 39
 e4c:	b0 e0       	ldi	r27, 0x00	; 0
 e4e:	e7 e2       	ldi	r30, 0x27	; 39
 e50:	f0 e0       	ldi	r31, 0x00	; 0
 e52:	80 81       	ld	r24, Z
 e54:	80 7e       	andi	r24, 0xE0	; 224
 e56:	8c 93       	st	X, r24
	ADMUX |=Copy_u8Channel;
 e58:	a7 e2       	ldi	r26, 0x27	; 39
 e5a:	b0 e0       	ldi	r27, 0x00	; 0
 e5c:	e7 e2       	ldi	r30, 0x27	; 39
 e5e:	f0 e0       	ldi	r31, 0x00	; 0
 e60:	90 81       	ld	r25, Z
 e62:	8b 81       	ldd	r24, Y+3	; 0x03
 e64:	89 2b       	or	r24, r25
 e66:	8c 93       	st	X, r24

	// Start Conversion

	SET_BIT(ADCSRA , ADSC);
 e68:	a6 e2       	ldi	r26, 0x26	; 38
 e6a:	b0 e0       	ldi	r27, 0x00	; 0
 e6c:	e6 e2       	ldi	r30, 0x26	; 38
 e6e:	f0 e0       	ldi	r31, 0x00	; 0
 e70:	80 81       	ld	r24, Z
 e72:	80 64       	ori	r24, 0x40	; 64
 e74:	8c 93       	st	X, r24

	while(GET_BIT(ADCSRA , ADIF) == 0)
 e76:	e6 e2       	ldi	r30, 0x26	; 38
 e78:	f0 e0       	ldi	r31, 0x00	; 0
 e7a:	80 81       	ld	r24, Z
 e7c:	82 95       	swap	r24
 e7e:	8f 70       	andi	r24, 0x0F	; 15
 e80:	88 2f       	mov	r24, r24
 e82:	90 e0       	ldi	r25, 0x00	; 0
 e84:	81 70       	andi	r24, 0x01	; 1
 e86:	90 70       	andi	r25, 0x00	; 0
 e88:	00 97       	sbiw	r24, 0x00	; 0
 e8a:	a9 f3       	breq	.-22     	; 0xe76 <ADC_StartConvertPolling+0x3e>
	{

	}
	ADC_read = ADCLH;
 e8c:	e4 e2       	ldi	r30, 0x24	; 36
 e8e:	f0 e0       	ldi	r31, 0x00	; 0
 e90:	80 81       	ld	r24, Z
 e92:	91 81       	ldd	r25, Z+1	; 0x01
 e94:	9a 83       	std	Y+2, r25	; 0x02
 e96:	89 83       	std	Y+1, r24	; 0x01
	SET_BIT(ADCSRA , ADIF);
 e98:	a6 e2       	ldi	r26, 0x26	; 38
 e9a:	b0 e0       	ldi	r27, 0x00	; 0
 e9c:	e6 e2       	ldi	r30, 0x26	; 38
 e9e:	f0 e0       	ldi	r31, 0x00	; 0
 ea0:	80 81       	ld	r24, Z
 ea2:	80 61       	ori	r24, 0x10	; 16
 ea4:	8c 93       	st	X, r24
	return ADC_read;
 ea6:	89 81       	ldd	r24, Y+1	; 0x01
 ea8:	9a 81       	ldd	r25, Y+2	; 0x02
}
 eaa:	0f 90       	pop	r0
 eac:	0f 90       	pop	r0
 eae:	0f 90       	pop	r0
 eb0:	cf 91       	pop	r28
 eb2:	df 91       	pop	r29
 eb4:	08 95       	ret

00000eb6 <ADC_StartConvertInt>:

u8 ADC_StartConvertInt(u8 Copy_u8Channel , u16 *pu16Reading , void(*PtrFunc)(void))
{
 eb6:	df 93       	push	r29
 eb8:	cf 93       	push	r28
 eba:	00 d0       	rcall	.+0      	; 0xebc <ADC_StartConvertInt+0x6>
 ebc:	00 d0       	rcall	.+0      	; 0xebe <ADC_StartConvertInt+0x8>
 ebe:	00 d0       	rcall	.+0      	; 0xec0 <ADC_StartConvertInt+0xa>
 ec0:	cd b7       	in	r28, 0x3d	; 61
 ec2:	de b7       	in	r29, 0x3e	; 62
 ec4:	8a 83       	std	Y+2, r24	; 0x02
 ec6:	7c 83       	std	Y+4, r23	; 0x04
 ec8:	6b 83       	std	Y+3, r22	; 0x03
 eca:	5e 83       	std	Y+6, r21	; 0x06
 ecc:	4d 83       	std	Y+5, r20	; 0x05
	u8 Local_u8Error = OK;
 ece:	19 82       	std	Y+1, r1	; 0x01

	if(ADC_STATE == IDLE)
 ed0:	80 91 69 00 	lds	r24, 0x0069
 ed4:	88 23       	and	r24, r24
 ed6:	69 f5       	brne	.+90     	; 0xf32 <ADC_StartConvertInt+0x7c>
	{
		if((NULL != pu16Reading)&& (NULL != PtrFunc) );\
		{
			ADC_STATE = BUSY;
 ed8:	81 e0       	ldi	r24, 0x01	; 1
 eda:	80 93 69 00 	sts	0x0069, r24
			Global_ptr=pu16Reading;
 ede:	8b 81       	ldd	r24, Y+3	; 0x03
 ee0:	9c 81       	ldd	r25, Y+4	; 0x04
 ee2:	90 93 66 00 	sts	0x0066, r25
 ee6:	80 93 65 00 	sts	0x0065, r24
			GlobalPtrFunc = PtrFunc;
 eea:	8d 81       	ldd	r24, Y+5	; 0x05
 eec:	9e 81       	ldd	r25, Y+6	; 0x06
 eee:	90 93 68 00 	sts	0x0068, r25
 ef2:	80 93 67 00 	sts	0x0067, r24

			ADMUX &=0b11100000;
 ef6:	a7 e2       	ldi	r26, 0x27	; 39
 ef8:	b0 e0       	ldi	r27, 0x00	; 0
 efa:	e7 e2       	ldi	r30, 0x27	; 39
 efc:	f0 e0       	ldi	r31, 0x00	; 0
 efe:	80 81       	ld	r24, Z
 f00:	80 7e       	andi	r24, 0xE0	; 224
 f02:	8c 93       	st	X, r24
			ADMUX |=Copy_u8Channel;
 f04:	a7 e2       	ldi	r26, 0x27	; 39
 f06:	b0 e0       	ldi	r27, 0x00	; 0
 f08:	e7 e2       	ldi	r30, 0x27	; 39
 f0a:	f0 e0       	ldi	r31, 0x00	; 0
 f0c:	90 81       	ld	r25, Z
 f0e:	8a 81       	ldd	r24, Y+2	; 0x02
 f10:	89 2b       	or	r24, r25
 f12:	8c 93       	st	X, r24
			// Enable ADC Interrupt
			SET_BIT(ADCSRA , ADIE);
 f14:	a6 e2       	ldi	r26, 0x26	; 38
 f16:	b0 e0       	ldi	r27, 0x00	; 0
 f18:	e6 e2       	ldi	r30, 0x26	; 38
 f1a:	f0 e0       	ldi	r31, 0x00	; 0
 f1c:	80 81       	ld	r24, Z
 f1e:	88 60       	ori	r24, 0x08	; 8
 f20:	8c 93       	st	X, r24
			// Start Conversion
			SET_BIT(ADCSRA , ADSC);
 f22:	a6 e2       	ldi	r26, 0x26	; 38
 f24:	b0 e0       	ldi	r27, 0x00	; 0
 f26:	e6 e2       	ldi	r30, 0x26	; 38
 f28:	f0 e0       	ldi	r31, 0x00	; 0
 f2a:	80 81       	ld	r24, Z
 f2c:	80 64       	ori	r24, 0x40	; 64
 f2e:	8c 93       	st	X, r24
 f30:	02 c0       	rjmp	.+4      	; 0xf36 <ADC_StartConvertInt+0x80>
		}
	}
	else
	{
		Local_u8Error = NOK;
 f32:	81 e0       	ldi	r24, 0x01	; 1
 f34:	89 83       	std	Y+1, r24	; 0x01
	}
	return Local_u8Error;
 f36:	89 81       	ldd	r24, Y+1	; 0x01
}
 f38:	26 96       	adiw	r28, 0x06	; 6
 f3a:	0f b6       	in	r0, 0x3f	; 63
 f3c:	f8 94       	cli
 f3e:	de bf       	out	0x3e, r29	; 62
 f40:	0f be       	out	0x3f, r0	; 63
 f42:	cd bf       	out	0x3d, r28	; 61
 f44:	cf 91       	pop	r28
 f46:	df 91       	pop	r29
 f48:	08 95       	ret

00000f4a <__vector_16>:

void __vector_16(void) __attribute__((signal));
void __vector_16(void)
{
 f4a:	1f 92       	push	r1
 f4c:	0f 92       	push	r0
 f4e:	0f b6       	in	r0, 0x3f	; 63
 f50:	0f 92       	push	r0
 f52:	11 24       	eor	r1, r1
 f54:	2f 93       	push	r18
 f56:	3f 93       	push	r19
 f58:	4f 93       	push	r20
 f5a:	5f 93       	push	r21
 f5c:	6f 93       	push	r22
 f5e:	7f 93       	push	r23
 f60:	8f 93       	push	r24
 f62:	9f 93       	push	r25
 f64:	af 93       	push	r26
 f66:	bf 93       	push	r27
 f68:	ef 93       	push	r30
 f6a:	ff 93       	push	r31
 f6c:	df 93       	push	r29
 f6e:	cf 93       	push	r28
 f70:	cd b7       	in	r28, 0x3d	; 61
 f72:	de b7       	in	r29, 0x3e	; 62
	// Return Reading
	*Global_ptr =ADCLH;
 f74:	a0 91 65 00 	lds	r26, 0x0065
 f78:	b0 91 66 00 	lds	r27, 0x0066
 f7c:	e4 e2       	ldi	r30, 0x24	; 36
 f7e:	f0 e0       	ldi	r31, 0x00	; 0
 f80:	80 81       	ld	r24, Z
 f82:	91 81       	ldd	r25, Z+1	; 0x01
 f84:	8d 93       	st	X+, r24
 f86:	9c 93       	st	X, r25

	// exe function
	GlobalPtrFunc();
 f88:	e0 91 67 00 	lds	r30, 0x0067
 f8c:	f0 91 68 00 	lds	r31, 0x0068
 f90:	09 95       	icall

	//Interrutpt Disable
	CLR_BIT(ADCSRA , ADIE);
 f92:	a6 e2       	ldi	r26, 0x26	; 38
 f94:	b0 e0       	ldi	r27, 0x00	; 0
 f96:	e6 e2       	ldi	r30, 0x26	; 38
 f98:	f0 e0       	ldi	r31, 0x00	; 0
 f9a:	80 81       	ld	r24, Z
 f9c:	87 7f       	andi	r24, 0xF7	; 247
 f9e:	8c 93       	st	X, r24

	// Change the State
	ADC_STATE = IDLE;
 fa0:	10 92 69 00 	sts	0x0069, r1



}
 fa4:	cf 91       	pop	r28
 fa6:	df 91       	pop	r29
 fa8:	ff 91       	pop	r31
 faa:	ef 91       	pop	r30
 fac:	bf 91       	pop	r27
 fae:	af 91       	pop	r26
 fb0:	9f 91       	pop	r25
 fb2:	8f 91       	pop	r24
 fb4:	7f 91       	pop	r23
 fb6:	6f 91       	pop	r22
 fb8:	5f 91       	pop	r21
 fba:	4f 91       	pop	r20
 fbc:	3f 91       	pop	r19
 fbe:	2f 91       	pop	r18
 fc0:	0f 90       	pop	r0
 fc2:	0f be       	out	0x3f, r0	; 63
 fc4:	0f 90       	pop	r0
 fc6:	1f 90       	pop	r1
 fc8:	18 95       	reti

00000fca <_exit>:
 fca:	f8 94       	cli

00000fcc <__stop_program>:
 fcc:	ff cf       	rjmp	.-2      	; 0xfcc <__stop_program>
